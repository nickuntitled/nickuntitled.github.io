<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://nickuntitled.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nickuntitled.com/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-03-26T13:44:09+07:00</updated><id>https://nickuntitled.com/feed.xml</id><title type="html">Nick Untitled</title><subtitle>A Nick's Journal on my Life</subtitle><author><name>Nick Untitled</name><email>contact@nickuntitled.com</email></author><entry><title type="html">นำอุปกรณ์ Samsung มาใช้เขียนโปรแกรมแทนที่เดสก์ท็อป และโน้ตบุ๊ค โดย Samsung DeX</title><link href="https://nickuntitled.com/2022/03/26/samsung_dex_programming_replace_desktop/" rel="alternate" type="text/html" title="นำอุปกรณ์ Samsung มาใช้เขียนโปรแกรมแทนที่เดสก์ท็อป และโน้ตบุ๊ค โดย Samsung DeX" /><published>2022-03-26T13:30:00+07:00</published><updated>2022-03-26T13:30:00+07:00</updated><id>https://nickuntitled.com/2022/03/26/samsung-dex-programming-machine</id><content type="html" xml:base="https://nickuntitled.com/2022/03/26/samsung_dex_programming_replace_desktop/">&lt;p&gt;ภาคต่อจาก&lt;a href=&quot;https://nickuntitled.com/2022/03/20/android_as_programming_pc_replacement/&quot;&gt;บทความก่อนหน้า&lt;/a&gt;ที่นำอุปกรณ์แอนดรอยด์มาติดตั้งโปรแกรม termux ร่วมกับการติดตั้งเครื่องมือการพัฒนาโปรแกรม รวมถึง IDE ที่จำเป็นมาใช้งาน ทีนี้เรามาพูดถึงอุปกรณ์แอนดรอยด์ที่คนใช้งานกันนั่นก็คือมือถือหรือแท็บเล็ตของซัมซุง&lt;/p&gt;

&lt;p&gt;มือถือ หรือแท็บเล็ตของซัมซุงมีฟังก์ชันหนึ่งที่ทำให้เวลาที่เราต่อออกหน้าจอแล้วเป็นเดสก์ท็อปได้เลยผ่านการเสียบสาย USB-C ออกมาต่อเข้ากับจอผ่าน USB-C/HDMI/DisplayPort หรืออื่น ๆ โดยฟังก์ชันนี้เรียกว่า Samsung DeX&lt;/p&gt;

&lt;h2 id=&quot;samsung-dex&quot;&gt;Samsung DeX&lt;/h2&gt;

&lt;p&gt;Samsung DeX (หรือชื่อเต็มของมันเรียกว่า Samsung Desktop eXperience) เป็นฟังก์ชันที่ทำให้ชีวิตดีขึ้นมากกว่าเดิมเมื่อเทียบกับแต่ก่อนที่เวลาต่อออกหน้าจอคอมพิวเตอร์ทั่วไปแล้วมันจะเป็นหน้าจอแอนดรอยด์เหมือนกับบนหน้าจอมือถือ แต่มีขนาดใหญ่กว่า โดยฟังก์ชันนี้มีมานานแล้ว ตั้งแต่มือถือ Samsung Galaxy S8/S8+ เป็นต้นมา จนปัจจุบันมีให้ใช้ในมือถือ แล้วยังมีให้ใช้บนแท็บเล็ตอีกด้วยครับ (แต่ฟังก์ชันนี้ไม่ได้มีครบทุกรุ่นนะ ต้องเช็คกับทางซัมซุงอีกที)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;สำหรับคนที่ใช้มือถือยี่ห้ออื่นก็ไม่ต้องเสียใจไป เพราะมือถือหัวเว่ย (Huawei) ก็มีฟังก์ชันที่ต่อออกจอเป็นเดสก์ท็อปได้เช่นกัน โดยฟังก์ชันนี้มีชื่อว่า Huawei Easy Projection&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;เมื่อมี Samsung DeX แล้วยังไงต่อล่ะ อย่างแรกที่ต้องทำเลยก็คือการเตรียมอุปกรณ์&lt;/p&gt;

&lt;h2 id=&quot;การเตรียมอุปกรณ์เพื่อใช้งาน-samsung-dex&quot;&gt;การเตรียมอุปกรณ์เพื่อใช้งาน Samsung DeX&lt;/h2&gt;

&lt;p&gt;การเตรียมอุปกรณ์ที่ใช้งาน Samsung DeX นี้ จริง ๆ ถ้าเอาง่าย ๆ ก็หาคีย์บอร์ด + เมาส์ แล้วหาตัว USB-C hub ดีหน่อย ร่วมกันกับหาสาย HDMI และหาสาย USB-C to USB-C กับ Adapter ดี ๆ ก็สามารถใช้งานได้แล้วล่ะครับ&lt;/p&gt;

&lt;p&gt;ส่วนของเราเตรียมอุปกรณ์ดังนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;สาย USB-C to USB-C และ Adapter ของ Aukey ที่รองรับวัตต์เยอะหน่อย ของเราเลือกตัวที่รองรับวัตต์ประมาณ 100W&lt;/li&gt;
  &lt;li&gt;เมาส์และคีย์บอร์ดของ Microsoft อย่าง Sculpt Ergonomic ที่ให้มาเป็นเซ็ต และดีที่มันไร้สาย เพราะเวลาจัดโต๊ะจะจัดได้ง่าย ไม่ต้องมีสายรุงรัง&lt;/li&gt;
  &lt;li&gt;ตัว &lt;a href=&quot;https://nickuntitled.com/2021/09/04/usb-c-docking-station-with-surface/&quot;&gt;Docking Station ของ Feeltek&lt;/a&gt; ที่แต่เดิมเราใช้กับ Surface&lt;/li&gt;
  &lt;li&gt;หน้าจอของ Dell 23.8” รุ่นล่าง ๆ ที่ใช้กับออฟฟิศครับ&lt;/li&gt;
  &lt;li&gt;มือถือก็ต้องซัมซุงสิ ของเราใช้ Z fold 3&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เมื่อต่อออกมาแล้วก็ใช้งานได้ดีในระดับหนึ่งเลย แถมสบายข้อมือระหว่างที่ใช้งานอีกเพราะเป็นคีย์บอร์ดแบบ Ergonomic ร่วมกันกับเมาส์แนวตั้งที่ลดการหันข้อมือได้สบาย&lt;/p&gt;

&lt;p&gt;ส่วนใครที่งบไม่เยอะมาก แนะนำซื้อแท็บเล็ต Samsung Galaxy Tab S8 Wi-Fi ธรรมดาที่น่าจะแถมชุดคีย์บอร์ดและเมาส์มาก็เหลือ ๆ แล้ว (หรือจะไปซื้อ Tab S7 รุ่นเก่าหน่อยก็ใช้ได้เช่นกัน) เพราะแท็บเล็ตมันเปิดใช้งาน Samsung DeX ได้เลย โดยเราไม่ต้องเสียบต่อจอนอก&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้งเครื่องมือที่จำเป็น&quot;&gt;การติดตั้งเครื่องมือที่จำเป็น&lt;/h2&gt;

&lt;p&gt;เราเลยเอามือถือมาต่อออกจอแล้วใช้งานโปรแกรม IDE ที่เราติดตั้งไปก่อนหน้า โดยเราทำตามขั้นตอนด้านล่างนี้ (อ่านแบบเต็ม ๆ ได้ที่บทความก่อนหน้า)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ติดตั้ง termux&lt;/li&gt;
  &lt;li&gt;ติดตั้ง Debian ผ่านการพิมพ์ (หรือก็อปปี้) คำสั่งมาใส่ใน termux เพื่อติดตั้งลงไปในระบบ&lt;/li&gt;
  &lt;li&gt;เริ่มต้นการใช้งาน Debian แล้วติดตั้งโปรแกรม IDE ที่จำเป็น โดยของเราลง OpenVSCode server&lt;/li&gt;
  &lt;li&gt;เข้าไปหน้า OpenVSCode server ผ่านการก็อปปี้ที่อยู่เว็บไซต์แล้ววางบนแถบ Address ของเว็บเบราวเซอร์&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เมื่อเข้ามาแล้ว เราสามารถใช้งานได้ปกติเลย โดยฟังก์ชันเหล่านี้คล้ายกันกับที่เราใช้งานบน Visual Studio Code ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/coding_samsung_dex_vscode.jpg&quot; alt=&quot;Samsung DeX with VS Code&quot; /&gt;
OpenVSCode server บน Samsung DeX&lt;/p&gt;

&lt;p&gt;ส่วนเรื่องการจัดการไฟล์ จุดนี้เราต้องลงโปรแกรมเพิ่มตัวหนึ่งที่มีชื่อว่า &lt;a href=&quot;https://play.google.com/store/apps/details%3Fid%3Dme.zhanghai.android.files&quot;&gt;Material Files จาก Google Play Store&lt;/a&gt; ที่ทำให้เราเข้าถึงไฟล์บน Termux ได้โดย&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ติดตั้งโปรแกรมผ่าน Google Play Store&lt;/li&gt;
  &lt;li&gt;เปิดแอพ Material Files&lt;/li&gt;
  &lt;li&gt;กดที่ Add Storage แล้วเลือก Android/data&lt;/li&gt;
  &lt;li&gt;เข้าไปที่มุมบนซ้าย เลือกไปที่ termux ตัวโปรแกรมจะขึ้นว่าขออนุญาตเข้าถึงไฟล์ แล้วตอบตกลงไป (ถ้าจำไม่ผิด)&lt;/li&gt;
  &lt;li&gt;เมื่อทำเสร็จแล้ว เราจะเข้าไปจัดการไฟล์ได้เลย&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/material_file_googleplay.jpg&quot; alt=&quot;Material File on Google Play&quot; /&gt;
Material File บน Google Play&lt;/p&gt;

&lt;p&gt;ส่วนผู้อื่นที่ต้องการเข้าถึงไฟล์ที่อยู่ใน Debian อีกที อันนี้เราเข้าถึงไฟล์เหล่านี้ได้เลย ผ่านการเข้าไปในโฟลเดอร์ของ termux ที่เราสร้างขึ้นตามขั้นตอนด้านบนนี้ จากนั้น&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เลือกโฟลเดอร์ของ Debian เอง โดยของเราอยู่ที่ debian ส่วนของผู้อ่านจะเป็นชื่ออื่นก็เข้าไปในโฟลเดอร์ที่ได้ตั้งชื่อไว้ครับ&lt;/li&gt;
  &lt;li&gt;เข้าไปที่ debian-fs เราจะพบโฟลเดอร์ Root ของ debian ที่ตัวติดตั้งสร้างขึ้นไว้&lt;/li&gt;
  &lt;li&gt;เลือกที่ home แล้วเข้าไปในโฟลเดอร์ของผู้ใช้ของเราเองที่สร้างขึ้น&lt;/li&gt;
  &lt;li&gt;เลือกไฟล์ที่อยู่ใน debian ที่เราเขียนโค้ดไว้เพื่อส่งงาน หรือทำอไรอย่างอื่นก็ได้ตามที่เราต้องการ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/termux_file_access_materail_file.jpg&quot; alt=&quot;Material File access to Debian inside of termux&quot; /&gt;
ภาพหน้าจอ Material File ที่เข้าถึงโฟลเดอร์ใน Debian ที่ติดตั้งใน termux อีกที&lt;/p&gt;

&lt;h2 id=&quot;รีวิวการใช้งานซักหน่อย&quot;&gt;รีวิวการใช้งานซักหน่อย&lt;/h2&gt;

&lt;p&gt;เมื่อเราใช้งาน OpenVSCode server ที่ใช้งานบนหน้าเว็บ ร่วมกันกับ Samsung DeX พร้อมอุปกรณ์ที่กล่าวถึงไปก่อนหน้า ก็พบว่าใช้งานได้ดีในระดับหนึ่งเลย พิมพ์ได้ลื่น ไม่พบการกระตุกอะไร แถมเราเปิด Terminal จากหน้า OpenVSCode server เพื่อทดลองรันโค้ด Node.js/Python คอมไพล์ตัวโค้ด รวมถึงเขียนบล็อคแล้วรัน Jekyll (ที่ตัวเครื่องมือตัวนี้เขียนบน Ruby) เพื่อทดสอบบล็อคเราเองก็ใช้งานได้ดี ไม่มีการติดขัดอะไร (โดยบทความนี้เขียนบนมือถือซัมซุงที่ใช้งาน Samsung DeX)&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี เนื่องจากมันเป็นมือถือ/แท็บเล็ตที่ใช้ซีพียูมือถือที่มีประสิทธิภาพจำกัด รวมถึงการระบายความร้อนทำได้ไม่ดีเท่าเดสก์ท็อปแล้ว ดังนั้นจะนำอุปกรณ์เหล่านี้มารันหนัก ๆ แบบเทรนโมเดล AI/ML หรือประมวลผลหนัก ๆ อะไรแบบนี้ก็ใช่ที่ ดังนั้นแล้วถ้าจะเทรน AI จริง เราคิดว่าทดสอบการรันโค้ดว่าไม่มีบัคอะไรพวกนี้บนอุปกรณ์แบบนี้ก่อนก็ได้ แล้วค่อยเทรนบนเซิร์ฟเวอร์ หรือใช้งานผ่าน Google Colab/Jupyter อะไรแบบนี้น่าจะดีกว่า&lt;/p&gt;

&lt;p&gt;นอกจากประสิทธิภาพที่จำกัดแล้ว การใช้งานในลักษณะนี้ก็มีข้อจำกัดอีกจุด นั่นก็คือมันจะเหมาะกับการพัฒนาเว็บ/แอพแบบคอมมานไลน์มากกว่า สำหรับคนที่พัฒนาแอพเพื่อลงอุปกรณ์มือถืออย่าง React Native/Flutter/iOS หรือพัฒนาแอพแบบเดสก์ท็อปแบบ .NET ปกติ การใช้งานแบบนี้อาจจะตอบสนองต่อผู้อ่านได้ไม่ดี คิดว่าใช้งานบนแมคบุ๊ค แล็ปท็อปหรือเดสก์ท็อปไปก่อนน่าจะดีกว่า&lt;/p&gt;

&lt;h2 id=&quot;สำหรับผู้อ่าน&quot;&gt;สำหรับผู้อ่าน&lt;/h2&gt;

&lt;p&gt;สำหรับผู้อ่าน อาจจะต้องเช็คความต้องการตัวผู้อ่านเองอีกที ว่าจะเอาไปใช้งานกับอะไรครับผม ถ้าผู้อ่านจะเอามาใช้งานตามด้านล่างนี้ ได้แก่&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ฝึกการเขียนโค้ด (โค้ดดิ้งตามที่ศธ. กล่าวถึง) ในวิชาแบบวิทยาการคำนวณ หรือตามที่เรียนในมหาวิทยาลัย&lt;/li&gt;
  &lt;li&gt;เอาไปเขียนโปรแกรมเพื่อพัฒนาเว็บ&lt;/li&gt;
  &lt;li&gt;Prototype ตัวโค้ดก่อนที่จะไปนำใช้งานบนเครื่อง Production จริง อย่างการเทรน AI/ML หรือการคำนวณคณิตศาสตร์หนัก ๆ หรืออื่น ๆ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;การใช้งาน Samsung DeX ร่วมกับการติดตั้งตามที่เรากล่าวไว้ในบทความที่แล้ว สิ่งเหล่านี้ตอบสนองผู้อ่านได้สบายครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Computer" /><category term="Diary" /><category term="samsung" /><category term="samsung dex" /><category term="samsung zfold 3" /><category term="zfold 3" /><category term="computer" /><category term="android" /><category term="mobile" /><category term="tablet" /><category term="personal" /><category term="productivity" /><category term="programming" /><category term="replacement" /><category term="working" /><category term="คอมพิวเตอร์" /><category term="ซัมซุง" /><category term="เดสก์ท็อป" /><category term="ทำงาน" /><category term="เขียนโปรแกรม" /><category term="แท็บเล็ต" /><category term="มือถือ" /><category term="แอนดรอยด์" /><summary type="html">คราวนี้เราจะมาพูดถึงภาคต่อของการนำอุปกรณ์แอนดรอยด์มาใช้งานเขียนโปรแกรมแทนคอมพิวเตอร์ที่มีอยู่โดยการใช้งาน Samsung DeX</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/03/samsung_dex_developing_replacement_pc_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/03/samsung_dex_developing_replacement_pc_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วิธีนำอุปกรณ์ Android มาใช้โค้ดทิ้งแทนที่โน้ตบุ๊ต</title><link href="https://nickuntitled.com/2022/03/20/android_as_programming_pc_replacement/" rel="alternate" type="text/html" title="วิธีนำอุปกรณ์ Android มาใช้โค้ดทิ้งแทนที่โน้ตบุ๊ต" /><published>2022-03-20T01:00:00+07:00</published><updated>2022-03-20T01:00:00+07:00</updated><id>https://nickuntitled.com/2022/03/20/android-as-programming-replacement</id><content type="html" xml:base="https://nickuntitled.com/2022/03/20/android_as_programming_pc_replacement/">&lt;p&gt;ช่วงที่ผ่านมาก็จะมีพูดถึงการให้นักเรียนมาเรียนการเขียนโค้ด หรือที่คนพูดกันบ่อย ๆ (รวมถึงเจ้าหน้าที่รัฐฯ) ก็จะเรียกกันว่าโค้ดดิ้งที่ได้รับการบรรจุลงในวิชาวิทยาการคำนวณ โดยภาษาที่เหมาะกับผู้เริ่มต้นนั่นก็คือไพทอน&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดีการเขียนโปรแกรมไพทอนจำเป็นต้องใช้คอมพิวเตอร์เป็นหลักที่ใช่ว่าทุกคนจะมีกันเสียเท่าไร เลยคิดว่าไหน ๆ มือถือแอนดรอยด์ก็มีกันหลายคนแล้ว แถมเราก็เปลี่ยนจากไอโฟนมาเป็นซัมซุงที่รองรับ Samsung DeX อยู่แล้ว เลยมาเขียนบทความนี้ดีกว่า&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ส่วนใครที่ใช้ไอแพดก็ไปอ่านได้ที่ &lt;a href=&quot;https://nickuntitled.com/2021/03/04/ipad-as-a-programming-laptop-replacement/&quot;&gt;“เมื่อนำ iPad มาเขียนโปรแกรมแทนที่โน้ตบุ๊ค”&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;การเขียนโปรแกรมโดยปกติจำเป็นต้องมีตัว Compiler หรือตัว Interpreter ของแต่ละภาษา โดยภาษาไพทอนจำเป็นต้องมีโปรแกรมของตัว Python เอง หรือตัวจาวาสคริปที่รันบนคอมพิวเตอร์ก็ใช้โปรแกรมอย่าง Node.js อย่างไรก็ดีโปรแกรมเหล่านี้ก็ไม่ได้มีให้ดาวน์โหลดจาก Google Play, Amazon App Store นี่ แล้วจะทำอย่างไร?&lt;/p&gt;

&lt;p&gt;ทำได้ครับ วิธีแรกก็ตามในลิ้งค์บนนั้นเลย เราก็เช่าคลาวด์ที่ใดที่หนึ่งแล้วติดตั้งเครื่องมือที่เกี่ยวข้อง แล้วรีโหมดเข้าไปพัฒนาแอพ หรือใช้งานผ่าน Open VSCode Server (หรือ code-server) แต่เราจะไม่กล่าวถึงวิธีนั้น&lt;/p&gt;

&lt;p&gt;อีกวิธีหนึ่งที่เราทำได้นั่นก็คือการติดตั้งเครื่องมือที่ให้เราติดตั้งแอพที่อนุญาตให้เรารันคอมมานไลน์ที่เป็น Linux Shell ได้อย่าง &lt;a href=&quot;https://termux.com/&quot;&gt;Termux&lt;/a&gt; ตามนิยามภาษาอังกฤษของตัวแอพนี้ว่า&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Termux is an Android terminal emulator and Linux environment app that works directly with no rooting or setup required. A minimal base system is installed automatically - additional packages are available using the APT package manager.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;อย่างไรก็ดี Termux มีข้อแตกต่างกับตัวลินุกซ์ปกติ&lt;/p&gt;

&lt;h2 id=&quot;ความแตกต่างระหว่าง-termux-กับลินุกซ์&quot;&gt;ความแตกต่างระหว่าง Termux กับลินุกซ์&lt;/h2&gt;

&lt;p&gt;Termux มีจุดที่แตกต่างระหว่างตัวลินุกซ์ที่อยู่ใน Termux กับตัวลินุกซ์ที่เราใช้งานกันปกติ (อ้างอิงจาก&lt;a href=&quot;https://wiki.termux.com/wiki/Differences_from_Linux&quot;&gt;หน้าเว็บนี้&lt;/a&gt;) นั่นก็คือ&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ระบบไฟล์จะไม่เข้ากันได้กับมาตรฐาน Filesystem Hierachy Standard ที่จะแบ่งตัวโฟลเดอร์เป็น /boot /etc /usr /home ทำให้อาจจะมีปัญหากับบางโปรแกรมบ้าง&lt;/li&gt;
  &lt;li&gt;เนื่องมาจากตัวแอพคอมไพล์โดยใช้ Android NDK ทำให้ใช้งาน Bionic libc แทนที่จะใช้ตัวที่มีอยู่ลินุกซ์ปกติ ส่งผลทำให้เราไม่สามารถนำแอพบนลินุกซ์มาใช้งานได้ทันที เราจำเป็นต้องคอมไพล์ใหม่เสียก่อน&lt;/li&gt;
  &lt;li&gt;โฟลเดอร์ที่เกี่ยวข้องกับ Termux รวมถึงโฟลเดอร์ที่เก็บข้อมูลแอพต่าง ๆ จะอยู่ในโฟลเดอร์ที่อยู่ในโฟลเดอร์ data ของ Termux อีกที&lt;/li&gt;
  &lt;li&gt;Termux อนุญาตให้เราใช้งานเพียง user เดียว&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เมื่อทราบข้อแตกต่างนี้แล้ว เรามาติดตั้ง Termux กันดีกว่า&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้ง-termux&quot;&gt;การติดตั้ง Termux&lt;/h2&gt;

&lt;p&gt;เมื่อรู้จักกับ Termux แล้ว เราจะติดตั้งได้จากที่ไหน? ปกติเราจะติดตั้งจาก Google Play ใช่ไหมครับ ทีนี้แอพนี้มันก็มีให้ดาวน์โหลดอยู่ แต่ทว่า แอพที่ให้ดาวน์โหลดนั้นเป็นรุ่นเก่าที่ไม่ได้รัับการอัพเดทแล้วเนื่องมาจากปัญหาเรื่อง API เอง ดังนั้นทางเว็บผู้พัฒนาเอง และเราแนะนำให้ติดตั้งจาก &lt;a href=&quot;https://f-droid.org/en/&quot;&gt;F-Droid&lt;/a&gt; ที่เป็น App Store ที่ให้ดาวน์โหลดแอพที่ฟรี และเปิดเผยตัวโค้ด (Open Source) โดย&lt;/p&gt;

&lt;p&gt;ขั้นตอนแรก ติดตั้งตัว F-Droid เสียก่อน โดยดาวน์โหลดจากเว็บผู้พัฒนาของ F-Droid&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/download_fdroid.jpg&quot; alt=&quot;Download F-Droid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ต่อมา เมื่อดาวน์โหลดมาเรียบร้อย ตั้งค่าในหน้าการตั้งค่าให้ติดตั้งแอพจาก Unknown Sources (โดยมือถือซัมซุงที่เราใช้อยู่เข้าได้ที่ Settings -&amp;gt; Biometrics and Security -&amp;gt; Install unknown apps -&amp;gt; กดที่ตัว File Manager แล้วติ๊กถูกให้ Allow from this source ส่วนรุ่นอื่นอาจต้องไปอ่านคู่มืออีกทีครับ)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/enable_myfile.jpg&quot; alt=&quot;Enable Unknown Sources&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ขั้นตอนที่สาม เข้าไปที่ตัวติดตั้ง F-Droid ผ่านทางหน้า File Manager แล้วติดตั้ง เมื่อติดตั้งเสร็จแล้วไปตั้งค่าให้ติดตั้งแอพจาก Unknown Sources โดยเลือก F-Droid เพื่ออนุญาตให้ F-Droid ดาวน์โหลดแอพที่ไม่ได้อยู่ใน Google Play Store ได้ครีบ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/enable_fdroid.jpg&quot; alt=&quot;Enable F-Droid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ต่อไป เข้าไปที่หน้า F-Droid ค้นหาแอพที่ชื่อว่า Termux จากนั้นกด Install&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/install_termux.jpg&quot; alt=&quot;Installation of Termux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;สุดท้าย ตัวโปรแกรมจะติดตั้ง Termux เมื่อติดตั้งเสร็จแล้ว เข้าไปที่หน้าเมนูหลัก แล้วกดที่ Termux&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้งเครื่องมือที่เกี่ยวข้อง&quot;&gt;การติดตั้งเครื่องมือที่เกี่ยวข้อง&lt;/h2&gt;

&lt;p&gt;หลังจากที่เข้ามาในตัว Termux แล้ว การใช้งานก็คือเราพิมพ์คำสั่งคอมมานไลน์เข้าไปในระบบให้มันทำงาน ซึ่งจุดนี้ก็จะคล้ายกันกับที่ใช้บนลินุกซ์เองครับ แต่จุดหนึ่งที่เราจะนำมาเขียนโปรแกรมแทนที่จะใช้คอมพิวเตอร์นั่นก็คือเราต้องติดตั้งเครื่องมือที่เกี่ยวข้องเสียก่อน&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;สำหรับผู้ที่ไม่เคยใช้คอมมานไลน์บนลินุกซ์ ผู้อ่านสามารถศึกษาได้&lt;a href=&quot;https://saixiii.com/unix-linux-command/&quot;&gt;ที่นี่&lt;/a&gt; หรือจาก&lt;a href=&quot;https://linuxcommand.org/&quot;&gt;ที่นี่แต่เป็นภาษาอังกฤษที่ดูครบครันมากกว่าครับ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;โดยภาษาหลัก ๆ ที่เขียนก็เป็นไพทอนที่เหมาะกับผู้เริ่มต้น เราเริ่มต้นโดยการอัพเดทรายการแพคเกจที่มีอยู่ในระบบเสียก่อนโดยพิมพ์คำสั่งว่า&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ pkg update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หลังจากนั้นสั่งให้ระบบติดตั้งไพทอนได้โดยพิมพ์คำสั่งว่า&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ pkg install python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ระบบจะติดตั้งแพคเกจไพทอน หลังจากนั้นเราเริ่มต้นไพทอนได้โดยพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หน้าจอจะปรากฏแอพไพทอนให้เราเขียนโปรแกรมได้แล้วตามภาพด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/python_termux.jpg&quot; alt=&quot;Python inside Termux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เมื่อเราเห็นหน้าจอตามข้างบนนี้แล้วมันเหมือนเป็นหน้าจอสำหรับการพิมพ์โค้ดเพื่อให้ตัวไพทอนประมวลผลได้ทันทีแบบ Interpreter ทั่ว ๆ ไปนี่แหละครับ อย่างไรก็ดีมีจุดที่สังเกตเลยเนื่องมาจากตัว Termux มีข้อจำกัดตามที่กล่าวไว้ในหัวข้อก่อนหน้า ดังนั้นแล้วไลบรารีบางไลบรารีที่ติดตั้งผ่านทาง pip3 อาจจะติดตั้งไม่ได้เนื่องมาจากมีปัญหาการคอมไพล์เครื่องมือที่เกี่ยวข้อง เรื่องนี้เราจะกล่าวถึงในหัวข้อถัดไปจากนี้&lt;/p&gt;

&lt;p&gt;แต่ตอนนี้เราจะมากล่าวถึงวิธีการเขียนโค้ดเป็นไพล์ไพทอนออกมาแล้วค่อยสั่งให้ไพทอนทำงานด้วยคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ python &amp;lt;ไฟล์ตัวโค้ดที่พิมพ์ไว้&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ที่ผู้อ่านอาจจะสงสัยว่าเราจะทำได้อย่างไรล่ะ คำตอบก็เหมือนเดิม ทำได้ครับ แต่ก่อนอื่น เราต้องมาอนุญาตให้ตัว Termux เข้าถึงไฟล์ที่มีอยู่ใน Internal Storage/SD Card บนแอนดรอยด์เสียก่อน ด้วยคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ termux-setup-storage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวโปรแกรมจะขึ้นหน้าจออนุญาตให้เราเข้าถึงตัวไฟล์ที่มีอยู่ใน Internal Storage/SD Card ครับ แล้วเราจะเข้าถึงได้อย่างไร? ตัว Termux จะสร้างไฟลเดอร์หนึ่งที่เหมือนเป็น Shortcut เพื่อให้เราเข้าถึงโฟลเดอร์​ และไฟล์เหล่านี้ได้ผ่านทางการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ cd storage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ระบบจะเข้าถึงโฟลเดอร์ที่เกี่ยวข้องกับระบบ โดยจะแสดงโฟลเดอร์ dcim, downloads, movies, music, pictures ส่วนโฟลเดอร์ shared นี่เมื่อเปิดเข้าไปจะเป็นโฟลเดอร์ที่เป็น Shortcut เข้าไปยัง Internal Storage/SD Card ที่จะแสดงโฟลเดอร์ และไฟล์ที่มีอยู่ทั้งหมด เราสามารถแก้ไข ลบ สร้าง เปลี่ยนแปลงไฟล์เหล่านี้ได้เลย&lt;/p&gt;

&lt;p&gt;ต่อไป เราจะมาแนะนำการติดตั้ง IDE ที่เกี่ยวข้อง&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้ง-ide-ที่เกี่ยวข้อง&quot;&gt;การติดตั้ง IDE ที่เกี่ยวข้อง&lt;/h2&gt;

&lt;p&gt;IDE บนแอนดรอยด์มาหลาย IDE แต่ที่เราใช้ตัวหนึ่งก็เป็น DroidEdit ที่เป็นแอพที่เสียเงิน แต่ใช้งานได้ดีในระดับหนึ่งเลย โดยติดตั้งได้ผ่านทาง Google Play Store ครับ ราคาอยู่ประมาณหลักร้อยบาท แต่ใช้งานได้ดีครับ&lt;/p&gt;

&lt;p&gt;หน้าจอการใช้งานก็ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/droidedit.jpg&quot; alt=&quot;DroidEdit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;วิธีที่สองที่เราใช้ได้ นั่นก็คือใช้งานผ่านทางเว็บของไมโครซอฟท์เองอย่าง &lt;a href=&quot;https://vscode.dev/&quot;&gt;vscode.dev&lt;/a&gt; ที่ให้เราใช้งานตัว Visual Studio Code บนหน้าเว็บได้เลย เพียงแต่ฟังก์ชันจะจำกัดเมื่อเทียบกันกับ Visual Studio Code ที่มีอยู่บนคอมพิวเตอร์ และยังเป็นรุ่น Preview ดังนั้นแล้วตัวนี้ยังไม่สมบูรณ์ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/andriod_vscodedev.jpg&quot; alt=&quot;VScode dot dev&quot; /&gt;&lt;/p&gt;

&lt;p&gt;วิธีที่สาม เราสามารถติดตั้งตัว &lt;a href=&quot;https://github.com/coder/code-server&quot;&gt;code-server&lt;/a&gt; หรือ &lt;a href=&quot;https://github.com/gitpod-io/openvscode-server&quot;&gt;OpenVScode server&lt;/a&gt; (ที่ทั้งสองตัวนี้ดูหน้าจอแล้วคล้ายกันกับที่เราเขียนบน Visual Studio Code) ได้ผ่านทางการติดตั้งใน Termux ได้อีก โดยการติดตั้งทำได้โดยติดตั้ง Debian แล้วติดตั้งเครื่องมืออันใดอันหนึ่งครับ โดยวิธีนี้ถ้าใครไม่อยากยุ่งยากก็ติดตั้ง IDE ตามที่แนะนำข้างบนนี้แล้วใช้งานกับไพทอนก็พอใช้ได้ในระดับหนึ่งแล้วครับ&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้ง-debian&quot;&gt;การติดตั้ง Debian&lt;/h2&gt;

&lt;p&gt;เราติดตั้ง code-server ได้โดยการติดตั้งตัว Debian เสียก่อนเพื่อให้เราใช้งานลินุกซ์ได้แบบเต็ม ๆ ไม่มีจุดที่จำกัดของตัวลินุกซ์ที่มีอยู่บน Termux เอง โดยวิธีการติดตั้ง Debian เราพิมพ์คำสั่งตามที่อ้างอิงมาจาก&lt;a href=&quot;https://coder.com/docs/code-server/latest/termux&quot;&gt;เว็บนี้&lt;/a&gt; ได้โดยพิมพ์ไปว่า&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pkg update -y &amp;amp;&amp;amp; pkg install wget curl proot tar -y &amp;amp;&amp;amp; wget https://raw.githubusercontent.com/AndronixApp/AndronixOrigin/master/Installer/Debian/debian.sh -O debian.sh &amp;amp;&amp;amp; chmod +x debian.sh &amp;amp;&amp;amp; bash debian.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;กด Enter ตัว Termux จะติดตั้งเครื่องมือที่เกี่ยวข้อง หลังจากนั้นจะเริ่มต้นการติดตั้งตัว Debian ลงไป หลังจากนั้นเราจะพบว่าเราใช้งาน Debian อยู่ในขณะนี้ ขั้นตอนต่อไปจะเป็นการติดตั้งเครื่องมือที่เกี่ยวข้อง เราทำได้โดยติดตั้ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update
apt upgrade -y
apt-get install nano vim sudo curl wget git -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา สร้างผู้ใช้ และรหัสผ่านขึ้นมาแทนที่จะใช้ผู้ใช้ที่มีชื่อว่า root เราทำได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo adduser username
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วตอบคำถามตามที่หน้าจอปรากฏขึ้น เมื่อทำเสร็จแล้ว เราตั้งค่าให้ผู้ใช้นี้ใช้คำสัั่ง sudo ได้โดยการพิมพ์คำสั่งนี้ลงไป&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo usermod -aG sudo username
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แต่ถ้าทำแล้วไม่ได้ เราก็เข้าไปแก้ไขในไฟล์การตั้งค่าของ sudo ได้โดยการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;visudo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วเพิ่มผู้ใช้ใหม่ได้โดยการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;username&amp;gt; ALL=(ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วบันทึกไฟล์ก็ทำให้ผู้ใช้สามารถใช้คำสั่ง sudo ได้เช่นกัน&lt;/p&gt;

&lt;p&gt;เมื่อทำเสร็จแล้ว เราก็จะได้ผู้ใช้ใหม่ที่สามารถใช้งานคำสั่ง sudo เวลาที่จะติดตั้งแอพ หรือทำอะไรที่เกี่ยวข้องการตัวระบบปฏิบัติการเองครับ การเปลี่ยนไปใช้ผู้ใช้นี้เราทำได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su - &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;นอกเหนือจากนี้เวลาที่เราจะกลับมาใช้งานตัว Debian ใหม่ผ่านทางหน้าจอ Termux เราทำได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ ./start-debian.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อไปจะเป็นการติดตั้งเครื่องมือที่เกี่ยวข้อง มีสองทางเลือก หนึ่งติดตั้ง code-server กับสองติดตั้ง OpenVScode server ครับ โดยส่วนตัวจากที่เคยใช้ ใช้ได้ดีทั้งคู่ แต่เราชอบ OpenVScode server มากกว่า เพราะมันง่าย และไม่ต้องติดตั้งแพคเกจลงไปในระบบ ถ้าอยากลบก็สั่งลบทั้งโฟลเดอร์ไปได้เลย ง่ายกว่าเยอะ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;นอกจากนี้สำหรับคนที่อยากทำอะไรหลาย ๆ อย่างในหน้า Termux เดียวกัน แนะนำให้ติดตั้ง tmux เข้าไปในระบบโดยการติดตั้งด้วยการพิมพ์คำสั่ง sudo apt install tmux แล้วพิมพ์คำสั่ง tmux เพื่อเริ่มต้นการใช้งาน&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;วิธีแรก-ติดตั้ง-code-server&quot;&gt;วิธีแรก ติดตั้ง code-server&lt;/h2&gt;

&lt;p&gt;ถัดไปจากการติดตั้ง และตั้งค่าตัว Debian แล้ว เราติดตั้งตัว code-server ได้โดยการพิมพ์คำสั่งด้านล่างนี้เพื่อทดสอบเสียก่อน&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;กรณีที่ทดสอบแล้วพบว่าใช้งานได้ดี เราสามารถพิมพ์คำสั่งนี้เพื่อติดตั้งได้เลยผ่านทางการพิมพ์โค้ด&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -fsSL https://code-server.dev/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวระบบจะดาวน์โหลดตัว code-server ลงมาในตัวเครื่องแอนดรอยด์เอง เมื่อเราต้องการใช้งาน code-server เราทำได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;code-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เพื่อเริ่มต้นการทำงาน แล้วเราเข้าผ่านทางการพิมพ์ที่อยู่เว็บไซต์ http://127.0.0.1:8080 แล้วเราจะพบหน้าจอ code-server ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/android-code-server-login.jpg&quot; alt=&quot;code-server login&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เราเข้าสู่ระบบได้โดยการพิมพ์รหัสผ่านที่เป็นค่าเริ่มต้นได้โดยการเข้าไปดูในไฟล์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat ~/.config/code-server/config.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ระบบจะแสดงข้อมูลการตั้งค่า โดยจะแสดงมาตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind-addr: 127.0.0.1:8080
auth: password
password: &amp;lt;password&amp;gt;
cert: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ดูตรง password ให้ก็อปปี้ตัวนี้แล้วนำไปแปะในหน้าเว็บนั้น เราจะใช้งานตัว code-server ได้แล้วครับตามหน้าจอด้านล่างนี้เลย&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/android-code-server-main.jpg&quot; alt=&quot;code-server main&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เราจะพบว่ามันใช้งานได้แล้วครับ&lt;/p&gt;

&lt;h2 id=&quot;วิธีสอง-ติดตั้ง-openvscode-server&quot;&gt;วิธีสอง ติดตั้ง OpenVscode server&lt;/h2&gt;

&lt;p&gt;นอกจากตัว code-server ตามที่กล่าวไปข้างบนแล้ว ยังมีตัว IDE อีกตัวที่น่าใช้เช่นกัน แต่ติดตั้งได้ง่ายกว่าตัวข้างบน นั่นก็คือ OpenVSCode server ที่พัฒนาโดยผู้ให้บริการ &lt;a href=&quot;https://gitpod.io&quot;&gt;Gitpod&lt;/a&gt; ครับ เราติดตั้งได้โดยการดาวน์โหลดตัวติดตั้งเสียก่อนโดยดาวน์โหลดที่ส่วน &lt;a href=&quot;https://github.com/gitpod-io/openvscode-server/releases&quot;&gt;Release ในหน้า Github&lt;/a&gt; นี้ครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ก่อนที่จะดาวน์โหลดไฟล์มา ให้ตรวจสอบสถาปัตยกรรมซีพียูเสียก่อนได้โดยการพิมพ์คำสั่ง dpkg –print-architecture หรือ cat /proc/cpuinfo แล้วจะปรากฏรายละเอียดซีพียูครับ ของผู้เขียนจะขึ้นเป็น arm64 ครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;เมื่อดาวน์โหลดแล้ว แตกไฟล์ก่อนด้วยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar xzf &amp;lt;ตำแหน่งไฟล์ที่เราดาวน์โหลดไว้&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อแตกไฟล์เสร็จแล้ว เราเข้าไปในโฟลเดอร์ที่แตกไฟล์ไว้ จากนั้นเริ่มต้นการทำงาน OpenVSCode server ได้โดยการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/openvscode-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ระบบจะเริ่มต้นการทำงาน OpenVSCode server ผู้ใช้สามารถเข้าไปใช้งานได้โดยการก็อปปี้ที่อยู่ตามที่ปรากฏในหน้าจอแล้วเอาไปแปะในเว็บเบราวเซอร์ แล้วจะปรากฏหน้าจอตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/android_openvscode_server.jpg&quot; alt=&quot;OpenVScode server IDE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เราก็จะพบว่ามันใช้งานได้แล้วครับ&lt;/p&gt;

&lt;h2 id=&quot;สำหรับผู้อ่าน&quot;&gt;สำหรับผู้อ่าน&lt;/h2&gt;

&lt;p&gt;สำหรับผู้อ่านแล้ว ถ้าต้องการติดตั้งแบบไม่ยุ่งยากก็ติดตั้ง termux กับติดตั้งตัวไพทอนรวมถึงติดตั้ง IDE ที่มีอยู่บน Google Play ก็น่าจะเพียงพอในระดับหนึ่ง แต่ถ้าต้องการใช้ IDE แต่ต้องการให้ติดตั้งไลบรารีไพทอนให้ได้หลากหลายมากกว่านี้ได้ เราก็ทำจนถึงการติดตั้ง Debian&lt;/p&gt;

&lt;p&gt;ส่วนผู้ใช้ที่ต้องการใช้งาน code-server หรือ OpenVSCode Server ก็ทำจนครบทุกขั้นตอนไปเลยนี่แหละครับ เมื่อติดตั้งเสร็จแล้ว มันใช้งานได้สบายเลยนะ เพราะไม่มีข้อจำกัดด้านไลบรารีไพทอนเลย เพียงแต่มันจะใช้งานได้ลำบากไปหน่อบยำหรับคนที่มีอุปกรณ์แอนดรอยด์ที่มีหน้าจอเล็ก&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้วเราแนะนำวิธีนี้สำหรับผู้ใช้มือถือที่รองรับการเชื่อมต่อหน้าจอภายนอกให้ออกมาเป็นเดสก์ท็อปอย่าง Samsung DeX รวมถึงแท็บเล็ตแอนดรอยด์มากกว่าครับ (ส่วนใครใช้แท็บเล็ตจอใหญ่ไปเลยแบบ &lt;a href=&quot;https://www.gsmarena.com/samsung_galaxy_tab_s8_ultra-11274.php&quot;&gt;Samsung Galaxy Tab S8 Ultra&lt;/a&gt; นี่ใช้เขียนโปรแกรมได้สบาย)&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Computer" /><category term="Diary" /><category term="computer" /><category term="android" /><category term="mobile" /><category term="tablet" /><category term="personal" /><category term="productivity" /><category term="programming" /><category term="replacement" /><category term="working" /><category term="คอมพิวเตอร์" /><category term="ทำงาน" /><category term="เขียนโปรแกรม" /><category term="แท็บเล็ต" /><category term="มือถือ" /><category term="แอนดรอยด์" /><summary type="html">คราวนี้เราจะมาพูดถึงการนำอุปกรณ์แอนดรอยด์มาใช้งานเขียนโปรแกรมแทนคอมพิวเตอร์ที่มีอยู่ หลังจากที่ประสิทธิภาพของอุปกรณ์ดีขึ้นเยอะ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/03/android_as_development_machine_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/03/android_as_development_machine_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Pyodide - แนะนำการเริ่มต้นใช้งาน และการพล็อตกราฟเพื่อแสดงบนหน้าเว็บ</title><link href="https://nickuntitled.com/2022/03/16/running_python_website_draw_graph/" rel="alternate" type="text/html" title="Pyodide - แนะนำการเริ่มต้นใช้งาน และการพล็อตกราฟเพื่อแสดงบนหน้าเว็บ" /><published>2022-03-16T00:00:00+07:00</published><updated>2022-03-16T00:00:00+07:00</updated><id>https://nickuntitled.com/2022/03/16/pyodide-matplotlib-img-element</id><content type="html" xml:base="https://nickuntitled.com/2022/03/16/running_python_website_draw_graph/">&lt;p&gt;Python เป็นภาษาคอมพิวเตอร์ภาษาหนึ่งที่ได้รับความนิยมภาษาหนึ่ง โดยภาษานี้เป็นภาษา General-purpose ท่เน้นการอ่านตัวโค้ดได้ง่าย รวมถึงง่ายต่อการเรียนรู้ ภาษานี้ปกติจะไม่ได้ออกแบบเพื่อการทำงานบนหน้าเว็บไซต์แบบจาวาสคริป อย่างไรก็ดีมีทีมงานกลุ่มหนึ่งใน Mozilla ที่พัฒนาตึวโค้ด CPython ให้ทำงานอยู่บน Webassembly ที่ออกแบบมาให้รันตัวโค้ดที่ได้รับการคอมไพล์บนหน้าเว็บไซต์&lt;/p&gt;

&lt;p&gt;เมื่อตัวโค้ดได้รับการคอมไพล์ให้อยู่บน Webassembly แล้ว ตัวโค้ดที่เขียนในรูปแบบภาษา Python จะเข้าถึง Web APIs ทั้งหลายแหล่ที่อยู่บนเว็บเบราวเซอร์ได้นั่นเอง&lt;/p&gt;

&lt;p&gt;ตัว Pyodide นี้นอกจากคอมไพล์ตัว Python แล้ว ยังรวบรวมไลบรารี Numpy, Matplotlib, Pandas, scikit-learn และอื่น ๆ อีกหลายสิบไลบรารี แถมยังรองรับการติดตั้งไลบรารี Python เพิ่มเติมได้โดยการติดตั้งผ่าน micropip&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มต้นการใช้งาน-pyodide&quot;&gt;การเริ่มต้นการใช้งาน Pyodide&lt;/h2&gt;

&lt;p&gt;เราเริ่มต้นการใช้งานได้โดยการนำเข้าไลบรารี Pyodide ผ่านการแนบลิ้งค์ CDN ลงบนหน้า HTML ผ่านแท็ก script&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;script src = &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเรียกผ่านการใช้คำสั่ง import แบบ dynamic โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await import('https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อนำเข้าไลบรารีนี้แล้ว เราเริ่มต้นการทำงานของ Pyodide ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let pyodide = await loadPyodide({
      indexURL : &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/&quot;
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;การโหลดไลบรารี-และติดตั้งไลบรารีเพิ่มเติม&quot;&gt;การโหลดไลบรารี และติดตั้งไลบรารีเพิ่มเติม&lt;/h2&gt;

&lt;p&gt;เมื่อเริ่มต้นการทำงานแล้ว เราสามารถโหลดไลบรารีที่ต้องการได้โดยคำสั่ง loadPackage ตามด้วยไลบรารีที่ต้องการโดยเขัยนตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await pyodide.loadPackage(&quot;&amp;lt; ชื่อไลบรารี &amp;gt;&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ส่วนกรณีที่ต้องติดตั้งไลบรารีเพิ่มเติม เราสามารถติดตั้งได้โดยการใช้ micropip ซึ่งทำได้โดยการโหลดไบรารีผ่านการใช้ loadPackage และการเรียกใช้คำสั่ง micropip.install ผ่านการใช้คำสั่ง runPythonAsync ที่ให้เราเริ่มต้นการทำงานโค้ดไพทอนแบบ Asynchronous ได้ครับ&lt;/p&gt;

&lt;p&gt;เราเขียนโค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await pyodide.loadPackage(&quot;micropip&quot;);
  await pyodide.runPythonAsync(`
      import micropip
      micropip.install('&amp;lt; ไลบรารีที่ต้องการ ตัวอย่างเช่น seaborn &amp;gt;')
  `);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;การพล็อตกราฟด้วย-matplotlib--seaborn-แล้วแสดงบนแท็ก-img&quot;&gt;การพล็อตกราฟด้วย Matplotlib + Seaborn แล้วแสดงบนแท็ก img&lt;/h2&gt;

&lt;p&gt;เราสามารถพล็อตกราฟได้โดยการใช้ไลบรารี Matplotlib และไลบรารีที่พัฒนาต่อยอดจากไลบรารีก่อนหน้าอย่าง Seaborn ที่ทำให้การพล็อตกราฟเป็นไปได้โดยง่ายขึ้น&lt;/p&gt;

&lt;p&gt;ปกติเวลาที่เราพล็อตกราฟเสร็จแล้ว เราจะแสดงบนหน้าต่างใหม่ หรือแสดงบนหน้าเว็บใน Jupter Notebook ได้โดยการพิมพ์คำสั่งผ่านการเรียก pyplot ที่อยู่ใน matplotlib ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pyplot.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเซฟเป็นไฟล์ .png หรืออะไรแนวนี้ได้โดยการใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pyplot.savefig(&quot;&amp;lt; ที่อยู่ไฟล์ &amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;อย่างไรก็ดี เมื่อเราเขียนโค้ดแล้วนำมาทำงานบนหน้าเว็บไซต์ผ่านการใช้งาน Pyodide แล้ว มันก็จะไม่สามารถแสดงหน้าต่างใหม่ได้ หรือจะเซฟแบบนั้นโดยตรงก็ไม่น่าจะได้ ดังนั้นแล้วมีวิธีหนึ่งที่นำผลที่ได้จากการพล็อตกราฟมาแสดงบนหน้าเว็บไซต์ได้โดยการแปลงตัวกราฟที่พล็อตให้อยู่ในรูป base64 ที่สามารถเพิ่มลงไปใน src attribute ได้เลย&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ เรายังนำ base64 ไปแปลงให้เป็นรูปแบบ blob เพื่อนำไปอัพโหลด หรือเซฟไฟล์สำหรับการนำไปใช้งานต่อได้อีก แต่ในบทความนี้ขอแนะนำถึงการพล็อต แล้วส่งออกให้อยู่ในรูปแบบ base64 เพื่อนำมาแสดงบนแท็ก img ครับ&lt;/p&gt;

&lt;p&gt;เราทำได้ในขั้นตอนตัวอย่างตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h3 id=&quot;1-เริ่มต้น-pyodide--เรียกใช้ไลบรารี&quot;&gt;1. เริ่มต้น Pyodide + เรียกใช้ไลบรารี&lt;/h3&gt;

&lt;p&gt;เราเริ่มต้นการทำงานของ Pyodide และเรียกใช้งานไลบรารี numpy, matplotlib, seaborn (ที่ติดตั้งโดย micropip) ได้ตามหัวข้อก่อนหน้าครับ โดยเราเขียนโค้ดออกมาเป็น&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function importLib()
  {
      await import('https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js');

      let pyodide = await loadPyodide({
          indexURL : &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/&quot;
      });

      await pyodide.loadPackage(&quot;numpy&quot;);
      await pyodide.loadPackage(&quot;matplotlib&quot;);
      await pyodide.loadPackage(&quot;micropip&quot;);
      await pyodide.runPythonAsync(`
          import micropip
          micropip.install('seaborn')
      `);

      return pyodide;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราอธิบายโค้ดตามข้างบนนี้ โดยเป็นฟังก์ชัน importLib ที่เริ่มมาจากการนำเข้าไลบรารี เริ่มต้นการทำงานของ Pyodide แล้วนำเข้าแพคเกจเข้าไปในระบบโดยผ่านการใช้คำสั่ง loadPackage และ micropip.install (ที่ผ่านการใช้คำสั่ง runPythonAsync)&lt;/p&gt;

&lt;h3 id=&quot;2-เริ่มการพล็อตกราฟ&quot;&gt;2. เริ่มการพล็อตกราฟ&lt;/h3&gt;

&lt;p&gt;เริ่มต้นการพล็อตกราฟโดยใช้คำสั่งในไลบรารี&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;numpy มีไว้สำหรับการจำองข้อมูลขึ้นมา&lt;/li&gt;
  &lt;li&gt;matplotlib + seaborn มีไว้ใช้สำหรับการพล็อตกราฟ&lt;/li&gt;
  &lt;li&gt;base64 และ io มีไว้สำหรับการส่งออกกราฟให้อยู่ในรูปไบนารีที่แปลงออกมาเป็น base64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เราเขียนโค้ดได้โดยตามขั้นตอนตามด้านล่างนี้&lt;/p&gt;

&lt;h4 id=&quot;21-เรียกใช้ไลบรารี&quot;&gt;2.1 เรียกใช้ไลบรารี&lt;/h4&gt;

&lt;p&gt;เราเรียกใช้ไลบรารี numpy, matplotlib, seaborn, base64 และ io ผ่านการพิมพ์คำสั่ง Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import numpy as np
  import seaborn as sns
  from matplotlib import pyplot as plt
  import base64, io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;22-จำลองข้อมูลขึ้นมา&quot;&gt;2.2 จำลองข้อมูลขึ้นมา&lt;/h4&gt;

&lt;p&gt;เราสามารถจำลองข้อมูลขึ้นมาได้โดยผ่านการสุ่มตัวเลขโดยผลลัพธ์ที่ต้องการเป็นในรูปแบบอาเรย์ที่สามารถพล็อตกราฟได้โดยใช้คำสั่งในไลบรารี numpy โดยในที่นี่เราจะสุ่มโดยการใช้ Normal Distribution (หรือ Gaussian Distribution) ผ่านการใช้คำสั่ง Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mu, sigma = 0, 0.1
    data = np.random.normal(mu, sigma, 1000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้อาเรย์ที่ผ่านการสุ่มแบบ &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal Distribution&lt;/a&gt; ที่มีตัวเลขทั้งหมด 1,000 ค่าครับ โดยกำหนดค่าเฉลี่ยเท่ากับ 0 และค่าส่วนเบี่ยงเบนมาตรฐานเท่ากับ 0.1&lt;/p&gt;

&lt;h4 id=&quot;23-พล็อตกราฟ&quot;&gt;2.3 พล็อตกราฟ&lt;/h4&gt;

&lt;p&gt;เรานำอาเรย์ที่ผ่านการสุ่มแบบ Normal Distribution มาพล็อตกราฟได้โดยการใช้คำสั่งในไลบรารี matplotlib + seaborn ได้โดยการพิมพ์โค้ด Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    plt.xlabel(&quot;Sample&quot;)
    plt.ylabel(&quot;Count&quot;)
    sns.histplot(data=data, color=&quot;y&quot;, kde = True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;่จากตัวโค้ดเรากำหนดข้อความในแกน x เป็น Sample และแกน y เป็น Count แล้วพล็อตกราฟให้อยู่ในรูป Histrogram ที่มีพื้นหลังตัวกราฟเป็นสีเหลือง ร่วมกับกำหนด Distribution Cruve ผ่านการคำนวณโดย &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;Kernel Density Estimation&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-ส่งออกกราฟให้อยู่ในรูป-base64&quot;&gt;2.4 ส่งออกกราฟให้อยู่ในรูป base64&lt;/h4&gt;

&lt;p&gt;เราสามารถส่งออกกราฟที่พล็อตผ่าน matplotlib + seaborn ให้อยู่ในรูป base64 ที่สามารถแสดงได้ในแท็ก img โดยการพิมพ์โค้ด Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    img_str = 'data:image/png;base64,' + base64.b64encode(buf.getvalue()).decode('UTF-8')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;โค้ดตามด้านบนนี้ต้องการให้ส่งออกกราฟที่พล็อตได้ให้อยู่ในรูปไบนารีที่อยู่ในฟอร์แมต png และอยู่ในหน่วยความจำคอมพิวเตอร์ แล้วแปลงตัวไบนารีให้อยู่ในรูป base64&lt;/p&gt;

&lt;h4 id=&quot;25-นำมาเขียนรวมกัน&quot;&gt;2.5 นำมาเขียนรวมกัน&lt;/h4&gt;

&lt;p&gt;เราสามารถเขียนรวมกันได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np
    import seaborn as sns
    from matplotlib import pyplot as plt
    import base64, io

    mu, sigma = 0, 0.1
    data = np.random.normal(mu, sigma, 1000)

    plt.xlabel(&quot;Sample&quot;)
    plt.ylabel(&quot;Count&quot;)
    sns.histplot(data=data, color=&quot;y&quot;, kde = True)
        
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    img_str = 'data:image/png;base64,' + base64.b64encode(buf.getvalue()).decode('UTF-8');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;26-นำมาเขียนเพื่อให้ทำงานผ่านการใช้ไลบรารี-pyodide&quot;&gt;2.6 นำมาเขียนเพื่อให้ทำงานผ่านการใช้ไลบรารี Pyodide&lt;/h4&gt;

&lt;p&gt;เราเขียนให้ทำงานผ่าน Pyodide ได้ตามด้านล่างนี้ผ่านการใช้คำสั่งใน runPythonAsync แล้วนำค่าตัวแปรที่ได้ใน Python ออกมาให้ใช้งานผ่าน JavaScript ได้โดยเขียนโค้ดตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function drawGraph(pyodide)
  {
    await pyodide.runPythonAsync(`
        import numpy as np
        import seaborn as sns
        from matplotlib import pyplot as plt
        import base64, io

        mu, sigma = 0, 0.1
        data = np.random.normal(mu, sigma, 1000)

        plt.xlabel(&quot;Sample&quot;)
        plt.ylabel(&quot;Count&quot;)
        sns.histplot(data=data, color=&quot;y&quot;, kde = True)

        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        img_str = 'data:image/png;base64,' + base64.b64encode(buf.getvalue()).decode('UTF-8')
        plt.clf()
    `);

    let b64result = pyodide.globals.get(&quot;img_str&quot;);
    return b64result;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์เสร็จแล้ว เราสามารถเรียกใช้ฟังก์ชัน drawGraph(&amp;lt;ไลบรารี pyodide ที่โหลดมาแล้ว&amp;gt;);&lt;/p&gt;

&lt;h4 id=&quot;27-นำโค้ดที่ได้มาเขียนรวมกันเพื่อแสดงกราฟบนแท็ก-img&quot;&gt;2.7 นำโค้ดที่ได้มาเขียนรวมกันเพื่อแสดงกราฟบนแท็ก img&lt;/h4&gt;

&lt;p&gt;เรานำโค้ดที่เขียนอยู่ในรูปฟังก์ชันตามข้างบนนี้เพื่อให้ได้ภาพมาแสดงบนแท็ก img ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function onPageLoaded(event)
  {
      let img_canvas = document.getElementById('&amp;lt; id ของแท็ก img &amp;gt;'),
      let pyodide = await importLib();
      let b64result = await drawGraph(pyodide);
      img_canvas.src = b64result;
  }

  window.addEventListener('DOMContentLoaded', onPageLoaded);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อนำมารวมกันแล้วทดลองรันบนเว็บเบราวเซอร์ เราจะพบว่ากราฟจะพล็อตเมื่อหน้าเว็บเริ่มโหลด แล้วเมื่อเว็บโหลดเสร็จแล้ว เราจะเห็นกราฟที่อยู่ในแท็ก img ออกมาเป็นตามภาพด้างล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/pyodide_graph_result.png&quot; alt=&quot;Graph Result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เป็นไงล่ะ เราจะเห็นกราฟ Histrogram ที่ผ่านการสุ่มแบบ Normal Distribution นั่นเองครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;สำหรับตัวอย่างหน้าเว็บที่ทำเสร็จแล้ว ผู้อ่านสามารถเข้าไปดูที่ &lt;a href=&quot;https://asset.nickuntitled.com/demo/pyodide/pyodide_demo.html&quot;&gt;Demo&lt;/a&gt; นี่ได้เลยครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;จุดสังเกต&quot;&gt;จุดสังเกต&lt;/h2&gt;

&lt;p&gt;ตัวเว็บทำงานได้ช้าเนื่องมาจาก&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ตัวโค้ดตามด้านบนต้องดาวน์โหลดไลบรารี pyodide จาก CDN&lt;/li&gt;
  &lt;li&gt;ตัวโค้ดต้องเริ่มต้นการทำงาน pyodide ร่วมกับโหลดไลบรารีที่จำเป็น่ผ่านการดาวน์โหลดไลบรารีบน server&lt;/li&gt;
  &lt;li&gt;พล็อตกราฟผ่านการใช้คำสั่ง Python ที่อยู่บน pyodide อีกที&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;จากจุดสังเกตตามข้างบนนี้ สำหรับผู้อ่านที่มาอ่านบทความนี้แล้วจะนำไปใช้ อาจจะต้องพิจารณาประสิทธิภาพในการทำงานอีกทีครับ&lt;/p&gt;

&lt;p&gt;ถ้าเป็นไปได้ อาจจะลองใช้ไลบรารีที่มีอยู่แล้วอย่าง &lt;a href=&quot;https://www.chartjs.org/&quot;&gt;Chart.js&lt;/a&gt; หรือ &lt;a href=&quot;https://plotly.com/javascript/&quot;&gt;Plotly&lt;/a&gt; ก่อนก็ได้ครับผม ทั้งสองไลบรารีที่กล่าวมาในย่อหน้านี้ก็สามารถพล็อตกราฟให้สวยงามได้ตามใจชอบได้เช่นกัน&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Jupyter" /><category term="Data Science" /><category term="Pyodide" /><category term="Matplotlib" /><category term="Seaborn" /><category term="JavaScript" /><category term="Mozilla" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วิทยาการคำนวณ" /><category term="กราฟ" /><summary type="html">บทความนี้พูดถึงการรันโค้ดไพทอนโดยใช้ไลบรารี Pyodide โดยจะแนะนำไลบรารี การเริ่มต้นใช้งาน และพล็อตกราฟแล้วนำมาแสดงบน img ที่หน้าเว็บไซต์</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/03/plot_python_graph_website_pyodide_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/03/plot_python_graph_website_pyodide_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">รันโค้ด Jupyter โดยไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้</title><link href="https://nickuntitled.com/2022/02/13/running_jupyter_notebook_bg/" rel="alternate" type="text/html" title="รันโค้ด Jupyter โดยไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้" /><published>2022-02-16T00:00:00+07:00</published><updated>2022-02-16T00:00:00+07:00</updated><id>https://nickuntitled.com/2022/02/13/run-jupyter-background</id><content type="html" xml:base="https://nickuntitled.com/2022/02/13/running_jupyter_notebook_bg/">&lt;p&gt;Jupyter Notebook เป็นเครื่องมือที่ช่วยให้เรารันตัว Python Notebook ได้ ซึ่งตัวนี้เหมาะกับการเขียนโค้ดเพื่อคำนวณทางด้านวิทยาศาสตร์ หรือทำงานด้าน Data Science และอื่น ๆ เป็นต้น ซึ่งเราจะพบการใช้งานตัว &lt;a href=&quot;https://jupyter.org/&quot;&gt;Jupyter Notebook&lt;/a&gt; ได้บ่อย ๆ ใน &lt;a href=&quot;http://colab.research.google.com/&quot;&gt;Google Colab&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การใช้งานตัว Google Colab พบปัญหา เนื่องมาจากตัวฟรี หรือตัวโปรรุ่นล่าง ๆ จะเปิดให้รันบนเบื้องหลังได้ไม่นาน หลังจากนั้นตัวระบบจะตัดไป เพื่อนำทรัพยากรที่มีจำกัดให้กับบุคคลอื่นแทน ดังนั้นแล้วการใช้งาน Jupyter Notebook บนคอมพิวเตอร์ของเรา หรือบนเซิร์ฟเวอร์ของเราเองจะเป็นทางเลือกที่ดีกว่า&lt;/p&gt;

&lt;p&gt;เมื่อเราติดตั้งตัว jupyter Notebook ไว้ในคอมพิวเตอร์ของเราแล้ว เราเข้าตัว Notebook ่ผ่านทางหน้าเว็บเบราวเซอร์เพื่อใช้งาน เมื่อเรารันโค้ดที่มีใน Python Notebook แล้วปิดหน้าเว็บเบราวเซอร์ทิ้งไว้ ตัวผลลัพธ์อาจจะไม่ปรากฏบนหน้าจอ หรือเปิดให้รันโค้ดไปซักพักแล้วจะขึ้น Keyboard Interrupt แล้วตัวโค้ดที่รันไว้จะหยุดการทำงาน&lt;/p&gt;

&lt;p&gt;แล้วมีวิธีไหนที่จะรันตัวโค้ดที่เขียนอยู่ใน Python Notebook ให้ทำงานอยู่ถึงแม้ว่าเราจะปิดเว็บเบราวเซอร์ไปแล้วล่ะ? จากที่ไปค้นในเน็ตมีอยู่หลายวิธีได้แก่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;รันตัวโค้ดผ่านทาง SSH&lt;/li&gt;
  &lt;li&gt;รันผ่านทาง VNC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;วิธีแรกอันนี้ทำไม่ได้ เพราะเซิร์ฟเวอร์ที่ใช้อยู่ไม่ได้เปิดให้เข้าผ่านทาง SSH ดังนั้นแล้ว เราเลือกวิธีที่สองแทน โดยวิธีนี้เอามาจากใน&lt;a href=&quot;https://towardsdatascience.com/keep-jupyter-notebook-running-even-after-browser-is-closed-9a1937b7c615&quot;&gt;เว็บ Towards Data Science&lt;/a&gt; แล้วเอามาใช้กับงานเราครับ&lt;/p&gt;

&lt;p&gt;แต่ก่อนอื่นติดตั้ง ML workspace หรือติดตั้ง Jupyter Notebook ลงบนเซิร์ฟเวอร์ที่เราใช้งานอยู่ (หรือติดตั้งบนคลาวด์อย่าง DigitalOcean ก็ได้ ถ้าไม่มีสมาชิกก็&lt;a href=&quot;https://m.do.co/c/61ae5e7ddeb6&quot;&gt;สมัครสมาชิก&lt;/a&gt;ก่อน) อย่างไรก็ดีในตัวอย่างนี้เราแนะนำ ML workspace ที่ติดตั้งเป็นตัว Docker Container เพราะมันสะดวกมากกว่า แถมมันอยู่ใน Sandbox ไม่รบกวน OS หลักที่เราใช้งานอยู่&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มใช้งาน-และการเข้าไปใช้งาน-vnc&quot;&gt;การเริ่มใช้งาน และการเข้าไปใช้งาน VNC&lt;/h2&gt;

&lt;p&gt;เมื่อติดตั้งเสร็จแล้ว เราเริ่มทำได้โดยเปิดใช้งาน &lt;a href=&quot;https://github.com/ml-tooling/ml-workspace&quot;&gt;ML workspace&lt;/a&gt; ผ่านการใช้คำสั่งของ Docker เอง จากนั้นให้เราเข้าไปใช้งาน ML workspace โดย&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เข้าทางหน้าเว็บจากเครื่องคอมพิวเตอร์เครื่องมือ&lt;/li&gt;
  &lt;li&gt;เมื่อเข้ามาแล้ว เราจะพบหน้าจอ Jupyter Notebook ให้ใส่รหัสผ่านแล้วเข้ามาจะเจอหน้าจอหลักตามภาพแรก&lt;/li&gt;
  &lt;li&gt;เลื่อนเมาส์ไปยัง Tools ที่มุมบนขวา จากนั้นเลื่อนลงมาจะเจอ VNC ให้เลือกที่ VNC แล้วจะพบหน้าจอเดสก์ท็อปของลินุกซ์ ให้เราคลิกเมาส์ที่ Jupyter Notebook ตามภาพต่อมา&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/jupyter_notebook.jpeg&quot; alt=&quot;Jupyter Notebook&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/vnc.jpeg&quot; alt=&quot;VNC&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มรัน-jupyter-notebook&quot;&gt;การเริ่มรัน Jupyter Notebook&lt;/h2&gt;

&lt;p&gt;เมื่อเราเข้าไปใช้งาน Jupyter Notebook ผ่านตัว VNC แล้ว ให้เราเลือกไฟล์ Python Notebook ที่เราต้องการ จากนั้นเลือกที่ Run Cells ที่มันรันนาน ๆ (ของเราเป็นการทำ Inference ของ Head Pose Estimation จากไฟล์วิดีโอ)&lt;/p&gt;

&lt;p&gt;เมื่อกดเริ่มรันเรียบร้อย ระหว่างที่มันรันอยู่ ให้เราเลือกที่ Disconnect ที่ด้านซ้ายตามลูกศร&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/jupyter_vnc.jpeg&quot; alt=&quot;Running Jupyter Notebook on VNC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;กดปุ่ม Disconnect แล้ว ระบบจะตัดการเชื่อมต่อไป ระหว่างนี้ตัวโค้ดก็ยังรันอยู่ตามปกติโดยที่ไม่เจอการตัดการทำงานของตัวโค้ดเลย ยกเว้นแต่ว่ามีคนไปปิดเครื่องเซิร์ฟเวอร์ หรือไฟดับระหว่างที่รันครับ&lt;/p&gt;

&lt;p&gt;สำหรับผู้อ่านที่สนใจ สามารถไปประยุกต์ใช้ได้เลย วิธีนี้ใช้ง่ายดี ไม่ต้องเข้าผ่าน SSH แล้วพิมพ์คอมมานไลน์ให้ยุ่งยากฮะ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Jupyter" /><category term="Data Science" /><category term="AI" /><category term="Artificial Intelligence" /><category term="Machine Learning" /><category term="Notebook" /><category term="Background" /><category term="Python Notebook" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วิทยาการคำนวณ" /><category term="ปัญญาประดิษฐ์" /><summary type="html">บทความนี้พูดถึงการใช้ Jupyter โดยรันตัว Python Notebook ที่ไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/02/jupyter_notebook_bg_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/02/jupyter_notebook_bg_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">เขียนโค้ดจาวาสคริปเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่</title><link href="https://nickuntitled.com/2022/02/03/coding_check_metamask_crypto_web3/" rel="alternate" type="text/html" title="เขียนโค้ดจาวาสคริปเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่" /><published>2022-02-03T00:30:00+07:00</published><updated>2022-02-03T00:30:00+07:00</updated><id>https://nickuntitled.com/2022/02/03/check-web3-browser-javascript</id><content type="html" xml:base="https://nickuntitled.com/2022/02/03/coding_check_metamask_crypto_web3/">&lt;p&gt;Web3 (ที่ไม่ใช่ &lt;a href=&quot;https://en.wikipedia.org/wiki/Semantic_Web&quot;&gt;Web 3.0&lt;/a&gt; ตามที่คุณ Tim Berners-Lee กล่าวไว้) เป็นเว็บไซต์รูปแบบหนึ่งที่อยู่บนบล็อคเชนที่นำหลักการ Decentralization และหลักการ Token-based economics ตัวอย่างเช่นคริปโต โดย Web3 ที่พบได้ และบางคนก็ใช้ก็ตัวอย่างเช่น DeFi แบบ Pancakeswap หรืออื่น ๆ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี เวลาที่เปิดใช้งานเว็บแนวนี้เราก็ต้องเช็คก่อนครับว่ามีกระเป๋าตังคริปโต (ที่ได้ยินบ่อยก็เป็น MetaMask) หรือไม่ ถ้ามี เราก็เปิดให้เชื่อมกับกระเป๋าตังสำหรับใช้ทำธุรกรรม Smart Contract หรืออื่น ๆ ต่อได้เลย แต่ถ้าไม่มีก็ให้เว็บแจ้งว่าไม่มี&lt;/p&gt;

&lt;h2 id=&quot;เขียนโค้ด&quot;&gt;เขียนโค้ด&lt;/h2&gt;

&lt;p&gt;หลังจากที่เกริ่นมาสักพักแล้ว เรามาเขียนโค้ดกันดีกว่า ในขั้นตอนแรก เราก็ต้องเช็คว่ามีตัวแปรที่เกี่ยวข้องกับ MetaMask หรือไม่ โดยเขียนโค้ดตามด้านล่างนี้&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;โค้ดบางส่วนนำมาจาก &lt;a href=&quot;https://ethereum.stackexchange.com/questions/44601/how-to-check-whether-metamask-is-installed&quot;&gt;StackOverflow&lt;/a&gt; และเอกสารจากทางเว็บ &lt;a href=&quot;https://docs.metamask.io/guide/ethereum-provider.html#properties&quot;&gt;MetaMask&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if(typeof window.ethereum != &quot;undefined&quot; || typeof window.web3 != &quot;undefined&quot;) {

  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเช็คแล้วว่ามีตัวแปรที่เกี่ยวข้องแล้ว เราก็เรียกใช้งานตัวแปรที่เกี่ยวข้องแล้วอ่านค่าตัวแปรนี้ว่ามี MetaMask หรือไม่ โดยเขียนโค้ดตามด้านล่างนี้ในปีกกาครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const web3provider = window.ethereum || window.web3.currentProvider;
  const metamask = web3provider.isMetaMask;

  if(metamask) {
    console.log(&quot;We found MetaMask.&quot;);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียนโค้ดตามข้างบนนี้เสร็จแล้ว โค้ดที่ได้จะตามด้านล่างนี้&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if(typeof window.ethereum != &quot;undefined&quot; || typeof window.web3 != &quot;undefined&quot;) {
    const web3provider = window.ethereum || window.web3.currentProvider;
    const metamask = web3provider.isMetaMask;

    if(metamask) {
      console.log(&quot;We found MetaMask.&quot;);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราทดสอบบนเว็บเบราวเซอร์ที่ติดตั้ง MetaMask อยู่ เราเปิดหน้า JavaScript Console จะปรากฏผลลัพธ์ว่า&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  We found MetaMask.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ส่วนกรณีที่ไม่มี MetaMask ติดตั้งอยู่ เวลาเรียกใช้ฟังก์ชันตามข้างบนนี้จะพบ Error ขึ้นมากล่าวประมาณว่าไม่พบตัวแปร window.ethereum และ window.web3.currentProvider ครับ&lt;/p&gt;

&lt;p&gt;เมื่อเราเขียนโค้ดตามข้างบนนี้แล้ว เราสามารถรประยุกต์ใช้งานเพื่อทำธุรกรรมอื่นต่อ หรือทำแบนเนอร์บอกว่าเราใช้งาน Web3 อยู่นะ อะไรประมาณนี้ครับ ตัวอย่างก็พบได้ในหน้าโฮมของเว็บนี้ หรือตามวิดีโอด้านล่างนี้ได้ครับ&lt;/p&gt;

&lt;video src=&quot;https://asset.nickuntitled.com/2022/02/nickuntitled_web3.mp4&quot; controls=&quot;&quot;&gt;
  เว็บเบราวเซอร์ของท่านไม่รองรับการใช้งานวิดีโอ อย่างไรก็ดีเราอธิบายวิดีโอนี้ได้ว่ามันเกี่ยวกับการเปิดใช้งานบนเว็บเบราวเซอร์ที่ติดมากับ MetaMask ครับ
&lt;/video&gt;

&lt;p&gt;สำหรับผู้อ่านแล้ว ผู้อ่านสามารถประยุกต์เอาไปใช้งานกับเว็บตัวเองได้เลยครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="Web3" /><category term="MetaMask" /><category term="Cryptocurrency" /><category term="Wallet" /><category term="Ethereum" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><summary type="html">บทความนี้พูดถึงการเขียนโค้ดเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่ สำหรับการนำไปใช้ทำธุรกรรมต่อ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/02/metamask_checker_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/02/metamask_checker_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">การเขียนโค้ดเพื่อใช้งาน GraphQL โดยไม่ใช้ไลบรารี</title><link href="https://nickuntitled.com/2022/01/25/graphql_without_library/" rel="alternate" type="text/html" title="การเขียนโค้ดเพื่อใช้งาน GraphQL โดยไม่ใช้ไลบรารี" /><published>2022-01-25T06:30:00+07:00</published><updated>2022-01-25T06:30:00+07:00</updated><id>https://nickuntitled.com/2022/01/25/graphql-without-library</id><content type="html" xml:base="https://nickuntitled.com/2022/01/25/graphql_without_library/">&lt;p&gt;เวลาที่ส่งข้อมูลระหว่าง Client และ Server ผ่านทางจาวาสคริปโดยเรียกใช้งานผ่านทาง &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX&quot;&gt;AJAX&lt;/a&gt; ปกติ เราจะส่งข้อมูลโดยวิธี POST ผ่านการพิมพ์โค้ดตามด้านล่างนี้ (ในตัวอย่างจะใช้ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; แต่จะใช้ Fetch, Axios หรืออื่น ๆ ก็ได้ เพราะได้ผลเหมือนกัน)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();

  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;url&amp;gt;&quot;);

  ajaxrequest.onload = (event) =&amp;gt; {
      if(ajaxrequest.readyState == ajaxrequest.DONE) {
          if(ajaxrequest.status == 200) {
              /* Do Something */
          } else {
              console.error(&quot;[*] Error!);
          }
      }
  };

  ajaxrequest.onprogress = (event) =&amp;gt; {
      console.log('Processing...');
  };

  ajaxrequest.send(`argument=value&amp;amp;argument2=value`);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อใช้งานคำสั่งนี้แล้ว ข้อมูลจะได้รับการส่งไปยัง Server เพื่อประมวลผลต่อ จากนั้นเมื่อประมวลผลสำเร็จแล้ว ทางฝั่ง Server จะส่งข้อมูลกลับมาทาง Client เพื่อนำไปประมวลผลต่อ ขั้นตอนนี้แหละ ที่คนนำไปสร้าง API ที่ใช้กันอยู่ในปัจจุบันนี้ที่มีชื่อว่า REST API&lt;/p&gt;

&lt;h2 id=&quot;rest-api&quot;&gt;REST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@settawatjanpuk/beginner-%E0%B8%A1%E0%B8%B2%E0%B8%97%E0%B8%B3%E0%B8%84%E0%B8%A7%E0%B8%B2%E0%B8%A1%E0%B8%A3%E0%B8%B9%E0%B9%89%E0%B8%88%E0%B8%B1%E0%B8%81%E0%B8%81%E0%B8%B1%E0%B8%9A-rest-api-%E0%B8%81%E0%B8%B1%E0%B8%99%E0%B8%94%E0%B8%B5%E0%B8%81%E0%B8%A7%E0%B9%88%E0%B8%B2-%E0%B8%A1%E0%B8%B5%E0%B8%95%E0%B8%B1%E0%B8%A7%E0%B8%AD%E0%B8%A2%E0%B9%88%E0%B8%B2%E0%B8%87-c855d93beaf3&quot;&gt;REST API&lt;/a&gt; (ย่อมาจาก Representational State Transfer API) เป็นรูปแบบการส่งข้อมูลรูปแบบหนึ่งที่อยู่บนพื้นฐานของ HTTP Protocol เทคนิคนี้อนุญาตให้เราส่งข้อมูลในรูปแบบ JSON (JavaScript Object Notion), Text, File หรืออื่น ๆ แต่ที่ใช้กันบ่อยก็เป็น JSON เนื่องจากสะดวก และรองรับเว็บเบราวเซอร์หลายชนิด แถมเทคนิคนี้ใช้งานได้ง่าย ใช้ทำ Web Service ที่เกี่ยวข้องกับ CRUD ได้เลย เนื่องจากเราใช้งานโค้ดตามข้างบนได้เพียงแต่เปลี่ยนวิธีการส่งข้อมูลผ่านทาง HTTP Protocol ตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GET — R(etrieve) เรียกดูข้อมูล&lt;/li&gt;
  &lt;li&gt;POST — C(reate) เพิ่มข้อมูล&lt;/li&gt;
  &lt;li&gt;PUT — U(pdate) แก้ไขข้อมูล&lt;/li&gt;
  &lt;li&gt;DELETE — D(elete) ลบข้อมูล&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;อย่างไรก็ดี เราไม่จำเป็นต้องใช้งานตามข้างบนนี้เป๊ะ ๆ ก็ได้ ใช้งานแค่ POST กับ GET ก็ยังใช้งานได้ตามปกติ เพียงแต่ขึ้นกับทีมที่เขียนโปรแกรมว่าตกลงยังไงนี่แหละครับ&lt;/p&gt;

&lt;p&gt;ต่อมา เราจะมาพูดถึง GraphQL&lt;/p&gt;

&lt;h2 id=&quot;graphql&quot;&gt;GraphQL&lt;/h2&gt;

&lt;p&gt;REST API เป็นไลบรารีที่นิยมสำหรับการสร้าง Web Service อย่างไรก็ดีการใช้งาน REST API ก็มีข้อเสียหลัก ๆ ก็ต้องส่งข้อมูลผ่านทาง HTTP Protocol หลายรอบ (Multiple requests) และรับข้อมูลที่มากเกินจำเป็น (Over-fetching)&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้ว &lt;a href=&quot;https://graphql.org/&quot;&gt;GraphQL&lt;/a&gt; จึงได้รับการพัฒนาขึ้นเพื่อแก้ปัญหาตามย่อหน้าด้านบนนี้ แล้วมันคืออะไร?&lt;/p&gt;

&lt;p&gt;GraphQL เป็นโค้ดภาษาหนึ่งที่ใช้เรียกงาน API ผ่านทาง HTTP Protocol รูปแบบหนึ่งเพื่อจัดการข้อมูลได้ตามที่ต้องการ เครื่องมือนี้ได้รับการพัฒนาโดยบริษัท Meta (Facebook เดิม) ตั้งแต่ปี 2012 และเทคนิคนี้ได้รับการนำไปใช้งานจริงในหลายเว็บไซต์ ได้แก่ Github, Pinterest, Coursera เป็นต้น&lt;/p&gt;

&lt;p&gt;การใช้งาน ใช้งานได้ไม่ยากผ่านทางไลบรารีที่นิยมอย่างตัว GraphQL เอง หรือใช้งานผ่านไลบรารี Apollo Server/Client ก็ได้ อย่างไรก็ดี ในบทความนี้จะไม่ลงลึกเรื่องไลบรารี เราจะมาพูดถึงการส่งข้อมูล GraphQL ที่ไม่ได้ใช้งานไลบรารีกันดีกว่า&lt;/p&gt;

&lt;p&gt;การส่งข้อมูลผ่านทาง GraphQL ที่ใช้งานบ่อยก็เป็นการเรียกข้อมูล และการจัดการข้อมูลผ่านทางการใช้คำสั่งที่เกี่ยวข้องกับ query และ mutation&lt;/p&gt;

&lt;h3 id=&quot;query&quot;&gt;query&lt;/h3&gt;

&lt;p&gt;query เป็นการเรียกใช้ฟังก์ชันเพื่อดึงข้อมูลจากฐานข้อมูล สำหรับการแสดงผล และประมวลผลบน Client ในขั้นตอนต่อไป เราเขียน Schema สำหรับการเรียกข้อมูลบนเซิร์ฟเวอร์ได้ตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {
    &amp;lt;GraphQL query command&amp;gt;(&amp;lt;GraphQL query arguments&amp;gt;) {
      &amp;lt;the data that you want to be returned from the server&amp;gt;
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวอย่างการเขียน Schema ก็เขียนตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let str_query = `{
    getUser(user_id: &quot;${ user_id }&quot;) {
        name
        surname
    }
  }`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียน Schema เสร็จแล้ว เราเขียน Argument สำหรับการนำไปใช้งานผ่าน XMLHttpRequest ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = {
      query: str_query
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียน Argument เสร็จแล้ว เราก็ต้องส่งข้อมูลจาก Client ไปยัง Server เราส่งข้อมูลผ่าน XMLHttpRequest ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
    
  ajaxrequest.responseType = 'json';
  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;URL for GraphQL Server&amp;gt;&quot;);
  ajaxrequest.setRequestHeader('Content-Type', 'application/json');
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };

  ajaxrequest.send(JSON.stringify(query));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้น เมื่อเรียกใช้งานคำสั่งตามด้านบนนี้ ข้อมูลที่เขียนในรูปแบบ GraphQL จะส่งจาก Client ไปยัง Server แล้วทางนั้นจะคืนข้อมูล name, surname ที่อยู่ในรูปแบบ JSON ได้ตามที่ต้องการครับ&lt;/p&gt;

&lt;h3 id=&quot;mutation&quot;&gt;mutation&lt;/h3&gt;

&lt;p&gt;mutation เป็นการเรียกใช้ฟังก์ชันเพื่อเปลี่ยนแปลงข้อมูล แล้วแสดงผลข้อมูลกลับมาที่เราต้องการ เราเขียน Schema ของ mutation ได้ตามตัวอย่างด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = `mutation {
    &amp;lt;GraphQL Mutation Command&amp;gt;(&amp;lt;Arguments&amp;gt;) {
      &amp;lt;the data that you want to be returned from the server&amp;gt;
    }
  }`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เรานำ Argument ที่เขียนแล้วส่งข้อมูลผ่านทาง XMLHttpRequest ได้ด้วยการเขียนโค้ดตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
  let form_data = new FormData();
  let map = {};

  ajaxrequest.responseType = 'json';
  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;GraphQL server URL&amp;gt;&quot;);
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };

  // FormData
  form_data.append(&quot;operations&quot;, JSON.stringify({ query }));
  form_data.append(&quot;map&quot;, JSON.stringify(map));

  // Send Form Data
  ajaxrequest.send(form_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สำหรับการอัพโหลดไฟล์ เราพิมพ์ Schema เพื่ออัพโหลดไฟล์ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = `mutation($file: Upload!) {
      &amp;lt;GraphQL Upload mutation command&amp;gt;(&amp;lt;Arguments&amp;gt;, upload_file: $file) {
          &amp;lt;the data that you want to be returned from the server&amp;gt;
      }
  }`;
  let variables = { &quot;file&quot;: null };
  let map = { &quot;0&quot;: [&quot;variables.file&quot;] };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วสร้างตัวแปรเพื่อรองรับ File Object สำหรับการอัพโหลดไฟล์ตามโค้ดด้านล่าง ในตัวอยา่งจะใช้ File Input ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let fileObj = document.getElementById('&amp;lt;File Input ID&amp;gt;').files[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เราเรียกใช้งาน XMLHttpRequest เจ้าเดิมได้โดยการพิมพ์คำสั่งตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
  ajaxrequest.responseType = 'json';
  ajaxrequest.open('POST', graphql_url);
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };
  
	// FormData
	form_data.append(&quot;operations&quot;, JSON.stringify({ query, variables }));
	form_data.append(&quot;map&quot;, JSON.stringify(map));
	form_data.append(&quot;0&quot;, fileObj);

	// Send Form Data
  ajaxrequest.send(form_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเรียกใช้งานจะพบว่าไฟล์ได้รับการอัพโหลดเรียบร้อย&lt;/p&gt;

&lt;p&gt;เมื่อเราเขียนโค้ดตามด้านบนแล้ว สามารถทดสอบบนเว็บเบราวเซอร์ได้เลย ผลลัพธ์ก็จะเหมือนการใช้งาน GraphQL ผ่านทางไลบรารี อย่างไรก็ดี การใช้งานตามที่เขียนนี้จะดูยุ่งยากกว่าการใช้งานผ่านทางไลบรารีครับ ดังนั้นแล้วถ้าใช้งานไลบรารีได้ ก็แนะนำให้ใช้ไลบรารีได้ก่อนได้เลย โดยไลบรารีที่เราเคยใช้ก็ตัวอย่างเช่น &lt;a href=&quot;https://www.apollographql.com/docs/react/&quot;&gt;Apollo Client&lt;/a&gt; ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="GraphQL" /><category term="AJAX" /><category term="Httprequest" /><category term="XMLHttpRequest" /><category term="HTTP" /><category term="POST" /><category term="JSON" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วัตถุ" /><summary type="html">บทความนี้แนะนำวิธีการเขียนโค้ด JavaScript เพื่อใช้งาน GraphQL แบบที่ไม่ได้ใช้ไลบรารี</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/01/graphql_js_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/01/graphql_js_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วิธีการเลือก parent element ด้วย JavaScript</title><link href="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/" rel="alternate" type="text/html" title="วิธีการเลือก parent element ด้วย JavaScript" /><published>2022-01-02T22:30:00+07:00</published><updated>2022-01-02T22:30:00+07:00</updated><id>https://nickuntitled.com/2022/01/2/element-closest</id><content type="html" xml:base="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/">&lt;p&gt;ปกติเวลาที่เราเลือก element ด้วยภาษาจาวาสคริป เราจะใช้คำสั่งที่รู้จักกันอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.getElementById(&quot;id&quot;);
document.document.getElementsByClassName(&quot;class name&quot;);
document.document.getElementsByName(&quot;name&quot;);
document.document.getElementsByTagName(&quot;tag name&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเลือก element โดยการใช้ CSS Selector ด้วยคำสั่งที่รู้จักอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.querySelector(&quot;selector&quot;);
parent_element.querySelector(&quot;selector&quot;);
document.querySelectorAll(&quot;selector&quot;);
parent_element.querySelectorAll(&quot;selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งเหล่านี้ะคืนค่า element ที่เราเลือกไว้ ไม่ว่าจะเป็น element เดียว หรือ element ทั้งหมดที่เราพบในหน้าเว็บเพจนั้น ๆ อย่างไรก็ดีเราต้องการเลือก parent element จาก element ที่อยู่ภายใน จุดนี้เราจะทำได้อย่างไร?&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery&lt;/h2&gt;

&lt;p&gt;jQuery เป็นหนึ่งในไลบรารีที่คนนิยมใช้งานกัน เราเลือก parent element ได้โดยการพิมพ์คำสั่งอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).closest(&quot;parent css selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สองคำสั่งนี้จะอนุญาตเราเลือก parent element ได้ตามที่ต้องการเลย อย่างไรก็ดี ทั้งสองคำสั่งนี้มีข้อแตกต่างกัน เรายกตัวอย่างตามภาพด้านล่างนี้ก่อน&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานทั้งสองคำสั่งได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).parent().parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).closest(&quot;div&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทั้งคู่จะเลือก parent element ที่เป็น div ครับ&lt;/p&gt;

&lt;p&gt;สรุปความแตกต่างระหว่างสองคำสั่งตามข้างบนนี้ตรงที่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.parent() เป็นคำสั่งที่ให้เราเลือก element ที่เป็น parent และอยู่ติดกับ element ที่เราเลือก&lt;/li&gt;
  &lt;li&gt;.closest() เป็นการเลือก element ที่อยู่เหนือ และอยู่ใกล้กันกับ element ที่เราเลือกไว้โดยการใช้ css selector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;อย่างไรก็ดีไลบรารีนี้มีข้อเสียได้แก่ ไลบรารีมีขนาดใหญ่ส่งผลต่อระยะเวลาการโหลดไลบรารีเพื่อใช้งาน กับไลบรารีนี้เก่าไปแล้ว เนื่องมาจากตัวจาวาสคริปเองได้รับการพัฒนาอย่างต่อเนื่องจนทำงานได้แบบเดียวกันกับ jQuery แต่ไม่ต้องพึ่งพาไลบรารีที่มีขนาดใหญ่ และทำงานได้เร็วมากกว่าไลบรารีที่กล่าวถึง&lt;/p&gt;

&lt;p&gt;ต่อไป เราจะมาพูดถึงคำสั่งที่มีอยู่แล้วในจาวาสคริป (หรือเรียกว่า &lt;a href=&quot;http://vanilla-js.com&quot;&gt;Vanilla JavaScript&lt;/a&gt;) ที่อนุญาตให้เราเลือก parent element ครับ คำสั่งเหล่านี้ได้แก่ node.parentNode, element.parentElement และ element.closest&lt;/p&gt;

&lt;h2 id=&quot;nodeparentnode-กับ-elementparentelement&quot;&gt;node.parentNode กับ element.parentElement&lt;/h2&gt;

&lt;p&gt;ทั้งคู่นี้เป็นคำสั่งในจาวาสคริปที่เลือก parent node หรือ element ที่อยู่เหนือกว่า node หรือ element ที่เราเลือก ตัวอย่างการใช้งานคำสั่งนี้เป็นไปตามด้านล่างนี้ครับ (ตัวอย่างด้านล่างเอามาจากหน้าเว็บ &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.body.parentNode; // the &amp;lt;html&amp;gt; element
document.body.parentElement; // the &amp;lt;html&amp;gt; element
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือยกตัวอย่างจากภาพเดิม&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById('li');
let div = li.parentNode.parentNode;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById('li');
let div = li.parentElement.parentElement;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราก็จะเลือก parent Element ที่เป็น div ได้เลย ถ้าลองสังเกตดูจะพบว่าทั้งสองคำสั่งมันก็ใช้ได้เหมือนกันนี่ แล้วมันต่างกันอย่างไร?&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงความแตกต่างระหว่าง Node กับ Element เสียก่อน (ความแตกต่างสรุปจาก&lt;a href=&quot;https://blog.webdevsimplified.com/2021-05/node-vs-element/&quot;&gt;หน้าเว็บนี้&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Element ก็คือ HTML tag ต่าง ๆ ที่อยู่ในหน้าเว็บไซต์ ได้แก่ div, span, body หรืออื่น ๆ&lt;/li&gt;
  &lt;li&gt;Node จะเป็นอะไรก็ได้ที่มีอยู่ในหน้าเว็บไซต์ รวมถึงข้อความ คอมเม้นต์ ไม่จำกัดว่าเป็น div, span, body, input, form หรืออื่น ๆ ที่เป็น HTML tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เราจะเห็นว่าการเลือก Node จะดูยุ่งยากกว่า เพราะเราค้องแยกระหว่างข้อความ คอมเม้นต์ หรือ HTML tag ดังนั้นแล้ว การใช้งาน Element จะดูจำเพาะมากกว่า&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถดูวิดีโอความแตกต่างระหว่าง Element กับ Node ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/rhvec8cXLlo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;ต่อมา เรามาดูความแตกต่างการใช้งานของสองคำสั่ง (โค้ดอ้างอิงจาก &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.documentElement.parentNode;    // document เป็น node
document.documentElement.parentElement; // null เนื่องจาก document ไม่ใช่ element
(document.documentElement.parentNode === document);  // true
(document.documentElement.parentElement === document);  // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะเห็นว่า document ไม่ได้เป็นหนึ่งใน HTML tag อะไรเลยตามที่กล่าวไว้ตามข้างบน และ document ไม่ได้เป็น element แต่ก็ยังเป็น node อยู่ ดังนั้นการใช้งาน element.parentElement จะคืนค่า null กลับมา&lt;/p&gt;

&lt;h2 id=&quot;elementclosest&quot;&gt;element.closest&lt;/h2&gt;

&lt;p&gt;คำสั่งนี้เป็นส่วนหนึ่งในภาษาสคริปที่อนุญาตให้เราเลือก parent element ที่อยู่ใกล้กันกับ element ที่เราเลือกอยู่โดยการใช้ CSS Selector การใช้งานใช้งานได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;element.closest(&quot;CSS selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ยกตัวอย่างโดยเอารูปเดิมมาใช้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById('li');
let div = li.closest('div');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์ตามข้างบนนี้แล้ว เราจะเลือก parent element ที่เป็น div ครับ เมื่อสังเกตตัวโค้ดแล้วพบว่าใช้งานได้สะดวกมากกว่า node.parentNode กับ element.parentElement&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดีการใช้งานทั้งสามคำสั่งได้แก่ node.parentNode, element.parentElement และ element.closest นี้ขึ้นกับผู้ใช้ว่าจะเอาไปใช้อย่างไรครับ ส่วนกรณีที่ผู้ใช้ไม่ได้ใช้ Vanilla JavaScript  คำสั่งทั้งสามคำสั่งนี้อาจจะไม่ได้ใช้เลยก็ได้ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="Element" /><category term="Selector" /><category term="Parent Element" /><category term="Programming" /><category term="getElementById" /><category term="getElementsByClassName" /><category term="getElementsByName" /><category term="getElementsByTagName" /><category term="querySelector" /><category term="querySelectorAll" /><category term="Node" /><category term="Parent Node" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วัตถุ" /><summary type="html">บทความนี้แนะนำวิธีการเลือกวัตถุ parent element ด้วยการใช้ภาษา JavaScript</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python</title><link href="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/" rel="alternate" type="text/html" title="วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python" /><published>2021-12-08T00:30:00+07:00</published><updated>2021-12-08T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/10/interpupillary-distance=measurement-python</id><content type="html" xml:base="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/">&lt;p&gt;อันนี้เป็นส่วนหนึ่งของงานวิจัย ทำไปแล้วบางส่วน&lt;/p&gt;

&lt;p&gt;ปกติการวัดตาดำ เราจะพบได้ในคนที่เลือกขนาดเครื่อง Virtual Reality Headset หรือวัดขนาดแว่นตา หรืออื่น ๆ ปกติเราจะใช้ไม้บรรทัดวัดเพื่อให้รู้ว่าระยะห่างระหว่างตาดำ (Interpupillary Distance) มีระยะห่างเท่าไร อย่างไรก็ดีเราจะใช้ไม้บรรทัดวัดไปตลอดเหรอก็ไม่สะดวกเท่าไร แถมสมัยนี้เราก็ใช้คอมพิวเตอร์กันอยู่แล้วด้วย เลยเอามาเขียนโค้ดส่วนนี้เพื่อจับระยะการอ้าปากครับ&lt;/p&gt;

&lt;p&gt;หลักการวัดจากภาพดิจิทัล โดยปกติเวลาที่เราวัดจะได้หน่วยการวัดเป็น pixel แต่สิ่งที่เราต้องการก็คือ ต้องการการวัดที่มีหน่วยเป็นเซนติเมตร หรือมิลลิเมตรที่ตัวโปรแกรมวัดด้วยตัวเองไม่ได้ เราจำเป็นต้องหาวัตถุอ้างอิงเพื่อเป็น Reference สำหรับการแปลงหน่วยจาก pixel เป็นหน่วยที่เราวัดครับ&lt;/p&gt;

&lt;p&gt;ในตัวอย่างนี้ เราจะใช้บัตรประชาชนซึ่งเป็นสิ่งที่คนทุกคนมีกันอยู่แล้ว (ยกเว้นเด็กเล็ก) เป็นวัตถุ Reference ใช้สำหรับการวัดในครั้งนี้ ขนาดของบัตรประชาชน (ไทย) มีขนาดที่เป็นมาตรฐาน โดนมีขนาดด้านยาว 86 mm ด้านกว้าง 54 mm เราจะใช้ด้านยาวเป็น Reference&lt;/p&gt;

&lt;p&gt;แต่ก่อนที่จะไปวัด เราจะต้องแยกส่วน (Segment) บัตรประชาชนออกจากวัตถุอื่นในภาพก่อน แล้วจะทำอย่างไรดี หลักการนี้เรียกว่า Image Segmentation&lt;/p&gt;

&lt;h2 id=&quot;image-segmentation&quot;&gt;Image Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/mask_rcnn_segmentation.png&quot; alt=&quot;Image Segmentation&quot; /&gt;
ภาพตัวอย่างการ Segmentation จากเปเปอร์​ Mask R-CNN&lt;/p&gt;

&lt;p&gt;Image Segmentation เป็นหลักการจำแนก pixel ของวัตถุที่เราต้องการออกมาจากวัตถุอื่นในภาพดิจิทัล โดยยกตัวอย่างเช่นระบบการขับรถอัตโนมัติ (self-driving car) ที่จับคนในภาพเพื่อป้องกันไม่ให้เกิดอุบัติเหตุครับ หลักการนี้แบ่งออกมาได้เป็นสองวิธีได้แก่ Semantic Segmentation และ Instance Segmentation&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Semantic Segmentation เป็นการแยกวัตถุออกจากภาพวัตถุอื่นโดยการแบ่งประเภทของวัตถุ (class) จากภาพ ได้แก่ สีแดงเป็นคน สีน้ำเงินเป็นรถ เป็นต้น&lt;/li&gt;
  &lt;li&gt;Instance Segmentation เป็นการแบ่งวัตถุแต่ละชิ้นในภาพ ที่แตกต่างกับ Semantic Segmentation ที่แบ่งเป็นวัตถุที่ 1,2,3,4 เป็นต้น&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ตัวอย่างของเทคนิคที่ใช้ Image Segmentation คือ Mask R-CNN, U-NET ครับ&lt;/p&gt;

&lt;h2 id=&quot;u-net&quot;&gt;U-NET&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_artchitecture.png&quot; alt=&quot;U-NET Architecture&quot; /&gt;
ภาพโครงสร้าง U-NET&lt;/p&gt;

&lt;p&gt;U-NET ที่เป็นคนละอันกันกับ O-NET ที่สอบมัธยมศึกษาตอนปลายเข้ามหาวิทยาลัยที่จัดโดยสทศ ครับ&lt;/p&gt;

&lt;p&gt;U-NET เป็นโครงข่ายประสาทเทียม (Neural Network Architecture) แบบ Convolutional Neural Network ที่ให้ผลลัพธ์เป็น Matrix ที่มีขนาดกว้าง x ยาวเท่ากันกับภาพเดิม โดยในแต่ละตำแหน่งจะระบุได้ว่าเป็น 0 (ไม่มีภาพ Object) หรือ 1 (มี Object) ในภาพ&lt;/p&gt;

&lt;p&gt;โครงสร้างของเครือข่ายประสาท U-NET เราจะเห็นว่าเป็นรูปตัว U (U-shape) ที่แบ่งเป็นสองช่วง ได้แก่ Contracting Path (ด้านซ้าย) และ Upsampling Path (ด้านขวา) เราจะอธิบายในแต่ละส่วนตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h3 id=&quot;contract-path&quot;&gt;Contract Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_downsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Contract Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;3x3 Convolutions (ที่ไม่มี Padding) 2 รอบ&lt;/li&gt;
  &lt;li&gt;ตามมาด้วย Activation Function ReLU&lt;/li&gt;
  &lt;li&gt;ใช้ 2x2 Max Pooling ที่มี Stride 2 เพื่อ Down Sampling ระหว่างที่ทำ Down Sampling เราจะเพิ่มจำนวน Feature Channel เป็น 2 เท่าในแต่ละครั้ง&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;upsampling-path&quot;&gt;Upsampling Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_upsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Upsampling Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Up Sampling แล้วตามด้วย 2x2 Convolutions (หรือเรียกอีกอย่างว่า “up-convolution”) ที่แบ่งครึ่งจำนวน Channels&lt;/li&gt;
  &lt;li&gt;นำภาพที่ได้จากขั้นตอนการทำ 3x3 Convolutions + ReLU ใน Contract Path ที่ผ่านการ Cropped แล้วมา Concatenate&lt;/li&gt;
  &lt;li&gt;ทำ 3x3 Convolutions สองรอบ แล้วตามด้วย ReLU&lt;/li&gt;
  &lt;li&gt;ทำไปจนกระทั่งถึง Layer สุดท้าย เราทำ 1x1 Convolution เพื่อนำ 64 Component Feature Vector ให้เป็นจำนวน Classes ที่เราต้องการ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;จำนวน Convolutional Layer ทั้งหมดที่ใช้ใน U-NET มีทั้งหมด 23 Layers ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลเพิ่มเติมของ U-NET ผู้อ่านศึกษาได้ใน&lt;a href=&quot;https://arxiv.org/abs/1505.04597&quot;&gt;เปเปอร์ U-Net: Convolutional Networks for Biomedical Image Segmentation จากเว็บ arXiv&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h2 id=&quot;midv-500&quot;&gt;MIDV-500&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/midv_500.png&quot; alt=&quot;MIDV-500 Dataset&quot; /&gt;
ตัวอย่างรูปภาพในฐานข้อมูล MIDV-500&lt;/p&gt;

&lt;p&gt;MIDV-500 หรือเรียกอีกอย่างว่า Mobile Identity Document Video dataset ที่ประกอบไปด้วยวิดีโอ 500 ชิ้นที่มีเอกสารยืนยันตัวตนทั้งหมด 50 ชนิดที่สร้างขึ้นโดยใช้กล้องโทรศัพท์มือถืออย่าง iPhone 5, Samsung Galaxy S3 ที่บันทึกในสภาพแวดล้อม 5 รูปแบบ ได้แก่ ภาพวางบนโต๊ะ บนคีย์บอร์ด และบนมือ ภาพที่ถูกบังบางส่วน รวมถึงภาพที่มีพื้นหลังทีมีวัตถุต่าง ๆ เต็มหน้าจอที่ไม่เกี่ยวข้อง&lt;/p&gt;

&lt;p&gt;ในภาพที่บันทึกได้ จะไม่มีข้อมูลสำคัญ หรือข้อมูลที่ไว้ก็อปปี้สำหรับการทำบัตรปลอมได้ จุดนี้เป็นปัญหาสำคัญที่ไม่มีฐานข้อมูลในลักษณะนี้มาก่อนครับ&lt;/p&gt;

&lt;p&gt;สำหรับผู้อ่านที่ต้องการอ่านเพิ่มเติม สามารถอ่านได้ใน&lt;a href=&quot;https://arxiv.org/abs/1807.05786&quot;&gt;เปเปอร์ MIDV-500: a dataset for identity document analysis and recognition on mobile devices in video stream จากเว็บ arXiv&lt;/a&gt; ครับ และกรณีที่ต้องการดาวน์โหลดฐานข้อมูลไว้ใช้งาน สามารถดาวน์โหลดได้ที่ &lt;a href=&quot;https://github.com/fcakyon/midv500&quot;&gt;Github&lt;/a&gt; หรือดาวน์โหลดผ่านการติดตั้งไลบรารีใน pip ของไพทอน โดยพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install midv500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวไพทอนจะติดตั้งไลบรารี MIDV-500 ไว้ใช้งาน ตัวไลบรารีสามารถแปลงข้อมูล Annotation ของฐานข้อมูล MIDV-500 ให้อยู่ในรูปแบบของ COCO instance segmentation format&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ ฐานข้อมูลได้รับการพัฒนาขึ้นมาให้เป็นเวอร์ชันใหม่ โดยฐานข้อมูลที่สร้างขึ้นมาใหม่มีชื่อว่า &lt;a href=&quot;https://www.spiedigitallibrary.org/conference-proceedings-of-spie/11433/2558438/MIDV-2019--challenges-of-the-modern-mobile-based-document/10.1117/12.2558438.short?SSO=1&quot;&gt;MIDV-2019&lt;/a&gt; ครับ ฐานข้อมูลนี้แก้ปัญหาเรื่อง Projective Distortion และสภาพแสงสว่างที่แตกต่างกันไป&lt;/p&gt;

&lt;h2 id=&quot;เขียนโค้ดกัน&quot;&gt;เขียนโค้ดกัน&lt;/h2&gt;

&lt;p&gt;เราเขียนโค้ดเพื่อที่จะวัดระยะห่างระหว่างตาดำ การเขียนโค้ดจะมีขั้นตอนดังนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;จับภาพใบหน้า (Face detection)&lt;/li&gt;
  &lt;li&gt;Calibrate ระยะการวัด Pixel ต่อ mm โดยแยกส่วนบัตรประชาชนจากภาพ โดยให้ถือบัตรประชาชนให้ชิดริมฝีปากของผู้ที่ต้องการวัดภาพ&lt;/li&gt;
  &lt;li&gt;จับภาพจุดแลนมาร์คบริเวณดวงตา หรือตาดำ (Facial Landmark Detection)&lt;/li&gt;
  &lt;li&gt;วัดระยะห่างระหว่างตาดำ (Interpupillary Distance)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เราเขียนโค้ดใน Google Colab ได้เลยครับ ผู้อ่านสามารถ&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/ipd_measurement.ipynb&quot;&gt;ดาวน์โหลดไฟล์ ipynb&lt;/a&gt; มาทดลองรันบน Google Colab หรืออื่น ๆ ได้ครับ&lt;/p&gt;

&lt;h3 id=&quot;จับภาพใบหน้า-face-detection&quot;&gt;จับภาพใบหน้า (Face Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/face_detection_python.jpg&quot; alt=&quot;Face Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับภาพใบหน้า หรือเรียกอีกอย่างว่า Face Detection คือการหาตำแหน่ง Face Regions of Interest จากภาพ โดยมีหลายเทคนิคที่เราสามารถใช้ได้เลย ตั้งแต่ Viola-Jones ที่พบได้ในคำสั่งบน OpenCV ที่คนโพสกันไปเยอะมาก หรือใช้เทคนิค dlib หรืออื่น ๆ ครับ อย่างไรก็ดี เราต้องพิจารณาความแม่นยำ ข้อดี ข้อเสียของแต่ละเทคนิค&lt;/p&gt;

&lt;p&gt;ในที่นี้ จะใช้เทคนิค FaceBoxes ครับ&lt;/p&gt;

&lt;h3 id=&quot;การจับจุดแลนมาร์คบนใบหน้า-facial-landmark-detection&quot;&gt;การจับจุดแลนมาร์คบนใบหน้า (Facial Landmark Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/dlib_facial_landmark.jpeg&quot; alt=&quot;Facial Landmark Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับจุดแลนมาร์คบนใบหน้า หรือเรียกอีกอย่างว่า Facial Landmark Detection เป็นการจับตำแหน่งอวัยวะบนใบหน้าเพื่อใช้สำหรับการประมวลผลในขั้นตอนต่อไป มีหลายเทคนิคที่ใช้ ตั้งแต่รุ่นเก่าเลยก็เป็น Active Appearance Models, Constrained Local Models หรืออื่น ๆ แต่ถ้าเอาง่ายหน่อยก็เป็น dlib (จากเปเปอร์ Ensemble of Regression Trees) หรือ FaceMesh หรืออื่น ๆ&lt;/p&gt;

&lt;p&gt;ในตัวอย่าง เราใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;h3 id=&quot;calibrate-ระยะการวัด-pixel-และหาระยะห่างระหว่างตาดำ&quot;&gt;Calibrate ระยะการวัด Pixel และหาระยะห่างระหว่างตาดำ&lt;/h3&gt;

&lt;p&gt;เอาล่ะ มาเขียนโค้ดกันดีกว่า เราติดตั้งไลบรารีที่จำเป็นโดยการใช้ pip แต่สำหรับการทำ Calibrate เราใช้ไลบรารี&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenCV&lt;/li&gt;
  &lt;li&gt;Numpy&lt;/li&gt;
  &lt;li&gt;PyTorch&lt;/li&gt;
  &lt;li&gt;iglovikov_helper_functions&lt;/li&gt;
  &lt;li&gt;midv500models&lt;/li&gt;
  &lt;li&gt;imutils&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ติดตั้งเสร็จแล้ว อัพโหลดภาพเข้า Google Colab จากนั้นนำเข้าภาพโดยใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = cv2.imread(&quot;&amp;lt; Image Path &amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab โดยใช้ภาพเราถือบัตรเองที่อัพโหลดเข้าไประบบ จะได้ภาพตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_input.png&quot; alt=&quot;Input Colab Image&quot; /&gt;
ภาพที่จะใช้ทำ Calibrate และหาระยะห่างระหว่างตาดำทั้งสองข้าง&lt;/p&gt;

&lt;p&gt;ต่อมา เรานำภาพผ่านการจับใบหน้าโดยใช้เทคนิค Face Detection และอะไรก็ได้เพื่อหา Face Regions of Interest ครับ โดยการใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = img[..., ::-1]
boxes = face_boxes(img)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมาเรานำ Face Regions of Interest (ที่อยู่ในตัวแปร boxes) ไปประยุกต์ใช้ต่อสำหรับการทำ Calibrate เรานำเข้าไลบรารีได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import albumentations as albu
import torch

from iglovikov_helper_functions.utils.image_utils import load_rgb, pad, unpad
from iglovikov_helper_functions.dl.pytorch.utils import tensor_from_rgb_image

from midv500models.pre_trained_models import create_model
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ดาวน์โหลดโมเดล U-NET มาใช้งาน โดยใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = create_model(&quot;Unet_resnet34_2020-05-19&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;กำหนดตัวโมเดลสำหรับการจับภาพที่ไม่ได้เทรนใหม่ (Evaluation model) และนำภาพที่เราจับภาพใบหน้ามาแล้วที่เป็นตำแหน่งแรกมาแยกส่วนบัตรประชาชน เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model.eval()
boxes = [boxes[0]]
size_box = len(boxes)
box = boxes[0]

[x1, y1, x2, y2] = box[:4]
x1 = int(x1)
y1 = int(y1)
x2 = int(x2)
y2 = int(y2)

# Segment Image
image = img[y1:y2,x1:x2].copy()
transform = albu.Compose([albu.Normalize(p=1)], p=1)
padded_image, pads = pad(image, factor=32, border=cv2.BORDER_CONSTANT)

# Inference
x = transform(image=padded_image)[&quot;image&quot;]
x = torch.unsqueeze(tensor_from_rgb_image(x), 0)
with torch.no_grad():
    prediction = model(x)[0][0]

# Postprocessing
mask = (prediction &amp;gt; 0).cpu().numpy().astype(np.uint8)
mask = unpad(mask, pads)
mask = mask * 255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราแยกส่วนบัตรประชาชนออกมาแล้วในรูปแบบตัวแปร mask ในตัวโค้ดจะออกมาเป็นอาเรย์ที่มีขนาดเท่าภาพต้นฉบับที่มีตัวแปรระหว่าง 0 กับ 1 แต่ภาพขาวดำปกติมันมีตั้งแต่ 0-255 (8-bit) เรานำ 255 มาคูณตามด้านบน&lt;/p&gt;

&lt;p&gt;หลังจากแยกส่วนแล้ว เราต้องการหาความยาวด้านยาวเป็นจำนวน Pixel เราจำเป็นต้องหา Contour ของภาพ โดยใช้คำสั่ง cv2.findContours แล้วเรียง Contour จากบนลงล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Contour
contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
(cnts, boundingBoxes) = contour.sort_contours(contours, method=&quot;top-to-bottom&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเรียงมาเรียบร้อยแล้ว เราหาความยาวด้านยาวของบัตรประชาชนที่แยกมาได้ โดยใช้คำสั่ง cv2.boundingRect&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# find boundingRect
target_cnt = cnts[0]
x,y,w,h = cv2.boundingRect(target_cnt)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้ความยาวมาเรียบร้อย เราแปลงให้อยู่ในรูปอัตราส่วนจำนวน pixel ต่อ mm ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Card size in pixels (compare to 86mm on long size)
distance = w
distancepermm = distance / 86
print(f&quot;card size (pixel) = { distance } compare to (mm) = 85 mm =&amp;gt; distance { distancepermm } pixels/mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab เราจะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_calibrate.png&quot; alt=&quot;Calibrated Colab Image&quot; /&gt;
ภาพหลังการทำ Calibrate&lt;/p&gt;

&lt;p&gt;ต่อมา ในขั้นตอนต่อไป เป็นการหาตำแหน่งอวัยวะบนใบหน้า (Facial Landmark Detection) เราเอาภาพเดิมที่ผ่านการจับภาพใบหน้า (Face Detection) มาใช้งาน ได้ตามโค้ดด้านล่างนี้ที่ใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param_lst, roi_box_lst = tddfa(img, boxes)
ver_lst = tddfa.recon_vers(param_lst, roi_box_lst, dense_flag=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้จุดบนใบหน้า 68 จุดออกมา แต่อาเรย์ของ ver_lst อยู่ในรูปแบบอาเรย์ที่มี Shape = [3, 68] เราจำเป็นต้องแปลงให้อยู่ในรูปแบบ Shape = [68, 3] เสียก่อน ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = first_landmark[0,:].reshape(-1, 1)
y = first_landmark[1,:].reshape(-1, 1)
landmark = np.concatenate([x,y], axis = 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้ว เราจำเป็นต้องหาตำแหน่งตาดำตรงกลางเพื่อหาระยะห่างระหว่างตาดำ แต่ก่อนอื่น เรามาหาตำแหน่งรอบตาดำ และตาขาวก่อน จากภาพนี้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/09/68-facial-landmarks.jpg&quot; alt=&quot;Facial Landmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;จุดบนอวัยวะบนใบหน้าทั้งหมด 68 จุด&lt;/p&gt;

&lt;p&gt;เรานำจุดบนอวัยวะบนใบหน้าตำแหน่งที่ 37-42 สำหรับตาขวา และตำแหน่งที่ 43-48 สำหรับตาซ้าย เพื่อนำมาหาตำแหน่งตาดำตรงกลางสำหรับการหาระยะห่างระหว่างตาดำ ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;righteye = landmark[36:42]
rightiris = np.array([np.mean(righteye[:, 0]), np.mean(righteye[:, 1])])
lefteye = landmark[42:48]
leftiris = np.array([np.mean(lefteye[:, 0]), np.mean(lefteye[:, 1])])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เราหาระยะห่างระหว่างตาดำทั้งสองข้างได้โดยนำค่า pixel ของภาพต่อระยะห่างที่เป็นหน่วย mm ที่ได้จากการทำ Calibrate มาใช้งานตามโค้ดด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find IPD
interpupillary_distance = 0.0
for i in range(2):
    interpupillary_distance += (rightiris[i] - leftiris[i])**2
interpupillary_distance = np.sqrt(interpupillary_distance)
interpupillary_distance_mm = interpupillary_distance / distancepermm
print(f&quot;Interpupillary Distance = { interpupillary_distance } which equals = { interpupillary_distance_mm } mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทดลองเริ่มต้นการทำงาน จะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_result.png&quot; alt=&quot;Interpupillary Distance Result&quot; /&gt;
ผลลัพธ์ที่ได้&lt;/p&gt;

&lt;p&gt;ฟังดูแล้วไม่ยากเกินไปใช่ไหมล่ะครับ สำหรับผู้อ่านวิธีการวัดระยะห่างระหว่างตาดำ (Interpupillary Distance) วิธีนี้เป็นวิธีหนึ่งแค่นั้นครับ&lt;/p&gt;

&lt;p&gt;และอีกอย่าง เทคนิคนี้ยังไม่ได้ทดสอบความแม่นยำกับคนอื่น ๆ (ยกเว้นผู้เขียนเอง) เลยอาจจะต้องเอาไปทดสอบก่อนที่จะนำไปใช้งานบน Production จริงครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Mouth Opening" /><category term="Iris" /><category term="Interpupillary Distance" /><category term="Measurement" /><category term="Programming" /><category term="Machine Learning" /><category term="Computer Vision" /><category term="Segmentation" /><category term="Face Detection" /><category term="Calibration" /><category term="U-NET" /><category term="Deep Learning" /><category term="3DDFA_V2" /><category term="FaceBoxes" /><category term="Face Detection" /><category term="Landmark Detection" /><category term="Artificial Intelligence" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ตาดำ" /><category term="การวัด" /><category term="คอมพิวเตอร์วิทัศน์" /><summary type="html">บทความนี้แนะนำวิธีการวัดระยะห่างระหว่างตาดำโดยใช้ภาษา Python จากภาพดิจิทัลครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token</title><link href="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/" rel="alternate" type="text/html" title="ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token" /><published>2021-12-01T00:30:00+07:00</published><updated>2021-12-01T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/01/implement-httponly-cookie-token-nodejs-express</id><content type="html" xml:base="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/">&lt;p&gt;เดิมทีเวลาที่เราใช้งานเพื่อเข้าสู่ระบบ เราจะเขียนโค้ดเพื่อขอ Access Token จากเซิร์ฟเวอร์แล้วนำมาเก็บไว้บน Client เพื่อนำมาใช้งานระบบที่จำเป็น โดยใน&lt;a href=&quot;https://www.howtographql.com/react-apollo/5-authentication/&quot;&gt;บทความบนเว็บที่เกี่ยวกับการทำระบบ Authentication โดยใช้ไลบรารี Apollo GraphQL&lt;/a&gt; นั้น เราจะเก็บข้อมูล Access Token ที่สร้างขึ้นไว้บน LocalStorage เพื่อนำมาใช้งานต่อครับ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การเก็บข้อมูลไว้ในนี้ก็มีปัญหาเรื่องความปลอดภัย ในบทความนี้จะแนะนำวิธีการเก็บข้อมูล Access Token ที่ปลอดภัยกว่าการเก็บบน LocalStorage ครับ&lt;/p&gt;

&lt;h2 id=&quot;localstorage&quot;&gt;LocalStorage&lt;/h2&gt;

&lt;p&gt;ก่อนอื่น เรามาพูดถึง LocalStorage ก่อน ตัว LocalStorage (หรือเรียกว่า window.localStorage) เป็นส่วนหนึ่งของ HTML5 Web Storage ที่ทำหน้าที่เก็บข้อมูลใส่ไว้บนเว็บเบราวเซอร์ทางฝั่ง Client ที่ข้อมูลยังคงอยู่ ถึงแม้ว่าเราจะปิดหน้าเว็บเบราวเซอร์นั้น ๆ ออกไป หรือข้อมูลหมดอายุตามที่เรากำหนดไว้เอง&lt;/p&gt;

&lt;p&gt;การใช้งาน LocalStorage ทำได้โดยการเก็บข้อมูลตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.setItem('token', &amp;lt; Access Token ที่ได้ &amp;gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วเราสามารถเรียกได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let token = localStorage.getItem('token');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้นข้อมูล Access Token ที่เก็บไว้ในเว็บเบราวเซอร์ก็จะคืนค่าอยู่ในตัวแปร token ครับ ฟังดูแล้วง่ายกว่าที่ดีคิดไว้ เพราะใช้คำสั่งตามที่เขียนไว้ข้างบนนี้ ข้อมูลก็ออกมาได้แล้วครับ อย่างไรก็ดี การเก็บข้อมูลไว้ใน LocalStorage มีข้อเสีย เนื่องมาจาก&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ข้อมูลที่เก็บ สามารถเก็บในรูปแบบ String เท่านั้น&lt;/li&gt;
  &lt;li&gt;มีขนาดที่จำกัดเพียงแค่ 5MB (แต่ข้อมูลข้างบนไม่ถึง 5MB :P)&lt;/li&gt;
  &lt;li&gt;มีปัญหาเรื่องความปลอดภัย เนื่องมาจากอ่านข้อมูลได้ง่ายเพียงใช้คำสั่งเดียวตามที่กล่าวไว้ข้างบน และสามารถดึกข้อมูลได้โดย &lt;a href=&quot;https://michael-coates.blogspot.com/2010/07/html5-local-storage-and-xss.html&quot;&gt;Cross site scripting (XSS)&lt;/a&gt; ครับ&lt;/li&gt;
  &lt;li&gt;อ่านรายละเอียดเพิ่มเติมได้ใน&lt;a href=&quot;https://dev.to/rdegges/please-stop-using-local-storage-1i04&quot;&gt;หน้าเว็บ dev.to ที่มีคนหนึ่งได้เขียนไว้&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ดังนั้นแล้ว ข้อมูลที่เก็บไว้ใน LocalStorage ไม่ควรจะเก็บข้อมูลที่เป็นความลับครับ แล้วเราจะเก็บข้อมูลไว้ที่ไหนดีล่ะ?&lt;/p&gt;

&lt;h2 id=&quot;httponly-cookies&quot;&gt;HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;HTTPOnly Cookies เป็นการตั้งค่าอันหนึ่งที่พบได้ระหว่าการตั้งค่า Set-Cookie HTTP Response Header ที่พบได้ตั้งแต่ Internet Explorer 6 SP1 (เก่ามากและ) โดยข้อมูลนี้เอามาจากบทความใน&lt;a href=&quot;https://owasp.org/www-community/HttpOnly&quot;&gt;หน้าเว็บมูลนิธิ OWASP&lt;/a&gt; ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลที่เป็นความลับ หรือข้อมูลที่ Sensitive มากกว่าปกติ ยกตัวอย่างเช่นข้อมูล Access Token, User ID, Session ID, ข้อมูลบัตรเครดิต และอื่น ๆ ที่เราต้องการให้แชร์บน Facebook แบบ Public นั้น เราเก็บช้อมูลใน HTTPOnly Cookies ที่ทำได้ตามขั้นตอนด้านล่างนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เมื่อผู้ใช้เข้าสู่ระบบ เซิร์ฟเวอร์จะสร้างข้อมูล Session ที่จำเป็นขึ้นมาสำหรับการใช้งาน&lt;/li&gt;
  &lt;li&gt;นำข้อมูลที่สร้างขึ้นเก็บอยู่ในรูปแบบ Cookie โดยกำหนดค่าคุกกี้ให้เป็น HTTPOnly เท่านั้น&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ไลบรารีที่รองรับ HTTPOnly Cookies มีหลากหลายไลบรารีมาก ผู้อ่านสามารถหาเพิ่มเติมได้ในอินเตอร์เน็ต แต่ในตัวอย่างนี้ เราจะใช้ไลบรารีที่นิยมอันหนึ่งที่มีชื่อว่า &lt;a href=&quot;https://expressjs.com/&quot;&gt;Express&lt;/a&gt; ที่อยู่ในรูปแบบภาษา JavaScript ที่ทำงานบน Node.js ครับ&lt;/p&gt;

&lt;p&gt;ตัวอย่างของการสร้าง HTTPOnly Cookies ทำได้ตามด้านล่างนี้ครับ แต่ก่อนอื่น เราต้องติดตั้งไลบรารีเหล่านี้ก่อนครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add express dayjs cookie-parser jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อติดตั้งเสร็จแล้ว เราพิมพ์ส่วนนี้เพิ่มเติมลงไปใน package.json&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  [...]
  &quot;type&quot;: &quot;module&quot;,
  [...]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เพื่อให้ใช้งานตามตัวอย่างด้านล่างนี้ได้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import http from 'http';
import express from 'express';
import dayjs from 'dayjs';
import cookieParser from &quot;cookie-parser&quot;;
import jwt from 'jsonwebtoken';

const app = express();
const httpServer = http.createServer(app);

[...]

app.use(cookieParser());

[...]

app.post('/login', (req, res, next) =&amp;gt; {

  [...]

  let token = jwt.sign(payload, jwt_secret, { expiresIn: jwt_expire });

  res.cookie(&quot;authorization&quot;, token, {
      secure: true,
      httpOnly: true,
      expires: dayjs().add(1, &quot;days&quot;).toDate(),
      sameSite: 'Strict'
  });

  [...]

});

[...]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อดูตัวอย่างจากข้างบนนี้แล้ว ดูตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(cookieParser());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นการเกิดใช้งานตัว cookie-parser Middleware ที่เป็นส่วนหนึ่งของไลบรารี Express ที่อนุญาตให้เราเรียกใช้งาน Cookie header เพื่อดึงข้อมูล HTTPOnly Cookies โดยพิมพ์ว่า req.cookies ครับ&lt;/p&gt;

&lt;p&gt;ในหลายบรรทัดต่อมา ตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie(&quot;token&quot;, token, 
    secure: true,
    httpOnly: true,
    expires: dayjs().add(1, &quot;days&quot;).toDate(),
    sameSite: 'Strict'
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นคำสั่งที่เรากำหนดค่าอะไรก็ตามลงไปใน Cookie ที่เราได้กำหนดไว้ คือ เรากำหนดค่า Access Token ลงไปใน Cookie token ครับ ส่วนการตั้งค่าที่อยู่ในปีกกานั้นเป็นการตั้งค่า Cookie นี้ให้&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;secure เป็นการตั้งค่าให้ใช้งานผ่าน HTTPS เท่านั้น&lt;/li&gt;
  &lt;li&gt;httpOnly เป็นการตั้งค่าให้ cookie ตัวนี้เรียกใช้งานโดยเว็บเซิร์ฟเวอร์ได้เท่านั้น&lt;/li&gt;
  &lt;li&gt;expires เป็นการตั้งค่าระยะเวลาหมดอายุ ตามคำสั่งที่เขียนข้างบนกำหนดให้มีอายุ 1 วัน&lt;/li&gt;
  &lt;li&gt;sameSite ตั้งค่าให้เพิ่ม SameSite ใน Set-Cookie HTTP Header มีด้วยกันสองแบบได้แก่ Strict ที่ผ่านทางเว็บไซต์เราเท่านั้น หรือ Lax ที่ส่ง Cookie ผ่านเว็บไซต์อื่นได้ ผ่าน HTTP Get บน Address Bar (เช่นการกด Link)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ส่วนการตั้งค่าเพิ่มเติมที่เราไม่ได้กำหนดค่าไว้ มีได้แก่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;domain กำหนดโดเมนเนม ในที่นี้ให้โดเมนเนมเดียวกันกับ app&lt;/li&gt;
  &lt;li&gt;encode เป็นฟังก์ชันที่กำหนด encoding
เป็นต้น โดยการตั้งต่าเพิ่มเติมนี้ ผู้อ่านสามารถเข้าไปดูได้ใน &lt;a href=&quot;https://expressjs.com/en/api.html&quot;&gt;Reference ของ Express&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เมื่อเราเรียกใช้งานผ่านคำสั่งอย่าง fetch, XMLHttpRequest หรืออื่น ๆ เราดู HTTPOnly Cookies ได้ที่หน้า Developer Tools -&amp;gt; Application -&amp;gt; Storage -&amp;gt; Cookies -&amp;gt; ที่อยู่เว็บไซต์ -&amp;gt; เราจะพบ HTTPOnly Cookies ที่เราได้สร้างขึ้นครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot; alt=&quot;HTTPOnly Cookies บน Developer Tools&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPOnly Cookies บน Developer Tools (&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot;&gt;ดูรูปเต็ม&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ดูตรง Authorization เราจะพบว่า Cookie ที่สร้างนี้อันนี้เป็น HTTPOnly Cookies ครับ แล้วเวลาที่ใช้งานจริง เราจะเรียกใช้งานอย่างไรดีล่ะ?&lt;/p&gt;

&lt;p&gt;เราเรียกใช้งานได้โดยผ่านการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/isloggedin', (req, res, next) =&amp;gt; {
  
  [...]

  let token = req.cookies.authorization;

  [...]

});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง req.cookies.authorization อันนี้แหละ เป็นการเรียกใช้งาน HTTPOnly Cookies ที่เราสร้างชึ้นครับ อย่างไรก็ดี กรณีที่เราใช้งานผ่าน Apollo Server GraphQL เรายังเรียก HTTPOnly Cookies ได้อยู่ไหม คำตอบคือ ทำได้สบายมาก เพียงแต่เราต้องมาพิมพ์คำสั่งใน context ที่สร้างขึ้น&lt;/p&gt;

&lt;p&gt;เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ApolloServer } from 'apollo-server-express';
import { ApolloServerPluginDrainHttpServer } from 'apollo-server-core';

[...]

const apollo_server = new ApolloServer({ 
  typeDefs,
  resolvers,
  plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
  context: ({ req }) =&amp;gt; {
    let token = req.cookies.authorization || '';
    return {
      token
    };
  }
});

[...]

apollo_server.applyMiddleware({ &quot;app&quot;: express_app });

[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง context ที่อยู่ใน new ApolloServer({ … }) อันนี้แหละมีส่วนที่เราเรียกใช้งาน HTTPOnly Cookies ครับ ส่วนไลบรารีอื่น ผู้อ่านสามารถหาอ่านได้ในอินเตอร์เน็ตเพิ่มเติมครับ&lt;/p&gt;

&lt;h2 id=&quot;ประโยชน์การใช้-httponly-cookies&quot;&gt;ประโยชน์การใช้ HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;ประโยชน์ของการใช้งาน HTTPOnly Cookies ตามที่เขียนในเว็บ &lt;a href=&quot;https://blog.codinghorror.com/protecting-your-cookies-httponly/&quot;&gt;CodingHorror&lt;/a&gt; หรืออื่น ๆ ได้แก่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTPOnly Cookies จำกัดให้เรียกใช้งานผ่านเว็บเซิร์ฟเวอร์เท่านั้น เราจะใช้งานผ่าน document.cookie ไม่ได้&lt;/li&gt;
  &lt;li&gt;ป้องกันการเกิด Cross-site Scripting (XSS) ดังนั้นแล้ว เวลาที่เรียกใช้งาน fetch, XMLHttpRequest หรืออื่น ๆ จะกระทำได้โดยผ่านโดเมนเดียวกันกับเว็บเซิร์ฟเวอร์เท่านั้น&lt;/li&gt;
  &lt;li&gt;ตามที่เขียนข้างบนนี้มีเขียนให้ใช้ Same-site Cookie ที่ใช้งานได้เฉพาะเว็บเราเท่านั้น ทำให้เรียกใช้ผ่านเว็บอื่นไม่ได้ ส่วนนี้จะป้องกัน Cross site request forgery (CSRF) ครับ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;และอื่น ๆ&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;จากตัวอย่างจะพบว่าเราใช้งาน HTTPOnly Cookies โดยใช้งานบน Node.js ที่ใช้ไลบรารี Express ได้เพียงไม่กี่คำสั่งเท่านั้น เมื่อใช้งานแล้วทำให้เว็บไซต์ของเราปลอดภัยขึ้นมากกว่าเดิมครับ อย่างไรก็ดี อันนี้เป็นส่วนหนึ่งที่ทำให้เว็บของเราปลอดภัยตรับ จะต้องพิจารณาการเขียนโค้ดส่วนอื่นร่วมด้วยว่ามีช่องโหว่หรือไม่ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="HTTPOnly" /><category term="Developer" /><category term="HTTP" /><category term="Cookies" /><category term="Secure" /><category term="Security" /><category term="Token" /><category term="JWT" /><category term="JavaScript" /><category term="Coding" /><category term="GraphQL" /><category term="API" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ความปลอดภัย" /><category term="โทเค็น" /><summary type="html">บทความนี้แนะนำวิธีการเก็บ Access Token ที่ปลอดภัยกว่าการเก็บใน LocalStorage ด้วย HTTPOnly Cookies บน Node.js</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">สรุปบางส่วนจากสเปช How to Become a Web 3 Developer</title><link href="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/" rel="alternate" type="text/html" title="สรุปบางส่วนจากสเปช How to Become a Web 3 Developer" /><published>2021-11-26T00:30:00+07:00</published><updated>2021-11-26T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/11/26/how-to-be-web3-developer</id><content type="html" xml:base="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/">&lt;p&gt;เมื่อวันก่อนเปิดทวิตเตอร์เจอสเปชของทางเว็บ &lt;a href=&quot;https://hashnode.com&quot;&gt;Hashnode&lt;/a&gt; ที่มีหัวข้อว่า How to Become a Web 3 Developer หรือแปลเป็นภาษาไทยว่าวิธีการเป็นนักพัฒนาเว็บ 3.0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hashnode เป็นเว็บที่อนุญาตให้คนเขัยนบทความที่เกี่ยวข้องกับการเขัยนโปรแกรมได้ แถมเราสามารถลิ้งค์โดเมนเนมที่เราจดไว้แล้วกับหน้าบล็อกนี้ได้เลย 
จุดนี้นึกถึงเว็บ Medium ครับ แต่อันนี้สำหรับนักพัฒนาโปรแกรม ใครสนใจเข้าไปสมัครสมาชิกและเขียนบทความได้ฟรี&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ก่อนที่เราจะไปถึงสรุป เรามาพูดถึงเว็บ 3.0&lt;/p&gt;

&lt;h2 id=&quot;web-3&quot;&gt;Web 3&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/cryptocurrency.jpg&quot; alt=&quot;Cryptocurrency&quot; /&gt;
เงินคริปโตเป็นส่วนหนึ่งของ Blockchain ที่เกี่ยวข้องกับ Web 3.0&lt;/p&gt;

&lt;p&gt;Web 3 หรือเรียกว่า Web 3.0 มีคำนิยามตามที่ Tim Berners-Lee ให้ไว้ว่ามันจะเป็น The next generation of internet ที่ตัวเว็บจะกลายเป็น Semantic Web ที่มีความฉลาดมากขึ้น ทำงานได้อัตโนมัติ ทำได้งานด้าน AI, Machine Learning, Blockchain และเทคโนโลยีอัจฉริยะอื่น ทำงานได้ดีมากขึ้นกว่าเดิม&lt;/p&gt;

&lt;p&gt;นอกจากนี้ ทาง Berners-Lee ให้นิยามไว้เพิ่มเติมว่า Web 3.0 จะเป็นเครือข่ายที่อนุญาตให้ผู้อ่านสามารถสร้างคอนเท้นต์ได้โดยไม่จำเป็นต้องพึ่งทางผู้ให้บริการ ทางรัฐ หรืออื่น ๆ ก็คือจะมีความเป็น Decentralize มากขึ้นกว่าเดิม สิ่งนี้เหมือนกับเทคโนโลยีของ Blockchain ทางด้าน Cryptocurrency ตรับ&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถอ่านเพิ่มเติมได้ที่บทความในเว็บ&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2020/01/06/what-is-web-3-0/?sh=3831244258df&quot;&gt;Forbes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://slate.com/technology/2021/11/web3-explained-crypto-nfts-bored-apes.html&quot;&gt;Slate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;รวมถึงใน&lt;a href=&quot;https://www.youtube.com/results?search_query=web+3.0&quot;&gt;ยูทูป&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;และอื่นๆ ครับ&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงที่สรุปจากสเปชบางส่วนครับ&lt;/p&gt;

&lt;h2 id=&quot;สรุปจากสเปช&quot;&gt;สรุปจากสเปช&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/web3_space.jpg&quot; alt=&quot;Web 3.0 Space&quot; /&gt;&lt;/p&gt;

&lt;p&gt;สเปชนี้จะเป็นสเปชที่เปิดให้คนกดยกมือเข้าไปถามได้ อันนี้นึกถึง &lt;a href=&quot;https://nickuntitled.com/2021/02/18/talk-about-clubhouse/&quot;&gt;Clubhouse&lt;/a&gt; ตรับ เพียงแต่อันนี้มีบนทวิตเตอร์มาระยะหนึ่งแล้ว และไม่เป็น&lt;a href=&quot;https://twitter.com/search?q=%23สเปซtoxic&amp;amp;src=typed_query&amp;amp;f=top&quot;&gt;สเปช Toxic&lt;/a&gt; ครับ โดยเราจะสรุปบางส่วนได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;นักพัฒนา Web 3.0 ไม่จำเป็นต้องเชี่ยวชาญ Web 2.0 มาก่อน แต่ถ้าเคยทำเว็บมาก่อนอยู่แล้วจะทำให้เรียนรู้การทำ Web 3.0 ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;การทำเว็บก็ต้องมีความรู้ทางด้านการเขียนโปรแกรม ในสเปชจะกล่าวถึ้งความรู้ทางด้าน HTML, CSS, JavaScript, Object-oriented Programming (OOP) และอื่น ๆ&lt;/li&gt;
  &lt;li&gt;นอกจากความรู้ทางการเขียนโปรแกรมแล้ว ความรู้ทางด้าน Blockchain, Solana, Ethereum, Polygon รวมถึงหลักการ NFT, Smart Contract, Decentralization, Layer 2 เป็นต้น &lt;a href=&quot;https://www.youtube.com/watch?v=qOVAbKKSH10&quot;&gt;ลิ้งยูทูปอันนี้&lt;/a&gt;น่าจะอธิบายเรื่องที่กล่าวมาได้ในระดับหนึ่งครับ&lt;/li&gt;
  &lt;li&gt;อีกอย่าง เรียนรู้การใช้ไลบรารีที่เกี่ยวข้องกับ Web 3.0 ครับ โดยหยิบไลบรารี Open Source มาฝึกได้เลย&lt;/li&gt;
  &lt;li&gt;พอเรีัยนรู้ตามข้างบนไประยะหนึ่งแล้ว การสร้างโปรเจคขึ้นมาเป็นวิธีทำให้เราเรียนรู้ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;เมื่อสร้างโปรเจคแล้ว นำมาเผยแพร่บนอินเตอร์เน็ต โซเชียล รวมถึงเขียนบล็อก บทความบนแพลตฟอร์มอะไรก็ได้เพื่อเผยแพร่โปรเจค ให้ความรู้ (ทางนั้นแนะนำ Hashnode แหม ก็ใครเป็นเจ้าของสเปช) และโพสลงโซเชียลเพื่อทำให้คนรู้จักเรา สร้างคอนเนคชั่นได้ (ที่ไม่ใช่ระบบอุปถัมภ์)&lt;/li&gt;
  &lt;li&gt;สร้าง Resume, CV และมองหาบริษัทที่เปิดรับสมัครงาน&lt;/li&gt;
  &lt;li&gt;ระยะเวลาเริ่มต้นจนทำเว็บ 3.0 เป็น อันนี้ไม่แน่นอน ขึ้นกับคน ถ้ายังไม่มีพื้นฐานอะไรเลย ก็จะช้าหน่อย&lt;/li&gt;
  &lt;li&gt;มี Passion อยากจะเรียนรู้ ใช้เวลาฝึกสม่ำเสมอ สนุกกับมัน&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;สรุปได้คร่าว ๆ ประมาณนี้ครับ ดูจากแต่ละข้อแล้วก็คล้าย ๆ กันกับวิธีการเริ่มการเขียนโปรแกรม หรือวิธีการเริ่มสกิลใหม่สำหรับคนที่ทำงานหนึ่งแล้วต้องการเปลี่ยนสาย เช่นหมอไปเป็นนักบิน เป็นต้น ผู้อ่านสามารถนำสิ่งที่สรุปไปทำตามได้ครับ&lt;/p&gt;

&lt;p&gt;แต่ถ้าผู้อ่านต้องการข้อมูลเพิ่มเติม ผู้อ่านสามารถหาได้ในอินเตอร์เน็ต ยูทูป หนังสือ และอื่น ๆ ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="Web 3.0" /><category term="Developer" /><category term="Programmer" /><category term="Job" /><category term="Career" /><category term="Reskill" /><category term="Hashnode" /><category term="เว็บ" /><category term="เว็บ 3.0" /><category term="เขียนโปรแกรม" /><category term="โปรแกรมเมอร์" /><category term="อาชีพ" /><category term="รีสกิล" /><category term="นักพัฒนาเว็บ" /><summary type="html">เมื่อวันก่อนมีการจัดสเปชของ Hashnode ที่กล่าวถึง How to be Web 3.0 Developer ในบทความนี้สรุปบางส่วนครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>