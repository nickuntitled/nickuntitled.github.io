<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://nickuntitled.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nickuntitled.com/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-03-16T01:03:09+07:00</updated><id>https://nickuntitled.com/feed.xml</id><title type="html">Nick Untitled</title><subtitle>A Nick&apos;s Journal on my Life</subtitle><author><name>Nick Untitled</name><email>contact@nickuntitled.com</email></author><entry><title type="html">Pyodide - แนะนำการเริ่มต้นใช้งาน และการพล็อตกราฟเพื่อแสดงบนหน้าเว็บ</title><link href="https://nickuntitled.com/2022/03/16/running_python_website_draw_graph/" rel="alternate" type="text/html" title="Pyodide - แนะนำการเริ่มต้นใช้งาน และการพล็อตกราฟเพื่อแสดงบนหน้าเว็บ" /><published>2022-03-16T00:00:00+07:00</published><updated>2022-03-16T00:00:00+07:00</updated><id>https://nickuntitled.com/2022/03/16/pyodide-matplotlib-img-element</id><content type="html" xml:base="https://nickuntitled.com/2022/03/16/running_python_website_draw_graph/">&lt;p&gt;Python เป็นภาษาคอมพิวเตอร์ภาษาหนึ่งที่ได้รับความนิยมภาษาหนึ่ง โดยภาษานี้เป็นภาษา General-purpose ท่เน้นการอ่านตัวโค้ดได้ง่าย รวมถึงง่ายต่อการเรียนรู้ ภาษานี้ปกติจะไม่ได้ออกแบบเพื่อการทำงานบนหน้าเว็บไซต์แบบจาวาสคริป อย่างไรก็ดีมีทีมงานกลุ่มหนึ่งใน Mozilla ที่พัฒนาตึวโค้ด CPython ให้ทำงานอยู่บน Webassembly ที่ออกแบบมาให้รันตัวโค้ดที่ได้รับการคอมไพล์บนหน้าเว็บไซต์&lt;/p&gt;

&lt;p&gt;เมื่อตัวโค้ดได้รับการคอมไพล์ให้อยู่บน Webassembly แล้ว ตัวโค้ดที่เขียนในรูปแบบภาษา Python จะเข้าถึง Web APIs ทั้งหลายแหล่ที่อยู่บนเว็บเบราวเซอร์ได้นั่นเอง&lt;/p&gt;

&lt;p&gt;ตัว Pyodide นี้นอกจากคอมไพล์ตัว Python แล้ว ยังรวบรวมไลบรารี Numpy, Matplotlib, Pandas, scikit-learn และอื่น ๆ อีกหลายสิบไลบรารี แถมยังรองรับการติดตั้งไลบรารี Python เพิ่มเติมได้โดยการติดตั้งผ่าน micropip&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มต้นการใช้งาน-pyodide&quot;&gt;การเริ่มต้นการใช้งาน Pyodide&lt;/h2&gt;

&lt;p&gt;เราเริ่มต้นการใช้งานได้โดยการนำเข้าไลบรารี Pyodide ผ่านการแนบลิ้งค์ CDN ลงบนหน้า HTML ผ่านแท็ก script&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;script src = &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเรียกผ่านการใช้คำสั่ง import แบบ dynamic โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await import(&apos;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อนำเข้าไลบรารีนี้แล้ว เราเริ่มต้นการทำงานของ Pyodide ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let pyodide = await loadPyodide({
      indexURL : &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/&quot;
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;การโหลดไลบรารี-และติดตั้งไลบรารีเพิ่มเติม&quot;&gt;การโหลดไลบรารี และติดตั้งไลบรารีเพิ่มเติม&lt;/h2&gt;

&lt;p&gt;เมื่อเริ่มต้นการทำงานแล้ว เราสามารถโหลดไลบรารีที่ต้องการได้โดยคำสั่ง loadPackage ตามด้วยไลบรารีที่ต้องการโดยเขัยนตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await pyodide.loadPackage(&quot;&amp;lt; ชื่อไลบรารี &amp;gt;&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ส่วนกรณีที่ต้องติดตั้งไลบรารีเพิ่มเติม เราสามารถติดตั้งได้โดยการใช้ micropip ซึ่งทำได้โดยการโหลดไบรารีผ่านการใช้ loadPackage และการเรียกใช้คำสั่ง micropip.install ผ่านการใช้คำสั่ง runPythonAsync ที่ให้เราเริ่มต้นการทำงานโค้ดไพทอนแบบ Asynchronous ได้ครับ&lt;/p&gt;

&lt;p&gt;เราเขียนโค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  await pyodide.loadPackage(&quot;micropip&quot;);
  await pyodide.runPythonAsync(`
      import micropip
      micropip.install(&apos;&amp;lt; ไลบรารีที่ต้องการ ตัวอย่างเช่น seaborn &amp;gt;&apos;)
  `);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;การพล็อตกราฟด้วย-matplotlib--seaborn-แล้วแสดงบนแท็ก-img&quot;&gt;การพล็อตกราฟด้วย Matplotlib + Seaborn แล้วแสดงบนแท็ก img&lt;/h2&gt;

&lt;p&gt;เราสามารถพล็อตกราฟได้โดยการใช้ไลบรารี Matplotlib และไลบรารีที่พัฒนาต่อยอดจากไลบรารีก่อนหน้าอย่าง Seaborn ที่ทำให้การพล็อตกราฟเป็นไปได้โดยง่ายขึ้น&lt;/p&gt;

&lt;p&gt;ปกติเวลาที่เราพล็อตกราฟเสร็จแล้ว เราจะแสดงบนหน้าต่างใหม่ หรือแสดงบนหน้าเว็บใน Jupter Notebook ได้โดยการพิมพ์คำสั่งผ่านการเรียก pyplot ที่อยู่ใน matplotlib ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pyplot.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเซฟเป็นไฟล์ .png หรืออะไรแนวนี้ได้โดยการใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pyplot.savefig(&quot;&amp;lt; ที่อยู่ไฟล์ &amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;อย่างไรก็ดี เมื่อเราเขียนโค้ดแล้วนำมาทำงานบนหน้าเว็บไซต์ผ่านการใช้งาน Pyodide แล้ว มันก็จะไม่สามารถแสดงหน้าต่างใหม่ได้ หรือจะเซฟแบบนั้นโดยตรงก็ไม่น่าจะได้ ดังนั้นแล้วมีวิธีหนึ่งที่นำผลที่ได้จากการพล็อตกราฟมาแสดงบนหน้าเว็บไซต์ได้โดยการแปลงตัวกราฟที่พล็อตให้อยู่ในรูป base64 ที่สามารถเพิ่มลงไปใน src attribute ได้เลย&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ เรายังนำ base64 ไปแปลงให้เป็นรูปแบบ blob เพื่อนำไปอัพโหลด หรือเซฟไฟล์สำหรับการนำไปใช้งานต่อได้อีก แต่ในบทความนี้ขอแนะนำถึงการพล็อต แล้วส่งออกให้อยู่ในรูปแบบ base64 เพื่อนำมาแสดงบนแท็ก img ครับ&lt;/p&gt;

&lt;p&gt;เราทำได้ในขั้นตอนตัวอย่างตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h3 id=&quot;1-เริ่มต้น-pyodide--เรียกใช้ไลบรารี&quot;&gt;1. เริ่มต้น Pyodide + เรียกใช้ไลบรารี&lt;/h3&gt;

&lt;p&gt;เราเริ่มต้นการทำงานของ Pyodide และเรียกใช้งานไลบรารี numpy, matplotlib, seaborn (ที่ติดตั้งโดย micropip) ได้ตามหัวข้อก่อนหน้าครับ โดยเราเขียนโค้ดออกมาเป็น&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function importLib()
  {
      await import(&apos;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/pyodide.js&apos;);

      let pyodide = await loadPyodide({
          indexURL : &quot;https://cdn.jsdelivr.net/pyodide/v0.19.1/full/&quot;
      });

      await pyodide.loadPackage(&quot;numpy&quot;);
      await pyodide.loadPackage(&quot;matplotlib&quot;);
      await pyodide.loadPackage(&quot;micropip&quot;);
      await pyodide.runPythonAsync(`
          import micropip
          micropip.install(&apos;seaborn&apos;)
      `);

      return pyodide;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราอธิบายโค้ดตามข้างบนนี้ โดยเป็นฟังก์ชัน importLib ที่เริ่มมาจากการนำเข้าไลบรารี เริ่มต้นการทำงานของ Pyodide แล้วนำเข้าแพคเกจเข้าไปในระบบโดยผ่านการใช้คำสั่ง loadPackage และ micropip.install (ที่ผ่านการใช้คำสั่ง runPythonAsync)&lt;/p&gt;

&lt;h3 id=&quot;2-เริ่มการพล็อตกราฟ&quot;&gt;2. เริ่มการพล็อตกราฟ&lt;/h3&gt;

&lt;p&gt;เริ่มต้นการพล็อตกราฟโดยใช้คำสั่งในไลบรารี&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;numpy มีไว้สำหรับการจำองข้อมูลขึ้นมา&lt;/li&gt;
  &lt;li&gt;matplotlib + seaborn มีไว้ใช้สำหรับการพล็อตกราฟ&lt;/li&gt;
  &lt;li&gt;base64 และ io มีไว้สำหรับการส่งออกกราฟให้อยู่ในรูปไบนารีที่แปลงออกมาเป็น base64&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เราเขียนโค้ดได้โดยตามขั้นตอนตามด้านล่างนี้&lt;/p&gt;

&lt;h4 id=&quot;21-เรียกใช้ไลบรารี&quot;&gt;2.1 เรียกใช้ไลบรารี&lt;/h4&gt;

&lt;p&gt;เราเรียกใช้ไลบรารี numpy, matplotlib, seaborn, base64 และ io ผ่านการพิมพ์คำสั่ง Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import numpy as np
  import seaborn as sns
  from matplotlib import pyplot as plt
  import base64, io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;22-จำลองข้อมูลขึ้นมา&quot;&gt;2.2 จำลองข้อมูลขึ้นมา&lt;/h4&gt;

&lt;p&gt;เราสามารถจำลองข้อมูลขึ้นมาได้โดยผ่านการสุ่มตัวเลขโดยผลลัพธ์ที่ต้องการเป็นในรูปแบบอาเรย์ที่สามารถพล็อตกราฟได้โดยใช้คำสั่งในไลบรารี numpy โดยในที่นี่เราจะสุ่มโดยการใช้ Normal Distribution (หรือ Gaussian Distribution) ผ่านการใช้คำสั่ง Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mu, sigma = 0, 0.1
    data = np.random.normal(mu, sigma, 1000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้อาเรย์ที่ผ่านการสุ่มแบบ &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal Distribution&lt;/a&gt; ที่มีตัวเลขทั้งหมด 1,000 ค่าครับ โดยกำหนดค่าเฉลี่ยเท่ากับ 0 และค่าส่วนเบี่ยงเบนมาตรฐานเท่ากับ 0.1&lt;/p&gt;

&lt;h4 id=&quot;23-พล็อตกราฟ&quot;&gt;2.3 พล็อตกราฟ&lt;/h4&gt;

&lt;p&gt;เรานำอาเรย์ที่ผ่านการสุ่มแบบ Normal Distribution มาพล็อตกราฟได้โดยการใช้คำสั่งในไลบรารี matplotlib + seaborn ได้โดยการพิมพ์โค้ด Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    plt.xlabel(&quot;Sample&quot;)
    plt.ylabel(&quot;Count&quot;)
    sns.histplot(data=data, color=&quot;y&quot;, kde = True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;่จากตัวโค้ดเรากำหนดข้อความในแกน x เป็น Sample และแกน y เป็น Count แล้วพล็อตกราฟให้อยู่ในรูป Histrogram ที่มีพื้นหลังตัวกราฟเป็นสีเหลือง ร่วมกับกำหนด Distribution Cruve ผ่านการคำนวณโดย &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;Kernel Density Estimation&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-ส่งออกกราฟให้อยู่ในรูป-base64&quot;&gt;2.4 ส่งออกกราฟให้อยู่ในรูป base64&lt;/h4&gt;

&lt;p&gt;เราสามารถส่งออกกราฟที่พล็อตผ่าน matplotlib + seaborn ให้อยู่ในรูป base64 ที่สามารถแสดงได้ในแท็ก img โดยการพิมพ์โค้ด Python ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    buf = io.BytesIO()
    plt.savefig(buf, format=&apos;png&apos;)
    buf.seek(0)
    img_str = &apos;data:image/png;base64,&apos; + base64.b64encode(buf.getvalue()).decode(&apos;UTF-8&apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;โค้ดตามด้านบนนี้ต้องการให้ส่งออกกราฟที่พล็อตได้ให้อยู่ในรูปไบนารีที่อยู่ในฟอร์แมต png และอยู่ในหน่วยความจำคอมพิวเตอร์ แล้วแปลงตัวไบนารีให้อยู่ในรูป base64&lt;/p&gt;

&lt;h4 id=&quot;25-นำมาเขียนรวมกัน&quot;&gt;2.5 นำมาเขียนรวมกัน&lt;/h4&gt;

&lt;p&gt;เราสามารถเขียนรวมกันได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    import numpy as np
    import seaborn as sns
    from matplotlib import pyplot as plt
    import base64, io

    mu, sigma = 0, 0.1
    data = np.random.normal(mu, sigma, 1000)

    plt.xlabel(&quot;Sample&quot;)
    plt.ylabel(&quot;Count&quot;)
    sns.histplot(data=data, color=&quot;y&quot;, kde = True)
        
    buf = io.BytesIO()
    plt.savefig(buf, format=&apos;png&apos;)
    buf.seek(0)
    img_str = &apos;data:image/png;base64,&apos; + base64.b64encode(buf.getvalue()).decode(&apos;UTF-8&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;26-นำมาเขียนเพื่อให้ทำงานผ่านการใช้ไลบรารี-pyodide&quot;&gt;2.6 นำมาเขียนเพื่อให้ทำงานผ่านการใช้ไลบรารี Pyodide&lt;/h4&gt;

&lt;p&gt;เราเขียนให้ทำงานผ่าน Pyodide ได้ตามด้านล่างนี้ผ่านการใช้คำสั่งใน runPythonAsync แล้วนำค่าตัวแปรที่ได้ใน Python ออกมาให้ใช้งานผ่าน JavaScript ได้โดยเขียนโค้ดตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function drawGraph(pyodide)
  {
    await pyodide.runPythonAsync(`
        import numpy as np
        import seaborn as sns
        from matplotlib import pyplot as plt
        import base64, io

        mu, sigma = 0, 0.1
        data = np.random.normal(mu, sigma, 1000)

        plt.xlabel(&quot;Sample&quot;)
        plt.ylabel(&quot;Count&quot;)
        sns.histplot(data=data, color=&quot;y&quot;, kde = True)

        buf = io.BytesIO()
        plt.savefig(buf, format=&apos;png&apos;)
        buf.seek(0)
        img_str = &apos;data:image/png;base64,&apos; + base64.b64encode(buf.getvalue()).decode(&apos;UTF-8&apos;)
        plt.clf()
    `);

    let b64result = pyodide.globals.get(&quot;img_str&quot;);
    return b64result;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์เสร็จแล้ว เราสามารถเรียกใช้ฟังก์ชัน drawGraph(&amp;lt;ไลบรารี pyodide ที่โหลดมาแล้ว&amp;gt;);&lt;/p&gt;

&lt;h4 id=&quot;27-นำโค้ดที่ได้มาเขียนรวมกันเพื่อแสดงกราฟบนแท็ก-img&quot;&gt;2.7 นำโค้ดที่ได้มาเขียนรวมกันเพื่อแสดงกราฟบนแท็ก img&lt;/h4&gt;

&lt;p&gt;เรานำโค้ดที่เขียนอยู่ในรูปฟังก์ชันตามข้างบนนี้เพื่อให้ได้ภาพมาแสดงบนแท็ก img ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  async function onPageLoaded(event)
  {
      let img_canvas = document.getElementById(&apos;&amp;lt; id ของแท็ก img &amp;gt;&apos;),
      let pyodide = await importLib();
      let b64result = await drawGraph(pyodide);
      img_canvas.src = b64result;
  }

  window.addEventListener(&apos;DOMContentLoaded&apos;, onPageLoaded);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อนำมารวมกันแล้วทดลองรันบนเว็บเบราวเซอร์ เราจะพบว่ากราฟจะพล็อตเมื่อหน้าเว็บเริ่มโหลด แล้วเมื่อเว็บโหลดเสร็จแล้ว เราจะเห็นกราฟที่อยู่ในแท็ก img ออกมาเป็นตามภาพด้างล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/03/pyodide_graph_result.png&quot; alt=&quot;Graph Result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เป็นไงล่ะ เราจะเห็นกราฟ Histrogram ที่ผ่านการสุ่มแบบ Normal Distribution นั่นเองครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;สำหรับตัวอย่างหน้าเว็บที่ทำเสร็จแล้ว ผู้อ่านสามารถเข้าไปดูที่ &lt;a href=&quot;https://asset.nickuntitled.com/demo/pyodide/pyodide_demo.html&quot;&gt;Demo&lt;/a&gt; นี่ได้เลยครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;จุดสังเกต&quot;&gt;จุดสังเกต&lt;/h2&gt;

&lt;p&gt;ตัวเว็บทำงานได้ช้าเนื่องมาจาก&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ตัวโค้ดตามด้านบนต้องดาวน์โหลดไลบรารี pyodide จาก CDN&lt;/li&gt;
  &lt;li&gt;ตัวโค้ดต้องเริ่มต้นการทำงาน pyodide ร่วมกับโหลดไลบรารีที่จำเป็น่ผ่านการดาวน์โหลดไลบรารีบน server&lt;/li&gt;
  &lt;li&gt;พล็อตกราฟผ่านการใช้คำสั่ง Python ที่อยู่บน pyodide อีกที&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;จากจุดสังเกตตามข้างบนนี้ สำหรับผู้อ่านที่มาอ่านบทความนี้แล้วจะนำไปใช้ อาจจะต้องพิจารณาประสิทธิภาพในการทำงานอีกทีครับ&lt;/p&gt;

&lt;p&gt;ถ้าเป็นไปได้ อาจจะลองใช้ไลบรารีที่มีอยู่แล้วอย่าง &lt;a href=&quot;https://www.chartjs.org/&quot;&gt;Chart.js&lt;/a&gt; หรือ &lt;a href=&quot;https://plotly.com/javascript/&quot;&gt;Plotly&lt;/a&gt; ก่อนก็ได้ครับผม ทั้งสองไลบรารีที่กล่าวมาในย่อหน้านี้ก็สามารถพล็อตกราฟให้สวยงามได้ตามใจชอบได้เช่นกัน&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Jupyter" /><category term="Data Science" /><category term="Pyodide" /><category term="Matplotlib" /><category term="Seaborn" /><category term="JavaScript" /><category term="Mozilla" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วิทยาการคำนวณ" /><category term="กราฟ" /><summary type="html">บทความนี้พูดถึงการรันโค้ดไพทอนโดยใช้ไลบรารี Pyodide โดยจะแนะนำไลบรารี การเริ่มต้นใช้งาน และพล็อตกราฟแล้วนำมาแสดงบน img ที่หน้าเว็บไซต์</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/03/plot_python_graph_website_pyodide_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/03/plot_python_graph_website_pyodide_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">รันโค้ด Jupyter โดยไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้</title><link href="https://nickuntitled.com/2022/02/13/running_jupyter_notebook_bg/" rel="alternate" type="text/html" title="รันโค้ด Jupyter โดยไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้" /><published>2022-02-16T00:00:00+07:00</published><updated>2022-02-16T00:00:00+07:00</updated><id>https://nickuntitled.com/2022/02/13/run-jupyter-background</id><content type="html" xml:base="https://nickuntitled.com/2022/02/13/running_jupyter_notebook_bg/">&lt;p&gt;Jupyter Notebook เป็นเครื่องมือที่ช่วยให้เรารันตัว Python Notebook ได้ ซึ่งตัวนี้เหมาะกับการเขียนโค้ดเพื่อคำนวณทางด้านวิทยาศาสตร์ หรือทำงานด้าน Data Science และอื่น ๆ เป็นต้น ซึ่งเราจะพบการใช้งานตัว &lt;a href=&quot;https://jupyter.org/&quot;&gt;Jupyter Notebook&lt;/a&gt; ได้บ่อย ๆ ใน &lt;a href=&quot;http://colab.research.google.com/&quot;&gt;Google Colab&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การใช้งานตัว Google Colab พบปัญหา เนื่องมาจากตัวฟรี หรือตัวโปรรุ่นล่าง ๆ จะเปิดให้รันบนเบื้องหลังได้ไม่นาน หลังจากนั้นตัวระบบจะตัดไป เพื่อนำทรัพยากรที่มีจำกัดให้กับบุคคลอื่นแทน ดังนั้นแล้วการใช้งาน Jupyter Notebook บนคอมพิวเตอร์ของเรา หรือบนเซิร์ฟเวอร์ของเราเองจะเป็นทางเลือกที่ดีกว่า&lt;/p&gt;

&lt;p&gt;เมื่อเราติดตั้งตัว jupyter Notebook ไว้ในคอมพิวเตอร์ของเราแล้ว เราเข้าตัว Notebook ่ผ่านทางหน้าเว็บเบราวเซอร์เพื่อใช้งาน เมื่อเรารันโค้ดที่มีใน Python Notebook แล้วปิดหน้าเว็บเบราวเซอร์ทิ้งไว้ ตัวผลลัพธ์อาจจะไม่ปรากฏบนหน้าจอ หรือเปิดให้รันโค้ดไปซักพักแล้วจะขึ้น Keyboard Interrupt แล้วตัวโค้ดที่รันไว้จะหยุดการทำงาน&lt;/p&gt;

&lt;p&gt;แล้วมีวิธีไหนที่จะรันตัวโค้ดที่เขียนอยู่ใน Python Notebook ให้ทำงานอยู่ถึงแม้ว่าเราจะปิดเว็บเบราวเซอร์ไปแล้วล่ะ? จากที่ไปค้นในเน็ตมีอยู่หลายวิธีได้แก่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;รันตัวโค้ดผ่านทาง SSH&lt;/li&gt;
  &lt;li&gt;รันผ่านทาง VNC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;วิธีแรกอันนี้ทำไม่ได้ เพราะเซิร์ฟเวอร์ที่ใช้อยู่ไม่ได้เปิดให้เข้าผ่านทาง SSH ดังนั้นแล้ว เราเลือกวิธีที่สองแทน โดยวิธีนี้เอามาจากใน&lt;a href=&quot;https://towardsdatascience.com/keep-jupyter-notebook-running-even-after-browser-is-closed-9a1937b7c615&quot;&gt;เว็บ Towards Data Science&lt;/a&gt; แล้วเอามาใช้กับงานเราครับ&lt;/p&gt;

&lt;p&gt;แต่ก่อนอื่นติดตั้ง ML workspace หรือติดตั้ง Jupyter Notebook ลงบนเซิร์ฟเวอร์ที่เราใช้งานอยู่ (หรือติดตั้งบนคลาวด์อย่าง DigitalOcean ก็ได้ ถ้าไม่มีสมาชิกก็&lt;a href=&quot;https://m.do.co/c/61ae5e7ddeb6&quot;&gt;สมัครสมาชิก&lt;/a&gt;ก่อน) อย่างไรก็ดีในตัวอย่างนี้เราแนะนำ ML workspace ที่ติดตั้งเป็นตัว Docker Container เพราะมันสะดวกมากกว่า แถมมันอยู่ใน Sandbox ไม่รบกวน OS หลักที่เราใช้งานอยู่&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มใช้งาน-และการเข้าไปใช้งาน-vnc&quot;&gt;การเริ่มใช้งาน และการเข้าไปใช้งาน VNC&lt;/h2&gt;

&lt;p&gt;เมื่อติดตั้งเสร็จแล้ว เราเริ่มทำได้โดยเปิดใช้งาน &lt;a href=&quot;https://github.com/ml-tooling/ml-workspace&quot;&gt;ML workspace&lt;/a&gt; ผ่านการใช้คำสั่งของ Docker เอง จากนั้นให้เราเข้าไปใช้งาน ML workspace โดย&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เข้าทางหน้าเว็บจากเครื่องคอมพิวเตอร์เครื่องมือ&lt;/li&gt;
  &lt;li&gt;เมื่อเข้ามาแล้ว เราจะพบหน้าจอ Jupyter Notebook ให้ใส่รหัสผ่านแล้วเข้ามาจะเจอหน้าจอหลักตามภาพแรก&lt;/li&gt;
  &lt;li&gt;เลื่อนเมาส์ไปยัง Tools ที่มุมบนขวา จากนั้นเลื่อนลงมาจะเจอ VNC ให้เลือกที่ VNC แล้วจะพบหน้าจอเดสก์ท็อปของลินุกซ์ ให้เราคลิกเมาส์ที่ Jupyter Notebook ตามภาพต่อมา&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/jupyter_notebook.jpeg&quot; alt=&quot;Jupyter Notebook&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/vnc.jpeg&quot; alt=&quot;VNC&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;การเริ่มรัน-jupyter-notebook&quot;&gt;การเริ่มรัน Jupyter Notebook&lt;/h2&gt;

&lt;p&gt;เมื่อเราเข้าไปใช้งาน Jupyter Notebook ผ่านตัว VNC แล้ว ให้เราเลือกไฟล์ Python Notebook ที่เราต้องการ จากนั้นเลือกที่ Run Cells ที่มันรันนาน ๆ (ของเราเป็นการทำ Inference ของ Head Pose Estimation จากไฟล์วิดีโอ)&lt;/p&gt;

&lt;p&gt;เมื่อกดเริ่มรันเรียบร้อย ระหว่างที่มันรันอยู่ ให้เราเลือกที่ Disconnect ที่ด้านซ้ายตามลูกศร&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2022/02/jupyter_vnc.jpeg&quot; alt=&quot;Running Jupyter Notebook on VNC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;กดปุ่ม Disconnect แล้ว ระบบจะตัดการเชื่อมต่อไป ระหว่างนี้ตัวโค้ดก็ยังรันอยู่ตามปกติโดยที่ไม่เจอการตัดการทำงานของตัวโค้ดเลย ยกเว้นแต่ว่ามีคนไปปิดเครื่องเซิร์ฟเวอร์ หรือไฟดับระหว่างที่รันครับ&lt;/p&gt;

&lt;p&gt;สำหรับผู้อ่านที่สนใจ สามารถไปประยุกต์ใช้ได้เลย วิธีนี้ใช้ง่ายดี ไม่ต้องเข้าผ่าน SSH แล้วพิมพ์คอมมานไลน์ให้ยุ่งยากฮะ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Jupyter" /><category term="Data Science" /><category term="AI" /><category term="Artificial Intelligence" /><category term="Machine Learning" /><category term="Notebook" /><category term="Background" /><category term="Python Notebook" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วิทยาการคำนวณ" /><category term="ปัญญาประดิษฐ์" /><summary type="html">บทความนี้พูดถึงการใช้ Jupyter โดยรันตัว Python Notebook ที่ไม่ต้องเปิดหน้าเว็บเบราวเซอร์ทิ้งไว้</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/02/jupyter_notebook_bg_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/02/jupyter_notebook_bg_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">เขียนโค้ดจาวาสคริปเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่</title><link href="https://nickuntitled.com/2022/02/03/coding_check_metamask_crypto_web3/" rel="alternate" type="text/html" title="เขียนโค้ดจาวาสคริปเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่" /><published>2022-02-03T00:30:00+07:00</published><updated>2022-02-03T00:30:00+07:00</updated><id>https://nickuntitled.com/2022/02/03/check-web3-browser-javascript</id><content type="html" xml:base="https://nickuntitled.com/2022/02/03/coding_check_metamask_crypto_web3/">&lt;p&gt;Web3 (ที่ไม่ใช่ &lt;a href=&quot;https://en.wikipedia.org/wiki/Semantic_Web&quot;&gt;Web 3.0&lt;/a&gt; ตามที่คุณ Tim Berners-Lee กล่าวไว้) เป็นเว็บไซต์รูปแบบหนึ่งที่อยู่บนบล็อคเชนที่นำหลักการ Decentralization และหลักการ Token-based economics ตัวอย่างเช่นคริปโต โดย Web3 ที่พบได้ และบางคนก็ใช้ก็ตัวอย่างเช่น DeFi แบบ Pancakeswap หรืออื่น ๆ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี เวลาที่เปิดใช้งานเว็บแนวนี้เราก็ต้องเช็คก่อนครับว่ามีกระเป๋าตังคริปโต (ที่ได้ยินบ่อยก็เป็น MetaMask) หรือไม่ ถ้ามี เราก็เปิดให้เชื่อมกับกระเป๋าตังสำหรับใช้ทำธุรกรรม Smart Contract หรืออื่น ๆ ต่อได้เลย แต่ถ้าไม่มีก็ให้เว็บแจ้งว่าไม่มี&lt;/p&gt;

&lt;h2 id=&quot;เขียนโค้ด&quot;&gt;เขียนโค้ด&lt;/h2&gt;

&lt;p&gt;หลังจากที่เกริ่นมาสักพักแล้ว เรามาเขียนโค้ดกันดีกว่า ในขั้นตอนแรก เราก็ต้องเช็คว่ามีตัวแปรที่เกี่ยวข้องกับ MetaMask หรือไม่ โดยเขียนโค้ดตามด้านล่างนี้&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;โค้ดบางส่วนนำมาจาก &lt;a href=&quot;https://ethereum.stackexchange.com/questions/44601/how-to-check-whether-metamask-is-installed&quot;&gt;StackOverflow&lt;/a&gt; และเอกสารจากทางเว็บ &lt;a href=&quot;https://docs.metamask.io/guide/ethereum-provider.html#properties&quot;&gt;MetaMask&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if(typeof window.ethereum != &quot;undefined&quot; || typeof window.web3 != &quot;undefined&quot;) {

  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเช็คแล้วว่ามีตัวแปรที่เกี่ยวข้องแล้ว เราก็เรียกใช้งานตัวแปรที่เกี่ยวข้องแล้วอ่านค่าตัวแปรนี้ว่ามี MetaMask หรือไม่ โดยเขียนโค้ดตามด้านล่างนี้ในปีกกาครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  const web3provider = window.ethereum || window.web3.currentProvider;
  const metamask = web3provider.isMetaMask;

  if(metamask) {
    console.log(&quot;We found MetaMask.&quot;);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียนโค้ดตามข้างบนนี้เสร็จแล้ว โค้ดที่ได้จะตามด้านล่างนี้&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if(typeof window.ethereum != &quot;undefined&quot; || typeof window.web3 != &quot;undefined&quot;) {
    const web3provider = window.ethereum || window.web3.currentProvider;
    const metamask = web3provider.isMetaMask;

    if(metamask) {
      console.log(&quot;We found MetaMask.&quot;);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราทดสอบบนเว็บเบราวเซอร์ที่ติดตั้ง MetaMask อยู่ เราเปิดหน้า JavaScript Console จะปรากฏผลลัพธ์ว่า&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  We found MetaMask.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ส่วนกรณีที่ไม่มี MetaMask ติดตั้งอยู่ เวลาเรียกใช้ฟังก์ชันตามข้างบนนี้จะพบ Error ขึ้นมากล่าวประมาณว่าไม่พบตัวแปร window.ethereum และ window.web3.currentProvider ครับ&lt;/p&gt;

&lt;p&gt;เมื่อเราเขียนโค้ดตามข้างบนนี้แล้ว เราสามารถรประยุกต์ใช้งานเพื่อทำธุรกรรมอื่นต่อ หรือทำแบนเนอร์บอกว่าเราใช้งาน Web3 อยู่นะ อะไรประมาณนี้ครับ ตัวอย่างก็พบได้ในหน้าโฮมของเว็บนี้ หรือตามวิดีโอด้านล่างนี้ได้ครับ&lt;/p&gt;

&lt;video src=&quot;https://asset.nickuntitled.com/2022/02/nickuntitled_web3.mp4&quot; controls=&quot;&quot;&gt;
  เว็บเบราวเซอร์ของท่านไม่รองรับการใช้งานวิดีโอ อย่างไรก็ดีเราอธิบายวิดีโอนี้ได้ว่ามันเกี่ยวกับการเปิดใช้งานบนเว็บเบราวเซอร์ที่ติดมากับ MetaMask ครับ
&lt;/video&gt;

&lt;p&gt;สำหรับผู้อ่านแล้ว ผู้อ่านสามารถประยุกต์เอาไปใช้งานกับเว็บตัวเองได้เลยครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="Web3" /><category term="MetaMask" /><category term="Cryptocurrency" /><category term="Wallet" /><category term="Ethereum" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><summary type="html">บทความนี้พูดถึงการเขียนโค้ดเพื่อเช็คว่าใช้งาน MetaMask อยู่หรือไม่ สำหรับการนำไปใช้ทำธุรกรรมต่อ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/02/metamask_checker_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/02/metamask_checker_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">การเขียนโค้ดเพื่อใช้งาน GraphQL โดยไม่ใช้ไลบรารี</title><link href="https://nickuntitled.com/2022/01/25/graphql_without_library/" rel="alternate" type="text/html" title="การเขียนโค้ดเพื่อใช้งาน GraphQL โดยไม่ใช้ไลบรารี" /><published>2022-01-25T06:30:00+07:00</published><updated>2022-01-25T06:30:00+07:00</updated><id>https://nickuntitled.com/2022/01/25/graphql-without-library</id><content type="html" xml:base="https://nickuntitled.com/2022/01/25/graphql_without_library/">&lt;p&gt;เวลาที่ส่งข้อมูลระหว่าง Client และ Server ผ่านทางจาวาสคริปโดยเรียกใช้งานผ่านทาง &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX&quot;&gt;AJAX&lt;/a&gt; ปกติ เราจะส่งข้อมูลโดยวิธี POST ผ่านการพิมพ์โค้ดตามด้านล่างนี้ (ในตัวอย่างจะใช้ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest&lt;/a&gt; แต่จะใช้ Fetch, Axios หรืออื่น ๆ ก็ได้ เพราะได้ผลเหมือนกัน)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();

  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;url&amp;gt;&quot;);

  ajaxrequest.onload = (event) =&amp;gt; {
      if(ajaxrequest.readyState == ajaxrequest.DONE) {
          if(ajaxrequest.status == 200) {
              /* Do Something */
          } else {
              console.error(&quot;[*] Error!);
          }
      }
  };

  ajaxrequest.onprogress = (event) =&amp;gt; {
      console.log(&apos;Processing...&apos;);
  };

  ajaxrequest.send(`argument=value&amp;amp;argument2=value`);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อใช้งานคำสั่งนี้แล้ว ข้อมูลจะได้รับการส่งไปยัง Server เพื่อประมวลผลต่อ จากนั้นเมื่อประมวลผลสำเร็จแล้ว ทางฝั่ง Server จะส่งข้อมูลกลับมาทาง Client เพื่อนำไปประมวลผลต่อ ขั้นตอนนี้แหละ ที่คนนำไปสร้าง API ที่ใช้กันอยู่ในปัจจุบันนี้ที่มีชื่อว่า REST API&lt;/p&gt;

&lt;h2 id=&quot;rest-api&quot;&gt;REST API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@settawatjanpuk/beginner-%E0%B8%A1%E0%B8%B2%E0%B8%97%E0%B8%B3%E0%B8%84%E0%B8%A7%E0%B8%B2%E0%B8%A1%E0%B8%A3%E0%B8%B9%E0%B9%89%E0%B8%88%E0%B8%B1%E0%B8%81%E0%B8%81%E0%B8%B1%E0%B8%9A-rest-api-%E0%B8%81%E0%B8%B1%E0%B8%99%E0%B8%94%E0%B8%B5%E0%B8%81%E0%B8%A7%E0%B9%88%E0%B8%B2-%E0%B8%A1%E0%B8%B5%E0%B8%95%E0%B8%B1%E0%B8%A7%E0%B8%AD%E0%B8%A2%E0%B9%88%E0%B8%B2%E0%B8%87-c855d93beaf3&quot;&gt;REST API&lt;/a&gt; (ย่อมาจาก Representational State Transfer API) เป็นรูปแบบการส่งข้อมูลรูปแบบหนึ่งที่อยู่บนพื้นฐานของ HTTP Protocol เทคนิคนี้อนุญาตให้เราส่งข้อมูลในรูปแบบ JSON (JavaScript Object Notion), Text, File หรืออื่น ๆ แต่ที่ใช้กันบ่อยก็เป็น JSON เนื่องจากสะดวก และรองรับเว็บเบราวเซอร์หลายชนิด แถมเทคนิคนี้ใช้งานได้ง่าย ใช้ทำ Web Service ที่เกี่ยวข้องกับ CRUD ได้เลย เนื่องจากเราใช้งานโค้ดตามข้างบนได้เพียงแต่เปลี่ยนวิธีการส่งข้อมูลผ่านทาง HTTP Protocol ตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GET — R(etrieve) เรียกดูข้อมูล&lt;/li&gt;
  &lt;li&gt;POST — C(reate) เพิ่มข้อมูล&lt;/li&gt;
  &lt;li&gt;PUT — U(pdate) แก้ไขข้อมูล&lt;/li&gt;
  &lt;li&gt;DELETE — D(elete) ลบข้อมูล&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;อย่างไรก็ดี เราไม่จำเป็นต้องใช้งานตามข้างบนนี้เป๊ะ ๆ ก็ได้ ใช้งานแค่ POST กับ GET ก็ยังใช้งานได้ตามปกติ เพียงแต่ขึ้นกับทีมที่เขียนโปรแกรมว่าตกลงยังไงนี่แหละครับ&lt;/p&gt;

&lt;p&gt;ต่อมา เราจะมาพูดถึง GraphQL&lt;/p&gt;

&lt;h2 id=&quot;graphql&quot;&gt;GraphQL&lt;/h2&gt;

&lt;p&gt;REST API เป็นไลบรารีที่นิยมสำหรับการสร้าง Web Service อย่างไรก็ดีการใช้งาน REST API ก็มีข้อเสียหลัก ๆ ก็ต้องส่งข้อมูลผ่านทาง HTTP Protocol หลายรอบ (Multiple requests) และรับข้อมูลที่มากเกินจำเป็น (Over-fetching)&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้ว &lt;a href=&quot;https://graphql.org/&quot;&gt;GraphQL&lt;/a&gt; จึงได้รับการพัฒนาขึ้นเพื่อแก้ปัญหาตามย่อหน้าด้านบนนี้ แล้วมันคืออะไร?&lt;/p&gt;

&lt;p&gt;GraphQL เป็นโค้ดภาษาหนึ่งที่ใช้เรียกงาน API ผ่านทาง HTTP Protocol รูปแบบหนึ่งเพื่อจัดการข้อมูลได้ตามที่ต้องการ เครื่องมือนี้ได้รับการพัฒนาโดยบริษัท Meta (Facebook เดิม) ตั้งแต่ปี 2012 และเทคนิคนี้ได้รับการนำไปใช้งานจริงในหลายเว็บไซต์ ได้แก่ Github, Pinterest, Coursera เป็นต้น&lt;/p&gt;

&lt;p&gt;การใช้งาน ใช้งานได้ไม่ยากผ่านทางไลบรารีที่นิยมอย่างตัว GraphQL เอง หรือใช้งานผ่านไลบรารี Apollo Server/Client ก็ได้ อย่างไรก็ดี ในบทความนี้จะไม่ลงลึกเรื่องไลบรารี เราจะมาพูดถึงการส่งข้อมูล GraphQL ที่ไม่ได้ใช้งานไลบรารีกันดีกว่า&lt;/p&gt;

&lt;p&gt;การส่งข้อมูลผ่านทาง GraphQL ที่ใช้งานบ่อยก็เป็นการเรียกข้อมูล และการจัดการข้อมูลผ่านทางการใช้คำสั่งที่เกี่ยวข้องกับ query และ mutation&lt;/p&gt;

&lt;h3 id=&quot;query&quot;&gt;query&lt;/h3&gt;

&lt;p&gt;query เป็นการเรียกใช้ฟังก์ชันเพื่อดึงข้อมูลจากฐานข้อมูล สำหรับการแสดงผล และประมวลผลบน Client ในขั้นตอนต่อไป เราเขียน Schema สำหรับการเรียกข้อมูลบนเซิร์ฟเวอร์ได้ตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {
    &amp;lt;GraphQL query command&amp;gt;(&amp;lt;GraphQL query arguments&amp;gt;) {
      &amp;lt;the data that you want to be returned from the server&amp;gt;
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวอย่างการเขียน Schema ก็เขียนตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let str_query = `{
    getUser(user_id: &quot;${ user_id }&quot;) {
        name
        surname
    }
  }`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียน Schema เสร็จแล้ว เราเขียน Argument สำหรับการนำไปใช้งานผ่าน XMLHttpRequest ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = {
      query: str_query
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเขียน Argument เสร็จแล้ว เราก็ต้องส่งข้อมูลจาก Client ไปยัง Server เราส่งข้อมูลผ่าน XMLHttpRequest ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
    
  ajaxrequest.responseType = &apos;json&apos;;
  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;URL for GraphQL Server&amp;gt;&quot;);
  ajaxrequest.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };

  ajaxrequest.send(JSON.stringify(query));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้น เมื่อเรียกใช้งานคำสั่งตามด้านบนนี้ ข้อมูลที่เขียนในรูปแบบ GraphQL จะส่งจาก Client ไปยัง Server แล้วทางนั้นจะคืนข้อมูล name, surname ที่อยู่ในรูปแบบ JSON ได้ตามที่ต้องการครับ&lt;/p&gt;

&lt;h3 id=&quot;mutation&quot;&gt;mutation&lt;/h3&gt;

&lt;p&gt;mutation เป็นการเรียกใช้ฟังก์ชันเพื่อเปลี่ยนแปลงข้อมูล แล้วแสดงผลข้อมูลกลับมาที่เราต้องการ เราเขียน Schema ของ mutation ได้ตามตัวอย่างด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = `mutation {
    &amp;lt;GraphQL Mutation Command&amp;gt;(&amp;lt;Arguments&amp;gt;) {
      &amp;lt;the data that you want to be returned from the server&amp;gt;
    }
  }`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เรานำ Argument ที่เขียนแล้วส่งข้อมูลผ่านทาง XMLHttpRequest ได้ด้วยการเขียนโค้ดตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
  let form_data = new FormData();
  let map = {};

  ajaxrequest.responseType = &apos;json&apos;;
  ajaxrequest.open(&quot;POST&quot;, &quot;&amp;lt;GraphQL server URL&amp;gt;&quot;);
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };

  // FormData
  form_data.append(&quot;operations&quot;, JSON.stringify({ query }));
  form_data.append(&quot;map&quot;, JSON.stringify(map));

  // Send Form Data
  ajaxrequest.send(form_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สำหรับการอัพโหลดไฟล์ เราพิมพ์ Schema เพื่ออัพโหลดไฟล์ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let query = `mutation($file: Upload!) {
      &amp;lt;GraphQL Upload mutation command&amp;gt;(&amp;lt;Arguments&amp;gt;, upload_file: $file) {
          &amp;lt;the data that you want to be returned from the server&amp;gt;
      }
  }`;
  let variables = { &quot;file&quot;: null };
  let map = { &quot;0&quot;: [&quot;variables.file&quot;] };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วสร้างตัวแปรเพื่อรองรับ File Object สำหรับการอัพโหลดไฟล์ตามโค้ดด้านล่าง ในตัวอยา่งจะใช้ File Input ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let fileObj = document.getElementById(&apos;&amp;lt;File Input ID&amp;gt;&apos;).files[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เราเรียกใช้งาน XMLHttpRequest เจ้าเดิมได้โดยการพิมพ์คำสั่งตามตัวอย่างด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let ajaxrequest = new XMLHttpRequest();
  ajaxrequest.responseType = &apos;json&apos;;
  ajaxrequest.open(&apos;POST&apos;, graphql_url);
  ajaxrequest.onload = function () {
      if(ajaxrequest.status == 200) {
          /* Do Something */
      } else if(ajaxrequest.status &amp;gt;= 400 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 500) {
          /* Do Something for Client Error */
      } else if(ajaxrequest.status &amp;gt;= 500 &amp;amp;&amp;amp; ajaxrequest.status &amp;lt; 600) {
          /* Do Something for Internal Server Error */
      }
  };
  
	// FormData
	form_data.append(&quot;operations&quot;, JSON.stringify({ query, variables }));
	form_data.append(&quot;map&quot;, JSON.stringify(map));
	form_data.append(&quot;0&quot;, fileObj);

	// Send Form Data
  ajaxrequest.send(form_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเรียกใช้งานจะพบว่าไฟล์ได้รับการอัพโหลดเรียบร้อย&lt;/p&gt;

&lt;p&gt;เมื่อเราเขียนโค้ดตามด้านบนแล้ว สามารถทดสอบบนเว็บเบราวเซอร์ได้เลย ผลลัพธ์ก็จะเหมือนการใช้งาน GraphQL ผ่านทางไลบรารี อย่างไรก็ดี การใช้งานตามที่เขียนนี้จะดูยุ่งยากกว่าการใช้งานผ่านทางไลบรารีครับ ดังนั้นแล้วถ้าใช้งานไลบรารีได้ ก็แนะนำให้ใช้ไลบรารีได้ก่อนได้เลย โดยไลบรารีที่เราเคยใช้ก็ตัวอย่างเช่น &lt;a href=&quot;https://www.apollographql.com/docs/react/&quot;&gt;Apollo Client&lt;/a&gt; ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="GraphQL" /><category term="AJAX" /><category term="Httprequest" /><category term="XMLHttpRequest" /><category term="HTTP" /><category term="POST" /><category term="JSON" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วัตถุ" /><summary type="html">บทความนี้แนะนำวิธีการเขียนโค้ด JavaScript เพื่อใช้งาน GraphQL แบบที่ไม่ได้ใช้ไลบรารี</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2022/01/graphql_js_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2022/01/graphql_js_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วิธีการเลือก parent element ด้วย JavaScript</title><link href="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/" rel="alternate" type="text/html" title="วิธีการเลือก parent element ด้วย JavaScript" /><published>2022-01-02T22:30:00+07:00</published><updated>2022-01-02T22:30:00+07:00</updated><id>https://nickuntitled.com/2022/01/2/element-closest</id><content type="html" xml:base="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/">&lt;p&gt;ปกติเวลาที่เราเลือก element ด้วยภาษาจาวาสคริป เราจะใช้คำสั่งที่รู้จักกันอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.getElementById(&quot;id&quot;);
document.document.getElementsByClassName(&quot;class name&quot;);
document.document.getElementsByName(&quot;name&quot;);
document.document.getElementsByTagName(&quot;tag name&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเลือก element โดยการใช้ CSS Selector ด้วยคำสั่งที่รู้จักอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.querySelector(&quot;selector&quot;);
parent_element.querySelector(&quot;selector&quot;);
document.querySelectorAll(&quot;selector&quot;);
parent_element.querySelectorAll(&quot;selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งเหล่านี้ะคืนค่า element ที่เราเลือกไว้ ไม่ว่าจะเป็น element เดียว หรือ element ทั้งหมดที่เราพบในหน้าเว็บเพจนั้น ๆ อย่างไรก็ดีเราต้องการเลือก parent element จาก element ที่อยู่ภายใน จุดนี้เราจะทำได้อย่างไร?&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery&lt;/h2&gt;

&lt;p&gt;jQuery เป็นหนึ่งในไลบรารีที่คนนิยมใช้งานกัน เราเลือก parent element ได้โดยการพิมพ์คำสั่งอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).closest(&quot;parent css selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สองคำสั่งนี้จะอนุญาตเราเลือก parent element ได้ตามที่ต้องการเลย อย่างไรก็ดี ทั้งสองคำสั่งนี้มีข้อแตกต่างกัน เรายกตัวอย่างตามภาพด้านล่างนี้ก่อน&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานทั้งสองคำสั่งได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).parent().parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).closest(&quot;div&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทั้งคู่จะเลือก parent element ที่เป็น div ครับ&lt;/p&gt;

&lt;p&gt;สรุปความแตกต่างระหว่างสองคำสั่งตามข้างบนนี้ตรงที่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.parent() เป็นคำสั่งที่ให้เราเลือก element ที่เป็น parent และอยู่ติดกับ element ที่เราเลือก&lt;/li&gt;
  &lt;li&gt;.closest() เป็นการเลือก element ที่อยู่เหนือ และอยู่ใกล้กันกับ element ที่เราเลือกไว้โดยการใช้ css selector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;อย่างไรก็ดีไลบรารีนี้มีข้อเสียได้แก่ ไลบรารีมีขนาดใหญ่ส่งผลต่อระยะเวลาการโหลดไลบรารีเพื่อใช้งาน กับไลบรารีนี้เก่าไปแล้ว เนื่องมาจากตัวจาวาสคริปเองได้รับการพัฒนาอย่างต่อเนื่องจนทำงานได้แบบเดียวกันกับ jQuery แต่ไม่ต้องพึ่งพาไลบรารีที่มีขนาดใหญ่ และทำงานได้เร็วมากกว่าไลบรารีที่กล่าวถึง&lt;/p&gt;

&lt;p&gt;ต่อไป เราจะมาพูดถึงคำสั่งที่มีอยู่แล้วในจาวาสคริป (หรือเรียกว่า &lt;a href=&quot;http://vanilla-js.com&quot;&gt;Vanilla JavaScript&lt;/a&gt;) ที่อนุญาตให้เราเลือก parent element ครับ คำสั่งเหล่านี้ได้แก่ node.parentNode, element.parentElement และ element.closest&lt;/p&gt;

&lt;h2 id=&quot;nodeparentnode-กับ-elementparentelement&quot;&gt;node.parentNode กับ element.parentElement&lt;/h2&gt;

&lt;p&gt;ทั้งคู่นี้เป็นคำสั่งในจาวาสคริปที่เลือก parent node หรือ element ที่อยู่เหนือกว่า node หรือ element ที่เราเลือก ตัวอย่างการใช้งานคำสั่งนี้เป็นไปตามด้านล่างนี้ครับ (ตัวอย่างด้านล่างเอามาจากหน้าเว็บ &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.body.parentNode; // the &amp;lt;html&amp;gt; element
document.body.parentElement; // the &amp;lt;html&amp;gt; element
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือยกตัวอย่างจากภาพเดิม&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.parentNode.parentNode;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.parentElement.parentElement;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราก็จะเลือก parent Element ที่เป็น div ได้เลย ถ้าลองสังเกตดูจะพบว่าทั้งสองคำสั่งมันก็ใช้ได้เหมือนกันนี่ แล้วมันต่างกันอย่างไร?&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงความแตกต่างระหว่าง Node กับ Element เสียก่อน (ความแตกต่างสรุปจาก&lt;a href=&quot;https://blog.webdevsimplified.com/2021-05/node-vs-element/&quot;&gt;หน้าเว็บนี้&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Element ก็คือ HTML tag ต่าง ๆ ที่อยู่ในหน้าเว็บไซต์ ได้แก่ div, span, body หรืออื่น ๆ&lt;/li&gt;
  &lt;li&gt;Node จะเป็นอะไรก็ได้ที่มีอยู่ในหน้าเว็บไซต์ รวมถึงข้อความ คอมเม้นต์ ไม่จำกัดว่าเป็น div, span, body, input, form หรืออื่น ๆ ที่เป็น HTML tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เราจะเห็นว่าการเลือก Node จะดูยุ่งยากกว่า เพราะเราค้องแยกระหว่างข้อความ คอมเม้นต์ หรือ HTML tag ดังนั้นแล้ว การใช้งาน Element จะดูจำเพาะมากกว่า&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถดูวิดีโอความแตกต่างระหว่าง Element กับ Node ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/rhvec8cXLlo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;ต่อมา เรามาดูความแตกต่างการใช้งานของสองคำสั่ง (โค้ดอ้างอิงจาก &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.documentElement.parentNode;    // document เป็น node
document.documentElement.parentElement; // null เนื่องจาก document ไม่ใช่ element
(document.documentElement.parentNode === document);  // true
(document.documentElement.parentElement === document);  // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะเห็นว่า document ไม่ได้เป็นหนึ่งใน HTML tag อะไรเลยตามที่กล่าวไว้ตามข้างบน และ document ไม่ได้เป็น element แต่ก็ยังเป็น node อยู่ ดังนั้นการใช้งาน element.parentElement จะคืนค่า null กลับมา&lt;/p&gt;

&lt;h2 id=&quot;elementclosest&quot;&gt;element.closest&lt;/h2&gt;

&lt;p&gt;คำสั่งนี้เป็นส่วนหนึ่งในภาษาสคริปที่อนุญาตให้เราเลือก parent element ที่อยู่ใกล้กันกับ element ที่เราเลือกอยู่โดยการใช้ CSS Selector การใช้งานใช้งานได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;element.closest(&quot;CSS selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ยกตัวอย่างโดยเอารูปเดิมมาใช้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.closest(&apos;div&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์ตามข้างบนนี้แล้ว เราจะเลือก parent element ที่เป็น div ครับ เมื่อสังเกตตัวโค้ดแล้วพบว่าใช้งานได้สะดวกมากกว่า node.parentNode กับ element.parentElement&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดีการใช้งานทั้งสามคำสั่งได้แก่ node.parentNode, element.parentElement และ element.closest นี้ขึ้นกับผู้ใช้ว่าจะเอาไปใช้อย่างไรครับ ส่วนกรณีที่ผู้ใช้ไม่ได้ใช้ Vanilla JavaScript  คำสั่งทั้งสามคำสั่งนี้อาจจะไม่ได้ใช้เลยก็ได้ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="Element" /><category term="Selector" /><category term="Parent Element" /><category term="Programming" /><category term="getElementById" /><category term="getElementsByClassName" /><category term="getElementsByName" /><category term="getElementsByTagName" /><category term="querySelector" /><category term="querySelectorAll" /><category term="Node" /><category term="Parent Node" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วัตถุ" /><summary type="html">บทความนี้แนะนำวิธีการเลือกวัตถุ parent element ด้วยการใช้ภาษา JavaScript</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python</title><link href="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/" rel="alternate" type="text/html" title="วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python" /><published>2021-12-08T00:30:00+07:00</published><updated>2021-12-08T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/10/interpupillary-distance=measurement-python</id><content type="html" xml:base="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/">&lt;p&gt;อันนี้เป็นส่วนหนึ่งของงานวิจัย ทำไปแล้วบางส่วน&lt;/p&gt;

&lt;p&gt;ปกติการวัดตาดำ เราจะพบได้ในคนที่เลือกขนาดเครื่อง Virtual Reality Headset หรือวัดขนาดแว่นตา หรืออื่น ๆ ปกติเราจะใช้ไม้บรรทัดวัดเพื่อให้รู้ว่าระยะห่างระหว่างตาดำ (Interpupillary Distance) มีระยะห่างเท่าไร อย่างไรก็ดีเราจะใช้ไม้บรรทัดวัดไปตลอดเหรอก็ไม่สะดวกเท่าไร แถมสมัยนี้เราก็ใช้คอมพิวเตอร์กันอยู่แล้วด้วย เลยเอามาเขียนโค้ดส่วนนี้เพื่อจับระยะการอ้าปากครับ&lt;/p&gt;

&lt;p&gt;หลักการวัดจากภาพดิจิทัล โดยปกติเวลาที่เราวัดจะได้หน่วยการวัดเป็น pixel แต่สิ่งที่เราต้องการก็คือ ต้องการการวัดที่มีหน่วยเป็นเซนติเมตร หรือมิลลิเมตรที่ตัวโปรแกรมวัดด้วยตัวเองไม่ได้ เราจำเป็นต้องหาวัตถุอ้างอิงเพื่อเป็น Reference สำหรับการแปลงหน่วยจาก pixel เป็นหน่วยที่เราวัดครับ&lt;/p&gt;

&lt;p&gt;ในตัวอย่างนี้ เราจะใช้บัตรประชาชนซึ่งเป็นสิ่งที่คนทุกคนมีกันอยู่แล้ว (ยกเว้นเด็กเล็ก) เป็นวัตถุ Reference ใช้สำหรับการวัดในครั้งนี้ ขนาดของบัตรประชาชน (ไทย) มีขนาดที่เป็นมาตรฐาน โดนมีขนาดด้านยาว 86 mm ด้านกว้าง 54 mm เราจะใช้ด้านยาวเป็น Reference&lt;/p&gt;

&lt;p&gt;แต่ก่อนที่จะไปวัด เราจะต้องแยกส่วน (Segment) บัตรประชาชนออกจากวัตถุอื่นในภาพก่อน แล้วจะทำอย่างไรดี หลักการนี้เรียกว่า Image Segmentation&lt;/p&gt;

&lt;h2 id=&quot;image-segmentation&quot;&gt;Image Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/mask_rcnn_segmentation.png&quot; alt=&quot;Image Segmentation&quot; /&gt;
ภาพตัวอย่างการ Segmentation จากเปเปอร์​ Mask R-CNN&lt;/p&gt;

&lt;p&gt;Image Segmentation เป็นหลักการจำแนก pixel ของวัตถุที่เราต้องการออกมาจากวัตถุอื่นในภาพดิจิทัล โดยยกตัวอย่างเช่นระบบการขับรถอัตโนมัติ (self-driving car) ที่จับคนในภาพเพื่อป้องกันไม่ให้เกิดอุบัติเหตุครับ หลักการนี้แบ่งออกมาได้เป็นสองวิธีได้แก่ Semantic Segmentation และ Instance Segmentation&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Semantic Segmentation เป็นการแยกวัตถุออกจากภาพวัตถุอื่นโดยการแบ่งประเภทของวัตถุ (class) จากภาพ ได้แก่ สีแดงเป็นคน สีน้ำเงินเป็นรถ เป็นต้น&lt;/li&gt;
  &lt;li&gt;Instance Segmentation เป็นการแบ่งวัตถุแต่ละชิ้นในภาพ ที่แตกต่างกับ Semantic Segmentation ที่แบ่งเป็นวัตถุที่ 1,2,3,4 เป็นต้น&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ตัวอย่างของเทคนิคที่ใช้ Image Segmentation คือ Mask R-CNN, U-NET ครับ&lt;/p&gt;

&lt;h2 id=&quot;u-net&quot;&gt;U-NET&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_artchitecture.png&quot; alt=&quot;U-NET Architecture&quot; /&gt;
ภาพโครงสร้าง U-NET&lt;/p&gt;

&lt;p&gt;U-NET ที่เป็นคนละอันกันกับ O-NET ที่สอบมัธยมศึกษาตอนปลายเข้ามหาวิทยาลัยที่จัดโดยสทศ ครับ&lt;/p&gt;

&lt;p&gt;U-NET เป็นโครงข่ายประสาทเทียม (Neural Network Architecture) แบบ Convolutional Neural Network ที่ให้ผลลัพธ์เป็น Matrix ที่มีขนาดกว้าง x ยาวเท่ากันกับภาพเดิม โดยในแต่ละตำแหน่งจะระบุได้ว่าเป็น 0 (ไม่มีภาพ Object) หรือ 1 (มี Object) ในภาพ&lt;/p&gt;

&lt;p&gt;โครงสร้างของเครือข่ายประสาท U-NET เราจะเห็นว่าเป็นรูปตัว U (U-shape) ที่แบ่งเป็นสองช่วง ได้แก่ Contracting Path (ด้านซ้าย) และ Upsampling Path (ด้านขวา) เราจะอธิบายในแต่ละส่วนตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h3 id=&quot;contract-path&quot;&gt;Contract Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_downsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Contract Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;3x3 Convolutions (ที่ไม่มี Padding) 2 รอบ&lt;/li&gt;
  &lt;li&gt;ตามมาด้วย Activation Function ReLU&lt;/li&gt;
  &lt;li&gt;ใช้ 2x2 Max Pooling ที่มี Stride 2 เพื่อ Down Sampling ระหว่างที่ทำ Down Sampling เราจะเพิ่มจำนวน Feature Channel เป็น 2 เท่าในแต่ละครั้ง&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;upsampling-path&quot;&gt;Upsampling Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_upsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Upsampling Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Up Sampling แล้วตามด้วย 2x2 Convolutions (หรือเรียกอีกอย่างว่า “up-convolution”) ที่แบ่งครึ่งจำนวน Channels&lt;/li&gt;
  &lt;li&gt;นำภาพที่ได้จากขั้นตอนการทำ 3x3 Convolutions + ReLU ใน Contract Path ที่ผ่านการ Cropped แล้วมา Concatenate&lt;/li&gt;
  &lt;li&gt;ทำ 3x3 Convolutions สองรอบ แล้วตามด้วย ReLU&lt;/li&gt;
  &lt;li&gt;ทำไปจนกระทั่งถึง Layer สุดท้าย เราทำ 1x1 Convolution เพื่อนำ 64 Component Feature Vector ให้เป็นจำนวน Classes ที่เราต้องการ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;จำนวน Convolutional Layer ทั้งหมดที่ใช้ใน U-NET มีทั้งหมด 23 Layers ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลเพิ่มเติมของ U-NET ผู้อ่านศึกษาได้ใน&lt;a href=&quot;https://arxiv.org/abs/1505.04597&quot;&gt;เปเปอร์ U-Net: Convolutional Networks for Biomedical Image Segmentation จากเว็บ arXiv&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h2 id=&quot;midv-500&quot;&gt;MIDV-500&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/midv_500.png&quot; alt=&quot;MIDV-500 Dataset&quot; /&gt;
ตัวอย่างรูปภาพในฐานข้อมูล MIDV-500&lt;/p&gt;

&lt;p&gt;MIDV-500 หรือเรียกอีกอย่างว่า Mobile Identity Document Video dataset ที่ประกอบไปด้วยวิดีโอ 500 ชิ้นที่มีเอกสารยืนยันตัวตนทั้งหมด 50 ชนิดที่สร้างขึ้นโดยใช้กล้องโทรศัพท์มือถืออย่าง iPhone 5, Samsung Galaxy S3 ที่บันทึกในสภาพแวดล้อม 5 รูปแบบ ได้แก่ ภาพวางบนโต๊ะ บนคีย์บอร์ด และบนมือ ภาพที่ถูกบังบางส่วน รวมถึงภาพที่มีพื้นหลังทีมีวัตถุต่าง ๆ เต็มหน้าจอที่ไม่เกี่ยวข้อง&lt;/p&gt;

&lt;p&gt;ในภาพที่บันทึกได้ จะไม่มีข้อมูลสำคัญ หรือข้อมูลที่ไว้ก็อปปี้สำหรับการทำบัตรปลอมได้ จุดนี้เป็นปัญหาสำคัญที่ไม่มีฐานข้อมูลในลักษณะนี้มาก่อนครับ&lt;/p&gt;

&lt;p&gt;สำหรับผู้อ่านที่ต้องการอ่านเพิ่มเติม สามารถอ่านได้ใน&lt;a href=&quot;https://arxiv.org/abs/1807.05786&quot;&gt;เปเปอร์ MIDV-500: a dataset for identity document analysis and recognition on mobile devices in video stream จากเว็บ arXiv&lt;/a&gt; ครับ และกรณีที่ต้องการดาวน์โหลดฐานข้อมูลไว้ใช้งาน สามารถดาวน์โหลดได้ที่ &lt;a href=&quot;https://github.com/fcakyon/midv500&quot;&gt;Github&lt;/a&gt; หรือดาวน์โหลดผ่านการติดตั้งไลบรารีใน pip ของไพทอน โดยพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install midv500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวไพทอนจะติดตั้งไลบรารี MIDV-500 ไว้ใช้งาน ตัวไลบรารีสามารถแปลงข้อมูล Annotation ของฐานข้อมูล MIDV-500 ให้อยู่ในรูปแบบของ COCO instance segmentation format&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ ฐานข้อมูลได้รับการพัฒนาขึ้นมาให้เป็นเวอร์ชันใหม่ โดยฐานข้อมูลที่สร้างขึ้นมาใหม่มีชื่อว่า &lt;a href=&quot;https://www.spiedigitallibrary.org/conference-proceedings-of-spie/11433/2558438/MIDV-2019--challenges-of-the-modern-mobile-based-document/10.1117/12.2558438.short?SSO=1&quot;&gt;MIDV-2019&lt;/a&gt; ครับ ฐานข้อมูลนี้แก้ปัญหาเรื่อง Projective Distortion และสภาพแสงสว่างที่แตกต่างกันไป&lt;/p&gt;

&lt;h2 id=&quot;เขียนโค้ดกัน&quot;&gt;เขียนโค้ดกัน&lt;/h2&gt;

&lt;p&gt;เราเขียนโค้ดเพื่อที่จะวัดระยะห่างระหว่างตาดำ การเขียนโค้ดจะมีขั้นตอนดังนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;จับภาพใบหน้า (Face detection)&lt;/li&gt;
  &lt;li&gt;Calibrate ระยะการวัด Pixel ต่อ mm โดยแยกส่วนบัตรประชาชนจากภาพ โดยให้ถือบัตรประชาชนให้ชิดริมฝีปากของผู้ที่ต้องการวัดภาพ&lt;/li&gt;
  &lt;li&gt;จับภาพจุดแลนมาร์คบริเวณดวงตา หรือตาดำ (Facial Landmark Detection)&lt;/li&gt;
  &lt;li&gt;วัดระยะห่างระหว่างตาดำ (Interpupillary Distance)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เราเขียนโค้ดใน Google Colab ได้เลยครับ ผู้อ่านสามารถ&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/ipd_measurement.ipynb&quot;&gt;ดาวน์โหลดไฟล์ ipynb&lt;/a&gt; มาทดลองรันบน Google Colab หรืออื่น ๆ ได้ครับ&lt;/p&gt;

&lt;h3 id=&quot;จับภาพใบหน้า-face-detection&quot;&gt;จับภาพใบหน้า (Face Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/face_detection_python.jpg&quot; alt=&quot;Face Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับภาพใบหน้า หรือเรียกอีกอย่างว่า Face Detection คือการหาตำแหน่ง Face Regions of Interest จากภาพ โดยมีหลายเทคนิคที่เราสามารถใช้ได้เลย ตั้งแต่ Viola-Jones ที่พบได้ในคำสั่งบน OpenCV ที่คนโพสกันไปเยอะมาก หรือใช้เทคนิค dlib หรืออื่น ๆ ครับ อย่างไรก็ดี เราต้องพิจารณาความแม่นยำ ข้อดี ข้อเสียของแต่ละเทคนิค&lt;/p&gt;

&lt;p&gt;ในที่นี้ จะใช้เทคนิค FaceBoxes ครับ&lt;/p&gt;

&lt;h3 id=&quot;การจับจุดแลนมาร์คบนใบหน้า-facial-landmark-detection&quot;&gt;การจับจุดแลนมาร์คบนใบหน้า (Facial Landmark Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/dlib_facial_landmark.jpeg&quot; alt=&quot;Facial Landmark Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับจุดแลนมาร์คบนใบหน้า หรือเรียกอีกอย่างว่า Facial Landmark Detection เป็นการจับตำแหน่งอวัยวะบนใบหน้าเพื่อใช้สำหรับการประมวลผลในขั้นตอนต่อไป มีหลายเทคนิคที่ใช้ ตั้งแต่รุ่นเก่าเลยก็เป็น Active Appearance Models, Constrained Local Models หรืออื่น ๆ แต่ถ้าเอาง่ายหน่อยก็เป็น dlib (จากเปเปอร์ Ensemble of Regression Trees) หรือ FaceMesh หรืออื่น ๆ&lt;/p&gt;

&lt;p&gt;ในตัวอย่าง เราใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;h3 id=&quot;calibrate-ระยะการวัด-pixel-และหาระยะห่างระหว่างตาดำ&quot;&gt;Calibrate ระยะการวัด Pixel และหาระยะห่างระหว่างตาดำ&lt;/h3&gt;

&lt;p&gt;เอาล่ะ มาเขียนโค้ดกันดีกว่า เราติดตั้งไลบรารีที่จำเป็นโดยการใช้ pip แต่สำหรับการทำ Calibrate เราใช้ไลบรารี&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenCV&lt;/li&gt;
  &lt;li&gt;Numpy&lt;/li&gt;
  &lt;li&gt;PyTorch&lt;/li&gt;
  &lt;li&gt;iglovikov_helper_functions&lt;/li&gt;
  &lt;li&gt;midv500models&lt;/li&gt;
  &lt;li&gt;imutils&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ติดตั้งเสร็จแล้ว อัพโหลดภาพเข้า Google Colab จากนั้นนำเข้าภาพโดยใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = cv2.imread(&quot;&amp;lt; Image Path &amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab โดยใช้ภาพเราถือบัตรเองที่อัพโหลดเข้าไประบบ จะได้ภาพตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_input.png&quot; alt=&quot;Input Colab Image&quot; /&gt;
ภาพที่จะใช้ทำ Calibrate และหาระยะห่างระหว่างตาดำทั้งสองข้าง&lt;/p&gt;

&lt;p&gt;ต่อมา เรานำภาพผ่านการจับใบหน้าโดยใช้เทคนิค Face Detection และอะไรก็ได้เพื่อหา Face Regions of Interest ครับ โดยการใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = img[..., ::-1]
boxes = face_boxes(img)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมาเรานำ Face Regions of Interest (ที่อยู่ในตัวแปร boxes) ไปประยุกต์ใช้ต่อสำหรับการทำ Calibrate เรานำเข้าไลบรารีได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import albumentations as albu
import torch

from iglovikov_helper_functions.utils.image_utils import load_rgb, pad, unpad
from iglovikov_helper_functions.dl.pytorch.utils import tensor_from_rgb_image

from midv500models.pre_trained_models import create_model
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ดาวน์โหลดโมเดล U-NET มาใช้งาน โดยใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = create_model(&quot;Unet_resnet34_2020-05-19&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;กำหนดตัวโมเดลสำหรับการจับภาพที่ไม่ได้เทรนใหม่ (Evaluation model) และนำภาพที่เราจับภาพใบหน้ามาแล้วที่เป็นตำแหน่งแรกมาแยกส่วนบัตรประชาชน เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model.eval()
boxes = [boxes[0]]
size_box = len(boxes)
box = boxes[0]

[x1, y1, x2, y2] = box[:4]
x1 = int(x1)
y1 = int(y1)
x2 = int(x2)
y2 = int(y2)

# Segment Image
image = img[y1:y2,x1:x2].copy()
transform = albu.Compose([albu.Normalize(p=1)], p=1)
padded_image, pads = pad(image, factor=32, border=cv2.BORDER_CONSTANT)

# Inference
x = transform(image=padded_image)[&quot;image&quot;]
x = torch.unsqueeze(tensor_from_rgb_image(x), 0)
with torch.no_grad():
    prediction = model(x)[0][0]

# Postprocessing
mask = (prediction &amp;gt; 0).cpu().numpy().astype(np.uint8)
mask = unpad(mask, pads)
mask = mask * 255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราแยกส่วนบัตรประชาชนออกมาแล้วในรูปแบบตัวแปร mask ในตัวโค้ดจะออกมาเป็นอาเรย์ที่มีขนาดเท่าภาพต้นฉบับที่มีตัวแปรระหว่าง 0 กับ 1 แต่ภาพขาวดำปกติมันมีตั้งแต่ 0-255 (8-bit) เรานำ 255 มาคูณตามด้านบน&lt;/p&gt;

&lt;p&gt;หลังจากแยกส่วนแล้ว เราต้องการหาความยาวด้านยาวเป็นจำนวน Pixel เราจำเป็นต้องหา Contour ของภาพ โดยใช้คำสั่ง cv2.findContours แล้วเรียง Contour จากบนลงล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Contour
contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
(cnts, boundingBoxes) = contour.sort_contours(contours, method=&quot;top-to-bottom&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเรียงมาเรียบร้อยแล้ว เราหาความยาวด้านยาวของบัตรประชาชนที่แยกมาได้ โดยใช้คำสั่ง cv2.boundingRect&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# find boundingRect
target_cnt = cnts[0]
x,y,w,h = cv2.boundingRect(target_cnt)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้ความยาวมาเรียบร้อย เราแปลงให้อยู่ในรูปอัตราส่วนจำนวน pixel ต่อ mm ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Card size in pixels (compare to 86mm on long size)
distance = w
distancepermm = distance / 86
print(f&quot;card size (pixel) = { distance } compare to (mm) = 85 mm =&amp;gt; distance { distancepermm } pixels/mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab เราจะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_calibrate.png&quot; alt=&quot;Calibrated Colab Image&quot; /&gt;
ภาพหลังการทำ Calibrate&lt;/p&gt;

&lt;p&gt;ต่อมา ในขั้นตอนต่อไป เป็นการหาตำแหน่งอวัยวะบนใบหน้า (Facial Landmark Detection) เราเอาภาพเดิมที่ผ่านการจับภาพใบหน้า (Face Detection) มาใช้งาน ได้ตามโค้ดด้านล่างนี้ที่ใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param_lst, roi_box_lst = tddfa(img, boxes)
ver_lst = tddfa.recon_vers(param_lst, roi_box_lst, dense_flag=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้จุดบนใบหน้า 68 จุดออกมา แต่อาเรย์ของ ver_lst อยู่ในรูปแบบอาเรย์ที่มี Shape = [3, 68] เราจำเป็นต้องแปลงให้อยู่ในรูปแบบ Shape = [68, 3] เสียก่อน ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = first_landmark[0,:].reshape(-1, 1)
y = first_landmark[1,:].reshape(-1, 1)
landmark = np.concatenate([x,y], axis = 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้ว เราจำเป็นต้องหาตำแหน่งตาดำตรงกลางเพื่อหาระยะห่างระหว่างตาดำ แต่ก่อนอื่น เรามาหาตำแหน่งรอบตาดำ และตาขาวก่อน จากภาพนี้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/09/68-facial-landmarks.jpg&quot; alt=&quot;Facial Landmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;จุดบนอวัยวะบนใบหน้าทั้งหมด 68 จุด&lt;/p&gt;

&lt;p&gt;เรานำจุดบนอวัยวะบนใบหน้าตำแหน่งที่ 37-42 สำหรับตาขวา และตำแหน่งที่ 43-48 สำหรับตาซ้าย เพื่อนำมาหาตำแหน่งตาดำตรงกลางสำหรับการหาระยะห่างระหว่างตาดำ ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;righteye = landmark[36:42]
rightiris = np.array([np.mean(righteye[:, 0]), np.mean(righteye[:, 1])])
lefteye = landmark[42:48]
leftiris = np.array([np.mean(lefteye[:, 0]), np.mean(lefteye[:, 1])])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เราหาระยะห่างระหว่างตาดำทั้งสองข้างได้โดยนำค่า pixel ของภาพต่อระยะห่างที่เป็นหน่วย mm ที่ได้จากการทำ Calibrate มาใช้งานตามโค้ดด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find IPD
interpupillary_distance = 0.0
for i in range(2):
    interpupillary_distance += (rightiris[i] - leftiris[i])**2
interpupillary_distance = np.sqrt(interpupillary_distance)
interpupillary_distance_mm = interpupillary_distance / distancepermm
print(f&quot;Interpupillary Distance = { interpupillary_distance } which equals = { interpupillary_distance_mm } mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทดลองเริ่มต้นการทำงาน จะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_result.png&quot; alt=&quot;Interpupillary Distance Result&quot; /&gt;
ผลลัพธ์ที่ได้&lt;/p&gt;

&lt;p&gt;ฟังดูแล้วไม่ยากเกินไปใช่ไหมล่ะครับ สำหรับผู้อ่านวิธีการวัดระยะห่างระหว่างตาดำ (Interpupillary Distance) วิธีนี้เป็นวิธีหนึ่งแค่นั้นครับ&lt;/p&gt;

&lt;p&gt;และอีกอย่าง เทคนิคนี้ยังไม่ได้ทดสอบความแม่นยำกับคนอื่น ๆ (ยกเว้นผู้เขียนเอง) เลยอาจจะต้องเอาไปทดสอบก่อนที่จะนำไปใช้งานบน Production จริงครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Mouth Opening" /><category term="Iris" /><category term="Interpupillary Distance" /><category term="Measurement" /><category term="Programming" /><category term="Machine Learning" /><category term="Computer Vision" /><category term="Segmentation" /><category term="Face Detection" /><category term="Calibration" /><category term="U-NET" /><category term="Deep Learning" /><category term="3DDFA_V2" /><category term="FaceBoxes" /><category term="Face Detection" /><category term="Landmark Detection" /><category term="Artificial Intelligence" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ตาดำ" /><category term="การวัด" /><category term="คอมพิวเตอร์วิทัศน์" /><summary type="html">บทความนี้แนะนำวิธีการวัดระยะห่างระหว่างตาดำโดยใช้ภาษา Python จากภาพดิจิทัลครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token</title><link href="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/" rel="alternate" type="text/html" title="ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token" /><published>2021-12-01T00:30:00+07:00</published><updated>2021-12-01T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/01/implement-httponly-cookie-token-nodejs-express</id><content type="html" xml:base="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/">&lt;p&gt;เดิมทีเวลาที่เราใช้งานเพื่อเข้าสู่ระบบ เราจะเขียนโค้ดเพื่อขอ Access Token จากเซิร์ฟเวอร์แล้วนำมาเก็บไว้บน Client เพื่อนำมาใช้งานระบบที่จำเป็น โดยใน&lt;a href=&quot;https://www.howtographql.com/react-apollo/5-authentication/&quot;&gt;บทความบนเว็บที่เกี่ยวกับการทำระบบ Authentication โดยใช้ไลบรารี Apollo GraphQL&lt;/a&gt; นั้น เราจะเก็บข้อมูล Access Token ที่สร้างขึ้นไว้บน LocalStorage เพื่อนำมาใช้งานต่อครับ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การเก็บข้อมูลไว้ในนี้ก็มีปัญหาเรื่องความปลอดภัย ในบทความนี้จะแนะนำวิธีการเก็บข้อมูล Access Token ที่ปลอดภัยกว่าการเก็บบน LocalStorage ครับ&lt;/p&gt;

&lt;h2 id=&quot;localstorage&quot;&gt;LocalStorage&lt;/h2&gt;

&lt;p&gt;ก่อนอื่น เรามาพูดถึง LocalStorage ก่อน ตัว LocalStorage (หรือเรียกว่า window.localStorage) เป็นส่วนหนึ่งของ HTML5 Web Storage ที่ทำหน้าที่เก็บข้อมูลใส่ไว้บนเว็บเบราวเซอร์ทางฝั่ง Client ที่ข้อมูลยังคงอยู่ ถึงแม้ว่าเราจะปิดหน้าเว็บเบราวเซอร์นั้น ๆ ออกไป หรือข้อมูลหมดอายุตามที่เรากำหนดไว้เอง&lt;/p&gt;

&lt;p&gt;การใช้งาน LocalStorage ทำได้โดยการเก็บข้อมูลตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.setItem(&apos;token&apos;, &amp;lt; Access Token ที่ได้ &amp;gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วเราสามารถเรียกได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let token = localStorage.getItem(&apos;token&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้นข้อมูล Access Token ที่เก็บไว้ในเว็บเบราวเซอร์ก็จะคืนค่าอยู่ในตัวแปร token ครับ ฟังดูแล้วง่ายกว่าที่ดีคิดไว้ เพราะใช้คำสั่งตามที่เขียนไว้ข้างบนนี้ ข้อมูลก็ออกมาได้แล้วครับ อย่างไรก็ดี การเก็บข้อมูลไว้ใน LocalStorage มีข้อเสีย เนื่องมาจาก&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ข้อมูลที่เก็บ สามารถเก็บในรูปแบบ String เท่านั้น&lt;/li&gt;
  &lt;li&gt;มีขนาดที่จำกัดเพียงแค่ 5MB (แต่ข้อมูลข้างบนไม่ถึง 5MB :P)&lt;/li&gt;
  &lt;li&gt;มีปัญหาเรื่องความปลอดภัย เนื่องมาจากอ่านข้อมูลได้ง่ายเพียงใช้คำสั่งเดียวตามที่กล่าวไว้ข้างบน และสามารถดึกข้อมูลได้โดย &lt;a href=&quot;https://michael-coates.blogspot.com/2010/07/html5-local-storage-and-xss.html&quot;&gt;Cross site scripting (XSS)&lt;/a&gt; ครับ&lt;/li&gt;
  &lt;li&gt;อ่านรายละเอียดเพิ่มเติมได้ใน&lt;a href=&quot;https://dev.to/rdegges/please-stop-using-local-storage-1i04&quot;&gt;หน้าเว็บ dev.to ที่มีคนหนึ่งได้เขียนไว้&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ดังนั้นแล้ว ข้อมูลที่เก็บไว้ใน LocalStorage ไม่ควรจะเก็บข้อมูลที่เป็นความลับครับ แล้วเราจะเก็บข้อมูลไว้ที่ไหนดีล่ะ?&lt;/p&gt;

&lt;h2 id=&quot;httponly-cookies&quot;&gt;HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;HTTPOnly Cookies เป็นการตั้งค่าอันหนึ่งที่พบได้ระหว่าการตั้งค่า Set-Cookie HTTP Response Header ที่พบได้ตั้งแต่ Internet Explorer 6 SP1 (เก่ามากและ) โดยข้อมูลนี้เอามาจากบทความใน&lt;a href=&quot;https://owasp.org/www-community/HttpOnly&quot;&gt;หน้าเว็บมูลนิธิ OWASP&lt;/a&gt; ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลที่เป็นความลับ หรือข้อมูลที่ Sensitive มากกว่าปกติ ยกตัวอย่างเช่นข้อมูล Access Token, User ID, Session ID, ข้อมูลบัตรเครดิต และอื่น ๆ ที่เราต้องการให้แชร์บน Facebook แบบ Public นั้น เราเก็บช้อมูลใน HTTPOnly Cookies ที่ทำได้ตามขั้นตอนด้านล่างนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เมื่อผู้ใช้เข้าสู่ระบบ เซิร์ฟเวอร์จะสร้างข้อมูล Session ที่จำเป็นขึ้นมาสำหรับการใช้งาน&lt;/li&gt;
  &lt;li&gt;นำข้อมูลที่สร้างขึ้นเก็บอยู่ในรูปแบบ Cookie โดยกำหนดค่าคุกกี้ให้เป็น HTTPOnly เท่านั้น&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ไลบรารีที่รองรับ HTTPOnly Cookies มีหลากหลายไลบรารีมาก ผู้อ่านสามารถหาเพิ่มเติมได้ในอินเตอร์เน็ต แต่ในตัวอย่างนี้ เราจะใช้ไลบรารีที่นิยมอันหนึ่งที่มีชื่อว่า &lt;a href=&quot;https://expressjs.com/&quot;&gt;Express&lt;/a&gt; ที่อยู่ในรูปแบบภาษา JavaScript ที่ทำงานบน Node.js ครับ&lt;/p&gt;

&lt;p&gt;ตัวอย่างของการสร้าง HTTPOnly Cookies ทำได้ตามด้านล่างนี้ครับ แต่ก่อนอื่น เราต้องติดตั้งไลบรารีเหล่านี้ก่อนครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add express dayjs cookie-parser jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อติดตั้งเสร็จแล้ว เราพิมพ์ส่วนนี้เพิ่มเติมลงไปใน package.json&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  [...]
  &quot;type&quot;: &quot;module&quot;,
  [...]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เพื่อให้ใช้งานตามตัวอย่างด้านล่างนี้ได้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import http from &apos;http&apos;;
import express from &apos;express&apos;;
import dayjs from &apos;dayjs&apos;;
import cookieParser from &quot;cookie-parser&quot;;
import jwt from &apos;jsonwebtoken&apos;;

const app = express();
const httpServer = http.createServer(app);

[...]

app.use(cookieParser());

[...]

app.post(&apos;/login&apos;, (req, res, next) =&amp;gt; {

  [...]

  let token = jwt.sign(payload, jwt_secret, { expiresIn: jwt_expire });

  res.cookie(&quot;authorization&quot;, token, {
      secure: true,
      httpOnly: true,
      expires: dayjs().add(1, &quot;days&quot;).toDate(),
      sameSite: &apos;Strict&apos;
  });

  [...]

});

[...]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อดูตัวอย่างจากข้างบนนี้แล้ว ดูตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(cookieParser());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นการเกิดใช้งานตัว cookie-parser Middleware ที่เป็นส่วนหนึ่งของไลบรารี Express ที่อนุญาตให้เราเรียกใช้งาน Cookie header เพื่อดึงข้อมูล HTTPOnly Cookies โดยพิมพ์ว่า req.cookies ครับ&lt;/p&gt;

&lt;p&gt;ในหลายบรรทัดต่อมา ตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie(&quot;token&quot;, token, 
    secure: true,
    httpOnly: true,
    expires: dayjs().add(1, &quot;days&quot;).toDate(),
    sameSite: &apos;Strict&apos;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นคำสั่งที่เรากำหนดค่าอะไรก็ตามลงไปใน Cookie ที่เราได้กำหนดไว้ คือ เรากำหนดค่า Access Token ลงไปใน Cookie token ครับ ส่วนการตั้งค่าที่อยู่ในปีกกานั้นเป็นการตั้งค่า Cookie นี้ให้&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;secure เป็นการตั้งค่าให้ใช้งานผ่าน HTTPS เท่านั้น&lt;/li&gt;
  &lt;li&gt;httpOnly เป็นการตั้งค่าให้ cookie ตัวนี้เรียกใช้งานโดยเว็บเซิร์ฟเวอร์ได้เท่านั้น&lt;/li&gt;
  &lt;li&gt;expires เป็นการตั้งค่าระยะเวลาหมดอายุ ตามคำสั่งที่เขียนข้างบนกำหนดให้มีอายุ 1 วัน&lt;/li&gt;
  &lt;li&gt;sameSite ตั้งค่าให้เพิ่ม SameSite ใน Set-Cookie HTTP Header มีด้วยกันสองแบบได้แก่ Strict ที่ผ่านทางเว็บไซต์เราเท่านั้น หรือ Lax ที่ส่ง Cookie ผ่านเว็บไซต์อื่นได้ ผ่าน HTTP Get บน Address Bar (เช่นการกด Link)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ส่วนการตั้งค่าเพิ่มเติมที่เราไม่ได้กำหนดค่าไว้ มีได้แก่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;domain กำหนดโดเมนเนม ในที่นี้ให้โดเมนเนมเดียวกันกับ app&lt;/li&gt;
  &lt;li&gt;encode เป็นฟังก์ชันที่กำหนด encoding
เป็นต้น โดยการตั้งต่าเพิ่มเติมนี้ ผู้อ่านสามารถเข้าไปดูได้ใน &lt;a href=&quot;https://expressjs.com/en/api.html&quot;&gt;Reference ของ Express&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เมื่อเราเรียกใช้งานผ่านคำสั่งอย่าง fetch, XMLHttpRequest หรืออื่น ๆ เราดู HTTPOnly Cookies ได้ที่หน้า Developer Tools -&amp;gt; Application -&amp;gt; Storage -&amp;gt; Cookies -&amp;gt; ที่อยู่เว็บไซต์ -&amp;gt; เราจะพบ HTTPOnly Cookies ที่เราได้สร้างขึ้นครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot; alt=&quot;HTTPOnly Cookies บน Developer Tools&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPOnly Cookies บน Developer Tools (&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot;&gt;ดูรูปเต็ม&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ดูตรง Authorization เราจะพบว่า Cookie ที่สร้างนี้อันนี้เป็น HTTPOnly Cookies ครับ แล้วเวลาที่ใช้งานจริง เราจะเรียกใช้งานอย่างไรดีล่ะ?&lt;/p&gt;

&lt;p&gt;เราเรียกใช้งานได้โดยผ่านการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(&apos;/isloggedin&apos;, (req, res, next) =&amp;gt; {
  
  [...]

  let token = req.cookies.authorization;

  [...]

});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง req.cookies.authorization อันนี้แหละ เป็นการเรียกใช้งาน HTTPOnly Cookies ที่เราสร้างชึ้นครับ อย่างไรก็ดี กรณีที่เราใช้งานผ่าน Apollo Server GraphQL เรายังเรียก HTTPOnly Cookies ได้อยู่ไหม คำตอบคือ ทำได้สบายมาก เพียงแต่เราต้องมาพิมพ์คำสั่งใน context ที่สร้างขึ้น&lt;/p&gt;

&lt;p&gt;เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ApolloServer } from &apos;apollo-server-express&apos;;
import { ApolloServerPluginDrainHttpServer } from &apos;apollo-server-core&apos;;

[...]

const apollo_server = new ApolloServer({ 
  typeDefs,
  resolvers,
  plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
  context: ({ req }) =&amp;gt; {
    let token = req.cookies.authorization || &apos;&apos;;
    return {
      token
    };
  }
});

[...]

apollo_server.applyMiddleware({ &quot;app&quot;: express_app });

[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง context ที่อยู่ใน new ApolloServer({ … }) อันนี้แหละมีส่วนที่เราเรียกใช้งาน HTTPOnly Cookies ครับ ส่วนไลบรารีอื่น ผู้อ่านสามารถหาอ่านได้ในอินเตอร์เน็ตเพิ่มเติมครับ&lt;/p&gt;

&lt;h2 id=&quot;ประโยชน์การใช้-httponly-cookies&quot;&gt;ประโยชน์การใช้ HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;ประโยชน์ของการใช้งาน HTTPOnly Cookies ตามที่เขียนในเว็บ &lt;a href=&quot;https://blog.codinghorror.com/protecting-your-cookies-httponly/&quot;&gt;CodingHorror&lt;/a&gt; หรืออื่น ๆ ได้แก่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTPOnly Cookies จำกัดให้เรียกใช้งานผ่านเว็บเซิร์ฟเวอร์เท่านั้น เราจะใช้งานผ่าน document.cookie ไม่ได้&lt;/li&gt;
  &lt;li&gt;ป้องกันการเกิด Cross-site Scripting (XSS) ดังนั้นแล้ว เวลาที่เรียกใช้งาน fetch, XMLHttpRequest หรืออื่น ๆ จะกระทำได้โดยผ่านโดเมนเดียวกันกับเว็บเซิร์ฟเวอร์เท่านั้น&lt;/li&gt;
  &lt;li&gt;ตามที่เขียนข้างบนนี้มีเขียนให้ใช้ Same-site Cookie ที่ใช้งานได้เฉพาะเว็บเราเท่านั้น ทำให้เรียกใช้ผ่านเว็บอื่นไม่ได้ ส่วนนี้จะป้องกัน Cross site request forgery (CSRF) ครับ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;และอื่น ๆ&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;จากตัวอย่างจะพบว่าเราใช้งาน HTTPOnly Cookies โดยใช้งานบน Node.js ที่ใช้ไลบรารี Express ได้เพียงไม่กี่คำสั่งเท่านั้น เมื่อใช้งานแล้วทำให้เว็บไซต์ของเราปลอดภัยขึ้นมากกว่าเดิมครับ อย่างไรก็ดี อันนี้เป็นส่วนหนึ่งที่ทำให้เว็บของเราปลอดภัยตรับ จะต้องพิจารณาการเขียนโค้ดส่วนอื่นร่วมด้วยว่ามีช่องโหว่หรือไม่ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="HTTPOnly" /><category term="Developer" /><category term="HTTP" /><category term="Cookies" /><category term="Secure" /><category term="Security" /><category term="Token" /><category term="JWT" /><category term="JavaScript" /><category term="Coding" /><category term="GraphQL" /><category term="API" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ความปลอดภัย" /><category term="โทเค็น" /><summary type="html">บทความนี้แนะนำวิธีการเก็บ Access Token ที่ปลอดภัยกว่าการเก็บใน LocalStorage ด้วย HTTPOnly Cookies บน Node.js</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">สรุปบางส่วนจากสเปช How to Become a Web 3 Developer</title><link href="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/" rel="alternate" type="text/html" title="สรุปบางส่วนจากสเปช How to Become a Web 3 Developer" /><published>2021-11-26T00:30:00+07:00</published><updated>2021-11-26T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/11/26/how-to-be-web3-developer</id><content type="html" xml:base="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/">&lt;p&gt;เมื่อวันก่อนเปิดทวิตเตอร์เจอสเปชของทางเว็บ &lt;a href=&quot;https://hashnode.com&quot;&gt;Hashnode&lt;/a&gt; ที่มีหัวข้อว่า How to Become a Web 3 Developer หรือแปลเป็นภาษาไทยว่าวิธีการเป็นนักพัฒนาเว็บ 3.0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hashnode เป็นเว็บที่อนุญาตให้คนเขัยนบทความที่เกี่ยวข้องกับการเขัยนโปรแกรมได้ แถมเราสามารถลิ้งค์โดเมนเนมที่เราจดไว้แล้วกับหน้าบล็อกนี้ได้เลย 
จุดนี้นึกถึงเว็บ Medium ครับ แต่อันนี้สำหรับนักพัฒนาโปรแกรม ใครสนใจเข้าไปสมัครสมาชิกและเขียนบทความได้ฟรี&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ก่อนที่เราจะไปถึงสรุป เรามาพูดถึงเว็บ 3.0&lt;/p&gt;

&lt;h2 id=&quot;web-3&quot;&gt;Web 3&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/cryptocurrency.jpg&quot; alt=&quot;Cryptocurrency&quot; /&gt;
เงินคริปโตเป็นส่วนหนึ่งของ Blockchain ที่เกี่ยวข้องกับ Web 3.0&lt;/p&gt;

&lt;p&gt;Web 3 หรือเรียกว่า Web 3.0 มีคำนิยามตามที่ Tim Berners-Lee ให้ไว้ว่ามันจะเป็น The next generation of internet ที่ตัวเว็บจะกลายเป็น Semantic Web ที่มีความฉลาดมากขึ้น ทำงานได้อัตโนมัติ ทำได้งานด้าน AI, Machine Learning, Blockchain และเทคโนโลยีอัจฉริยะอื่น ทำงานได้ดีมากขึ้นกว่าเดิม&lt;/p&gt;

&lt;p&gt;นอกจากนี้ ทาง Berners-Lee ให้นิยามไว้เพิ่มเติมว่า Web 3.0 จะเป็นเครือข่ายที่อนุญาตให้ผู้อ่านสามารถสร้างคอนเท้นต์ได้โดยไม่จำเป็นต้องพึ่งทางผู้ให้บริการ ทางรัฐ หรืออื่น ๆ ก็คือจะมีความเป็น Decentralize มากขึ้นกว่าเดิม สิ่งนี้เหมือนกับเทคโนโลยีของ Blockchain ทางด้าน Cryptocurrency ตรับ&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถอ่านเพิ่มเติมได้ที่บทความในเว็บ&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2020/01/06/what-is-web-3-0/?sh=3831244258df&quot;&gt;Forbes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://slate.com/technology/2021/11/web3-explained-crypto-nfts-bored-apes.html&quot;&gt;Slate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;รวมถึงใน&lt;a href=&quot;https://www.youtube.com/results?search_query=web+3.0&quot;&gt;ยูทูป&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;และอื่นๆ ครับ&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงที่สรุปจากสเปชบางส่วนครับ&lt;/p&gt;

&lt;h2 id=&quot;สรุปจากสเปช&quot;&gt;สรุปจากสเปช&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/web3_space.jpg&quot; alt=&quot;Web 3.0 Space&quot; /&gt;&lt;/p&gt;

&lt;p&gt;สเปชนี้จะเป็นสเปชที่เปิดให้คนกดยกมือเข้าไปถามได้ อันนี้นึกถึง &lt;a href=&quot;https://nickuntitled.com/2021/02/18/talk-about-clubhouse/&quot;&gt;Clubhouse&lt;/a&gt; ตรับ เพียงแต่อันนี้มีบนทวิตเตอร์มาระยะหนึ่งแล้ว และไม่เป็น&lt;a href=&quot;https://twitter.com/search?q=%23สเปซtoxic&amp;amp;src=typed_query&amp;amp;f=top&quot;&gt;สเปช Toxic&lt;/a&gt; ครับ โดยเราจะสรุปบางส่วนได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;นักพัฒนา Web 3.0 ไม่จำเป็นต้องเชี่ยวชาญ Web 2.0 มาก่อน แต่ถ้าเคยทำเว็บมาก่อนอยู่แล้วจะทำให้เรียนรู้การทำ Web 3.0 ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;การทำเว็บก็ต้องมีความรู้ทางด้านการเขียนโปรแกรม ในสเปชจะกล่าวถึ้งความรู้ทางด้าน HTML, CSS, JavaScript, Object-oriented Programming (OOP) และอื่น ๆ&lt;/li&gt;
  &lt;li&gt;นอกจากความรู้ทางการเขียนโปรแกรมแล้ว ความรู้ทางด้าน Blockchain, Solana, Ethereum, Polygon รวมถึงหลักการ NFT, Smart Contract, Decentralization, Layer 2 เป็นต้น &lt;a href=&quot;https://www.youtube.com/watch?v=qOVAbKKSH10&quot;&gt;ลิ้งยูทูปอันนี้&lt;/a&gt;น่าจะอธิบายเรื่องที่กล่าวมาได้ในระดับหนึ่งครับ&lt;/li&gt;
  &lt;li&gt;อีกอย่าง เรียนรู้การใช้ไลบรารีที่เกี่ยวข้องกับ Web 3.0 ครับ โดยหยิบไลบรารี Open Source มาฝึกได้เลย&lt;/li&gt;
  &lt;li&gt;พอเรีัยนรู้ตามข้างบนไประยะหนึ่งแล้ว การสร้างโปรเจคขึ้นมาเป็นวิธีทำให้เราเรียนรู้ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;เมื่อสร้างโปรเจคแล้ว นำมาเผยแพร่บนอินเตอร์เน็ต โซเชียล รวมถึงเขียนบล็อก บทความบนแพลตฟอร์มอะไรก็ได้เพื่อเผยแพร่โปรเจค ให้ความรู้ (ทางนั้นแนะนำ Hashnode แหม ก็ใครเป็นเจ้าของสเปช) และโพสลงโซเชียลเพื่อทำให้คนรู้จักเรา สร้างคอนเนคชั่นได้ (ที่ไม่ใช่ระบบอุปถัมภ์)&lt;/li&gt;
  &lt;li&gt;สร้าง Resume, CV และมองหาบริษัทที่เปิดรับสมัครงาน&lt;/li&gt;
  &lt;li&gt;ระยะเวลาเริ่มต้นจนทำเว็บ 3.0 เป็น อันนี้ไม่แน่นอน ขึ้นกับคน ถ้ายังไม่มีพื้นฐานอะไรเลย ก็จะช้าหน่อย&lt;/li&gt;
  &lt;li&gt;มี Passion อยากจะเรียนรู้ ใช้เวลาฝึกสม่ำเสมอ สนุกกับมัน&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;สรุปได้คร่าว ๆ ประมาณนี้ครับ ดูจากแต่ละข้อแล้วก็คล้าย ๆ กันกับวิธีการเริ่มการเขียนโปรแกรม หรือวิธีการเริ่มสกิลใหม่สำหรับคนที่ทำงานหนึ่งแล้วต้องการเปลี่ยนสาย เช่นหมอไปเป็นนักบิน เป็นต้น ผู้อ่านสามารถนำสิ่งที่สรุปไปทำตามได้ครับ&lt;/p&gt;

&lt;p&gt;แต่ถ้าผู้อ่านต้องการข้อมูลเพิ่มเติม ผู้อ่านสามารถหาได้ในอินเตอร์เน็ต ยูทูป หนังสือ และอื่น ๆ ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="Web 3.0" /><category term="Developer" /><category term="Programmer" /><category term="Job" /><category term="Career" /><category term="Reskill" /><category term="Hashnode" /><category term="เว็บ" /><category term="เว็บ 3.0" /><category term="เขียนโปรแกรม" /><category term="โปรแกรมเมอร์" /><category term="อาชีพ" /><category term="รีสกิล" /><category term="นักพัฒนาเว็บ" /><summary type="html">เมื่อวันก่อนมีการจัดสเปชของ Hashnode ที่กล่าวถึง How to be Web 3.0 Developer ในบทความนี้สรุปบางส่วนครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Black Friday - ช่วงแอพดี ราคาถูก แล้วบอกต่อ</title><link href="https://nickuntitled.com/2021/11/23/black_friday_app/" rel="alternate" type="text/html" title="Black Friday - ช่วงแอพดี ราคาถูก แล้วบอกต่อ" /><published>2021-11-23T08:23:00+07:00</published><updated>2021-11-23T08:23:00+07:00</updated><id>https://nickuntitled.com/2021/11/23/black-friday-app</id><content type="html" xml:base="https://nickuntitled.com/2021/11/23/black_friday_app/">&lt;p&gt;Black Friday เป็นมหกรรมงาน Sale ลดราคาสินค้าหลายชนิดที่จัดทางฝั่งอเมริกา งานในลักษณะนี้ถ้าให้ใกล้เคียงกันก็เป็นงาน 11.11 12.12 ที่จัดตามเว็บแบบ Lazada Shopee ครับ โดยในช่วงนี้เราจะเห็นว่ามีการจัดโปรโมชันลดราคาแอพลงมาพอสมควร ทำให้เราจับจ่ายใช้สอยซื้อแอพของแท้ได้ง่ายขึ้นมากกว่าเดิมครับ งาน Black Friday งานนี้ปกติทุกปีจะจัดในช่วงวันศุกร์สัปดาห์ที่ 4 ของเดือนพฤศจิกายนครับ โดยปี 2564 ปีนี้จัดขึ้นในวันที่ 26 พฤศจิกายนครับ&lt;/p&gt;

&lt;h2 id=&quot;ที่มาของงานนี้คืออะไร&quot;&gt;ที่มาของงานนี้คืออะไร?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/ddusa_blackfriday.jpg&quot; alt=&quot;Black Friday History&quot; /&gt;&lt;/p&gt;

&lt;center&gt;Black Friday ที่มาภาพจาก &lt;a href=&quot;https://en.wikipedia.org/wiki/Black_Friday_(shopping)&quot;&gt;Wikipedia&lt;/a&gt;&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ที่มาของงานนี้ตามในเว็บของ &lt;a href=&quot;https://www.history.com/news/black-friday-thanksgiving-origins-history&quot;&gt;Histroy&lt;/a&gt; กล่าวว่ามาจากเมืองฟิลาเดลเฟรีย ที่ประชาชนออกมาใช้เงินเป็นจำนวนมากอย่างกับจลาจล จนต้องมีตำรวจเข้ามาควบคุม และคอยระงับเหตุต่าง ๆ ในเมือง เลยเรียกวันนี้ว่า วันศุกร์อันแสนมืดหม่น ครับ แต่ตอนหลังก็ไม่ได้มืดหม่นอะไรแล้วล่ะฮะ เป็นช่วงงานช้อปปิ้งที่สินค้าลดราคาในช่วงนี้แทนครับ&lt;/p&gt;

&lt;h2 id=&quot;แอพที่ลดราคา&quot;&gt;แอพที่ลดราคา&lt;/h2&gt;

&lt;p&gt;ช่วงนี้เงินหายาก จะให้ไปดาวน์โหลดแอพเถื่อนเพื่อป้องกันนายทุนตามในทวิตเตอร์ที่ปรากฏในช่วงนี้ก็คงจะดูไม่ดี แถมการใช้งานแอพเถื่อนก็ยุ่งยากไปหน่อย เพราะเราต้อง Crack หรือลง Patch หรือทำวิธีอื่น ๆ เพื่อให้เราสามารถใช้งานแอพได้โดยไม่ซื้อของแท้ แล้วความเสี่ยงที่เกิดจากการใช้งานแอพเถื่อนก็มีได้แก่ ติดไวรัส ติดมัลแวร์ แอพมีช่องโหว่เนื่องจากแอพไม่ได้รับการอัพเดท ข้อมูลถูกขโมยได้ง่าย ขาดการซัพพอร์ตจากทางผู้ให้บริการ รวมถึงมีความเสี่ยงที่จะถูกจับได้ครับ&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้ว เรามาซื้อของแท้ดีกว่า แต่ก็มีคนบอกว่าไม่อยากจะจ่ายแอพราคาแพง เปลืองเงิน เงินไม่พอ หรือเงินเดือนน้อยจะให้ทำอย่างไร? เราจะบอกว่าช่วงนี้แหละ (รวมถึงช่วงอื่น ถ้าลดราคาครับ) เป็นช่วงที่เหมาะแก่การซื้อแอพเลยครับ เราจะยกตัวอย่างแอพที่ลดราคาในช่วงนี้ตามบทความที่เขียนใน &lt;a href=&quot;https://appleinsider.com/articles/21/11/22/black-friday-software-deals-save-up-to-70-on-adobe-creative-cloud-affinity-photo-parallels&quot;&gt;Apple Insider&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h3 id=&quot;affinity-photo-desginer-publisher&quot;&gt;Affinity Photo, Desginer, Publisher&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/affinity_app.png&quot; alt=&quot;Affinity App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Affinity Photo, Desginer, Publisher&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพนี้เป็นแอพแต่งภาพ ทำงานด้านการออกแบบ หรือถึงทำงานด้านสิ่งพิมพ์ที่พัฒนาโดยบริษัท Serif ที่เป็นหนึ่งในแอพที่นิยมครับ แอพนี้ซื้อครั้งเดียว ใช้งานได้ยาว ๆ ไม่จำเป็นต้องจ่ายรายเดือนแบบที่เราสมัครใช้บริการผ่าน Adobe Creative Cloud ครับ&lt;/p&gt;

&lt;p&gt;ช่วงนี้แอพเหล่านี้ลดราคาลงมา 30% เอาจริง ไม่ได้ลดแค่แอพอย่างเดียว ส่วนเสริมของแอพก็ลดราคา 30% ด้วย ใครที่ลังเลว่าจะซื้อไหม เราแนะนำให้ซื้อครับ ของเราใช้ Affinity Photo แล้วใช้แต่งภาพถ่ายได้ดีครับ&lt;/p&gt;

&lt;p&gt;ซื้อได้ที่ไหน เราแนะนำให้ซื้อผ่าน&lt;a href=&quot;https://affinity.serif.com/en-us/&quot;&gt;หน้าเว็บของผู้ผลิต&lt;/a&gt;ครับ ซื้อแล้วสามารถติดตั้งลงบน macOS, Windows ได้ครับ ส่วน iPad ก็สามารถติดตั้งผ่าน App Store ได้เช่นกัน แต่ไม่มีแอพ Affinity Publisher ครับ&lt;/p&gt;

&lt;h3 id=&quot;parallels&quot;&gt;Parallels&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/parallel_app.png&quot; alt=&quot;Parallels App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Parallels&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพ Parallels ที่เรารู้จักกันเป็นแอพ Parallels Desktop ที่สามารถติดตั้งวินโดว์เพื่อใช้งานบนคอมพิวเตอร์เครื่องแมค ที่มีคนลง Windows 10 on ARM ลงบนคอมพิวเตอร์ Mac ที่ใช้ซีพียู Apple M1, M1 Pro และ M1 Max ครับ ทีนี้ช่วงนี้แอพเหล่านี้ลดราคาลงมา 20% ทำให้เราสามารถซื้อมาใช้งานได้ง่ายขึ้นมากกว่าเดิม&lt;/p&gt;

&lt;p&gt;ไปซื้อได้ในเว็บของ &lt;a href=&quot;https://www.parallels.com&quot;&gt;Parallels&lt;/a&gt; เองตรับ&lt;/p&gt;

&lt;h3 id=&quot;adobe-creative-cloud&quot;&gt;Adobe Creative Cloud&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/adobe_app.png&quot; alt=&quot;Adobe Creative Cloud App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Creative Cloud&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพ Adobe Creative Cloud เป็นแอพกลุ่มที่ใช้งานออกแบบ ตัดต่อวิดีโอ ทำเว็บ หรืออื่น ๆ ที่หลายคนรู้จักกัน ได้แก่ Photoshop, Lightroom, Premiere Pro, Illustrator, AfterEffects หรืออื่น ๆ ที่เดิมจากซื้อขาดมาเปลี่ยนเป็นจ่ายผ่านรายเดือนแทน มีหลายแพคเกจตั้งแต่ Photography Plan จนถึง All Apps&lt;/p&gt;

&lt;p&gt;ที่เห็นในเว็บที่ลดราคาก็มีแพคเกจ All apps ที่ลดราคาสำหรับผู้ที่ใช้งานในปีแรก มีตั้งแต่สำหรับ&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Individual ที่ลดราคาเหลือ 1,143.83 บาทต่อเดือน จากเดิมราคา 2,020.16 บาทต่อเดือน&lt;/li&gt;
  &lt;li&gt;Student and Teachers ที่ลดราคาเหลือ 609.90 บาทต่อเดือน จากเดิมราคา 2,020.16 บาทจ่อเดือน&lt;/li&gt;
  &lt;li&gt;Teams ที่ลดราคาเหลือ 1,386.72 บาท&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ราคาทั้งหมด รวม VAT แล้วครับ&lt;/p&gt;

&lt;p&gt;ใครสนใจ ไปสมัครสมาชิกรายเดือนได้ในเว็บของ &lt;a href=&quot;https://www.adobe.com/th_th/creativecloud.html?mv=affiliate&amp;amp;mv2=red&quot;&gt;Adobe&lt;/a&gt; เองครับ&lt;/p&gt;

&lt;h3 id=&quot;อื่น-ๆ&quot;&gt;อื่น ๆ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/corel_app.png&quot; alt=&quot;Corel App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Corels ครับ&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;นอกเหนือจากสองแอพที่กล่าวมาข้างบน ตามในเว็บนั้นก็มีบอกแอพที่ลดราคาเพิ่มเติมได้แก่&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;แอพกลุ่ม VMWare ที่ลดราคาถึง 40%&lt;/li&gt;
  &lt;li&gt;แอพกลุ่ม Corel ที่ลดราคาพอสมควรเลย ได้แก่ แอพ CorelDraw, Painter 2022, Paintshop Pro 2022 Ultimate, Pinnacle Studio 25 Ultimate และ VideoStudio Ultimate 2021&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ส่วนแอพอื่นที่นอกเหนือจากนั้น ลองเปิดหาในอินเตอร์เน็ตเพิ่มเติมได้ครับ จะมีประกาศลดราคาให้เห็นเอง หรือถ้าลดใน App Store หรือ Play Store ก็จะได้เห็นในนั้นครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Black Friday" /><category term="Sale" /><category term="Discount" /><category term="Cheap" /><category term="App" /><category term="App Store" /><category term="Buying" /><category term="ลดราคา" /><category term="ราคาถูก" /><category term="แอพ" /><category term="โปรแกรม" /><category term="แอพลิเคชัน" /><summary type="html">Black Friday เป็นช่วงที่จัดขึ้นหลัง Thanksgiving Day เป็นช่วงที่สินค้าลดราคาหลายชนิด แอพก็เช่นกัน</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/blackfriday_cover_min.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/blackfriday_cover_min.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Enter Programming - จากเรียนแพทย์เข้ามาเขียนโปรแกรมได้ยังไง?</title><link href="https://nickuntitled.com/2021/11/9/enter_programming_how_to_move_from_medical_doctor/" rel="alternate" type="text/html" title="Enter Programming - จากเรียนแพทย์เข้ามาเขียนโปรแกรมได้ยังไง?" /><published>2021-11-09T20:00:00+07:00</published><updated>2021-11-09T20:00:00+07:00</updated><id>https://nickuntitled.com/2021/11/9/being-programming-from-doctor</id><content type="html" xml:base="https://nickuntitled.com/2021/11/9/enter_programming_how_to_move_from_medical_doctor/">&lt;p&gt;บทความนี้เราเขียนเสริมจากที่พูดในคาบของอ. advisor ที่สอนให้ในวิชาเลือกของรพ.ริมน้ำที่เกี่ยวกับการเรียน AI สำหรับทางการแพทย์&lt;/p&gt;

&lt;h2 id=&quot;ช่วงแรก-ก่อนเข้าเรียนหมอ&quot;&gt;ช่วงแรก ก่อนเข้าเรียนหมอ&lt;/h2&gt;

&lt;p&gt;ตอนแรกก่อนเข้าเรียนหมอเรียนภาษา C มาก่อน เรียนเองและเรียนจากค่ายสอวน. คอม (ที่เคยไปถึงโอลิมปิกระดับชาติแล้วได้เหรียญทองแดง) ฝึกตั้งแต่พื้นฐาน, Data Structure &amp;amp; Algorithms และแก้โจทย์ปัญหาบ้างผ่านทางเว็บในสมัยนั้นก็มีเว็บ programming.in.th (ที่ตอนนี้มีหลายเว็บแล้ว เช่น &lt;a href=&quot;https://leetcode.com/&quot;&gt;Leetcode&lt;/a&gt;)&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/c_programming.jpg&quot; alt=&quot;C Programming&quot; /&gt;
&lt;figcaption&gt;ก่อนเรียนหมอ ก็เรียนภาษา C มาก่อนแล้ว&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ต่อมา เราก็ฝึกเขียน PHP + MySQL เพราะมีพื้นภาษา C อยู่แล้วนี่ แถมได้เขียนเว็บทางฝั่ง Front-end ด้วย HTML, CSS, JavaScript (สมัยนั้นใช้ jQuery เพราะมันฮิตด้วย แถมมันติดมากับ Bootstrap เวอร์ชัน 3-4)&lt;/p&gt;

&lt;p&gt;ช่วงนี้เราเขียนหน้าเว็บให้กับทางคณะฯ มาบ้าง แต่พอขึ้นคลินิกก็ไม่ได้เขียนเลย ก็งานยุ่งนี่ครับ แค่ทบทวนเรื่องที่เรียนบนชั้นคลินิกเวลาก็หมดเสียแล้ว&lt;/p&gt;

&lt;h2 id=&quot;หลังเรียนจบหมอ&quot;&gt;หลังเรียนจบหมอ&lt;/h2&gt;

&lt;p&gt;เมื่อเรียนจบพอมาใช้ทุนสธ. ก็ไม่ได้เขียนเลย เพราะแค่ลงเวรมาก็อยากจะนอน ไม่อยากอ่านอะไรเพิ่ม ก็มันไม่มีเวลาอ่ะคุณ แต่พอคิดไปคิดมา ไม่ได้อยากเป็นหมอแต่แรกแล้ว พอใช้ไปสักพักก็ลาออกมา จ่ายเงินสองแสนกว่าบาท&lt;/p&gt;

&lt;p&gt;แล้วเลือกเรียนต่อวิศวะชีวการแพทย์ ที่เลือกม.มหิดลเพราะเป็นแห่งแรก ๆ และมีอาจารย์ที่ทำเรื่องนี้ เราเลยเลือกสอบและสัมภาษณ์เข้าไป ก็เข้าไปเรียน&lt;/p&gt;

&lt;h2 id=&quot;เข้าเรียนวิศวะชีวการแพทย์&quot;&gt;เข้าเรียนวิศวะชีวการแพทย์&lt;/h2&gt;

&lt;p&gt;ตอนเรียนมีปรับพื้นฐานของวิศวะ ก็มีพวกคณิตศาสตร์ที่ใช้ มีตั้งแต่แคลคูลัส, Differential Equation, Probability เป็นต้น อย่างไรก็ดี ตอนเรียนที่แพทย์จุฬาฯ ไม่มีสอน Calculus 1 เราเลยซื้อหนังสือแคลคูลัส 1 มาอ่านแล้วทำโจทย์เอง แถมค้นหาข้อมูลเพิ่มเติมในอินเตอร์เน็ตที่มีสอนฟรี เราก็ฝึกไปก่อน นอกจากเรียนเลขแล้วยังมีเรียน Signals, Image Processing, Bioimage Informatics และอื่น ๆ&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/face_detection_python.jpg&quot; alt=&quot;Face Detection&quot; /&gt;
&lt;figcaption&gt;หลังเข้าเรียน ก็ได้ฝึกเขียน Python และศึกษาเรื่อง Computer Vision เช่น Face Detection แบบในภาพ&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;แล้วเข้าไปแล็บที่เป็น AI ครับ ตอนนี้แหละ (Artificial Intelligence in Medicine) ได้ฝึกเขียนโปรแกรม เลยเอาภาษาไพทอนนี่แหละมาฝึก เพราะภาษาไพทอนเป็นภาษาที่ฝึกได้ง่าย ตัวโค้ดเขียนเข้าใจง่าย ฝึกไม่นานก็เขียนได้แล้ว&lt;/p&gt;

&lt;p&gt;ต่อมาเราเลยศึกษาพวกไลบรารีไพทอนที่จำเป็นที่เกี่ยวข้องกับงานด้าน Computer Vision เช่น OpenCV, Numpy, Matplotlib, PyTorch, Tensorflow, ONNX runtime เป็นต้น&lt;/p&gt;

&lt;p&gt;พอศึกษาแล้วเขียนพอได้ระดับหนึ่ง ก็ต้องทำตัวเว็บเซิร์ฟเวอร์ แล้วจะเอาตัวไหนดี ตอนแรกจะเอา Django มันจะดูยากไปไหม เลยเลือก Flask ฝึกและใช้งานไประดับหนึ่ง ก็ฝึก FastAPI มาลองใช้ดู ใช้ง่ายแฮะ แต่อันนี้ไม่ได้เอาไปทำตัวเว็บเซิร์ฟเวอร์ ใช้แต่ Flask&lt;/p&gt;

&lt;p&gt;นอกจากทำตัว back-end แล้วก็ต้องทำ front-end เลยฝึก HTML, JS, CSS ใหม่อีกที ฝึกไม่นานก็ทำหน้าเว็บได้ และช่วงนี้ก็ฝึก Framework ในปัจจุบัน อย่าง ReactJS, GraphQL (Apollo Server &amp;amp; Client) เป็นต้น แถมสมัยนี้ใช้ Container กัน ก็ฝึกใช้ Docker, docker-compose เลย (แต่ตอนนั้นยังไม่ได้ฝึก Kubernetes)&lt;/p&gt;

&lt;h2 id=&quot;หลังจากนี้&quot;&gt;หลังจากนี้&lt;/h2&gt;

&lt;p&gt;ต่อไปหลังจากนี้ เราก็เดี๋ยวฝึกอันที่คนใช้กันเยอะ เช่น Django, FastAPI, Svelte, Tailwind CSS, NoSQL (MongoDB) และอื่น ๆ รวมถึงฝึกพื้นฐานอย่าง Math, Data Structure, Algorithm, Data Science และอื่น ๆ ที่จำเป็นต้องกรทำงานครับ&lt;/p&gt;

&lt;p&gt;เดี๋ยวฝึกแล้วได้อะไร จะเอามาเขียนในนี้ในโพสต่อ ๆ ไปครับ ขอบคุณผู้อ่านที่ติดตามครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Doctor" /><category term="Programming" /><category term="Medicine" /><category term="Programmer" /><category term="Job" /><category term="Python" /><category term="JavaScript" /><category term="JS" /><category term="C" /><category term="HTML" /><category term="CSS" /><category term="Engineering" /><category term="Career" /><category term="Biomedical" /><category term="สายงาน" /><category term="เปลี่ยนสาย" /><category term="เปลี่ยนอาชีพ" /><category term="หมอ" /><category term="แพทย์" /><category term="โปรแกรมเมอร์" /><category term="เขียนโปรแกรม" /><category term="โปรแกรมมิง" /><category term="วิศวกรรมศาสตร์" /><category term="วิศวกร" /><category term="วิศวชีวการแพทย์" /><summary type="html">ก่อนหน้านี้เรียนหมอไม่ค่อยได้ฝึกเขียนโปรแกรมอะไร จนมาที่เรียนวิศวะชีวการแพทย์ ที่เขียนโปรแกรมได้ในระดับหนึ่งแล้ว ในบทความนี้จะพูดว่ามาเขียนโปรแกรมได้อย่างไรครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/enter_programming_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/enter_programming_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>