<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://nickuntitled.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://nickuntitled.com/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2022-01-09T01:31:24+07:00</updated><id>https://nickuntitled.com/feed.xml</id><title type="html">Nick Untitled</title><subtitle>A Nick&apos;s Journal on my Life</subtitle><author><name>Nick Untitled</name><email>contact@nickuntitled.com</email></author><entry><title type="html">วิธีการเลือก parent element ด้วย JavaScript</title><link href="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/" rel="alternate" type="text/html" title="วิธีการเลือก parent element ด้วย JavaScript" /><published>2022-01-02T22:30:00+07:00</published><updated>2022-01-02T22:30:00+07:00</updated><id>https://nickuntitled.com/2022/01/2/element-closest</id><content type="html" xml:base="https://nickuntitled.com/2022/01/2/select_parent_element_javascript/">&lt;p&gt;ปกติเวลาที่เราเลือก element ด้วยภาษาจาวาสคริป เราจะใช้คำสั่งที่รู้จักกันอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.getElementById(&quot;id&quot;);
document.document.getElementsByClassName(&quot;class name&quot;);
document.document.getElementsByName(&quot;name&quot;);
document.document.getElementsByTagName(&quot;tag name&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือเลือก element โดยการใช้ CSS Selector ด้วยคำสั่งที่รู้จักอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.querySelector(&quot;selector&quot;);
parent_element.querySelector(&quot;selector&quot;);
document.querySelectorAll(&quot;selector&quot;);
parent_element.querySelectorAll(&quot;selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งเหล่านี้ะคืนค่า element ที่เราเลือกไว้ ไม่ว่าจะเป็น element เดียว หรือ element ทั้งหมดที่เราพบในหน้าเว็บเพจนั้น ๆ อย่างไรก็ดีเราต้องการเลือก parent element จาก element ที่อยู่ภายใน จุดนี้เราจะทำได้อย่างไร?&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;jQuery&lt;/h2&gt;

&lt;p&gt;jQuery เป็นหนึ่งในไลบรารีที่คนนิยมใช้งานกัน เราเลือก parent element ได้โดยการพิมพ์คำสั่งอย่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;css selector&quot;).closest(&quot;parent css selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สองคำสั่งนี้จะอนุญาตเราเลือก parent element ได้ตามที่ต้องการเลย อย่างไรก็ดี ทั้งสองคำสั่งนี้มีข้อแตกต่างกัน เรายกตัวอย่างตามภาพด้านล่างนี้ก่อน&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานทั้งสองคำสั่งได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).parent().parent();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;li&quot;).closest(&quot;div&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทั้งคู่จะเลือก parent element ที่เป็น div ครับ&lt;/p&gt;

&lt;p&gt;สรุปความแตกต่างระหว่างสองคำสั่งตามข้างบนนี้ตรงที่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;.parent() เป็นคำสั่งที่ให้เราเลือก element ที่เป็น parent และอยู่ติดกับ element ที่เราเลือก&lt;/li&gt;
  &lt;li&gt;.closest() เป็นการเลือก element ที่อยู่เหนือ และอยู่ใกล้กันกับ element ที่เราเลือกไว้โดยการใช้ css selector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;อย่างไรก็ดีไลบรารีนี้มีข้อเสียได้แก่ ไลบรารีมีขนาดใหญ่ส่งผลต่อระยะเวลาการโหลดไลบรารีเพื่อใช้งาน กับไลบรารีนี้เก่าไปแล้ว เนื่องมาจากตัวจาวาสคริปเองได้รับการพัฒนาอย่างต่อเนื่องจนทำงานได้แบบเดียวกันกับ jQuery แต่ไม่ต้องพึ่งพาไลบรารีที่มีขนาดใหญ่ และทำงานได้เร็วมากกว่าไลบรารีที่กล่าวถึง&lt;/p&gt;

&lt;p&gt;ต่อไป เราจะมาพูดถึงคำสั่งที่มีอยู่แล้วในจาวาสคริป (หรือเรียกว่า &lt;a href=&quot;http://vanilla-js.com&quot;&gt;Vanilla JavaScript&lt;/a&gt;) ที่อนุญาตให้เราเลือก parent element ครับ คำสั่งเหล่านี้ได้แก่ node.parentNode, element.parentElement และ element.closest&lt;/p&gt;

&lt;h2 id=&quot;nodeparentnode-กับ-elementparentelement&quot;&gt;node.parentNode กับ element.parentElement&lt;/h2&gt;

&lt;p&gt;ทั้งคู่นี้เป็นคำสั่งในจาวาสคริปที่เลือก parent node หรือ element ที่อยู่เหนือกว่า node หรือ element ที่เราเลือก ตัวอย่างการใช้งานคำสั่งนี้เป็นไปตามด้านล่างนี้ครับ (ตัวอย่างด้านล่างเอามาจากหน้าเว็บ &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.body.parentNode; // the &amp;lt;html&amp;gt; element
document.body.parentElement; // the &amp;lt;html&amp;gt; element
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือยกตัวอย่างจากภาพเดิม&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.parentNode.parentNode;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.parentElement.parentElement;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราก็จะเลือก parent Element ที่เป็น div ได้เลย ถ้าลองสังเกตดูจะพบว่าทั้งสองคำสั่งมันก็ใช้ได้เหมือนกันนี่ แล้วมันต่างกันอย่างไร?&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงความแตกต่างระหว่าง Node กับ Element เสียก่อน (ความแตกต่างสรุปจาก&lt;a href=&quot;https://blog.webdevsimplified.com/2021-05/node-vs-element/&quot;&gt;หน้าเว็บนี้&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Element ก็คือ HTML tag ต่าง ๆ ที่อยู่ในหน้าเว็บไซต์ ได้แก่ div, span, body หรืออื่น ๆ&lt;/li&gt;
  &lt;li&gt;Node จะเป็นอะไรก็ได้ที่มีอยู่ในหน้าเว็บไซต์ รวมถึงข้อความ คอมเม้นต์ ไม่จำกัดว่าเป็น div, span, body, input, form หรืออื่น ๆ ที่เป็น HTML tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เราจะเห็นว่าการเลือก Node จะดูยุ่งยากกว่า เพราะเราค้องแยกระหว่างข้อความ คอมเม้นต์ หรือ HTML tag ดังนั้นแล้ว การใช้งาน Element จะดูจำเพาะมากกว่า&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถดูวิดีโอความแตกต่างระหว่าง Element กับ Node ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/rhvec8cXLlo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;ต่อมา เรามาดูความแตกต่างการใช้งานของสองคำสั่ง (โค้ดอ้างอิงจาก &lt;a href=&quot;https://stackoverflow.com/questions/8685739/difference-between-dom-parentnode-and-parentelement&quot;&gt;StackOverflow&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document.documentElement.parentNode;    // document เป็น node
document.documentElement.parentElement; // null เนื่องจาก document ไม่ใช่ element
(document.documentElement.parentNode === document);  // true
(document.documentElement.parentElement === document);  // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะเห็นว่า document ไม่ได้เป็นหนึ่งใน HTML tag อะไรเลยตามที่กล่าวไว้ตามข้างบน และ document ไม่ได้เป็น element แต่ก็ยังเป็น node อยู่ ดังนั้นการใช้งาน element.parentElement จะคืนค่า null กลับมา&lt;/p&gt;

&lt;h2 id=&quot;elementclosest&quot;&gt;element.closest&lt;/h2&gt;

&lt;p&gt;คำสั่งนี้เป็นส่วนหนึ่งในภาษาสคริปที่อนุญาตให้เราเลือก parent element ที่อยู่ใกล้กันกับ element ที่เราเลือกอยู่โดยการใช้ CSS Selector การใช้งานใช้งานได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;element.closest(&quot;CSS selector&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ยกตัวอย่างโดยเอารูปเดิมมาใช้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/parent_element_diagram.png&quot; alt=&quot;DOM Example&quot; /&gt;
แผนภาพตัวอย่าง&lt;/p&gt;

&lt;p&gt;ในที่นี้เราต้องการเลือก element div ที่อยู่เหนือ element li เราสามารถเรียกใช้งานคำสั่งนี้ได้ตามด้านล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let li = docuent.getElementById(&apos;li&apos;);
let div = li.closest(&apos;div&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์ตามข้างบนนี้แล้ว เราจะเลือก parent element ที่เป็น div ครับ เมื่อสังเกตตัวโค้ดแล้วพบว่าใช้งานได้สะดวกมากกว่า node.parentNode กับ element.parentElement&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดีการใช้งานทั้งสามคำสั่งได้แก่ node.parentNode, element.parentElement และ element.closest นี้ขึ้นกับผู้ใช้ว่าจะเอาไปใช้อย่างไรครับ ส่วนกรณีที่ผู้ใช้ไม่ได้ใช้ Vanilla JavaScript  คำสั่งทั้งสามคำสั่งนี้อาจจะไม่ได้ใช้เลยก็ได้ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="JavaScript" /><category term="Coding" /><category term="Developer" /><category term="Element" /><category term="Selector" /><category term="Parent Element" /><category term="Programming" /><category term="getElementById" /><category term="getElementsByClassName" /><category term="getElementsByName" /><category term="getElementsByTagName" /><category term="querySelector" /><category term="querySelectorAll" /><category term="Node" /><category term="Parent Node" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="วัตถุ" /><summary type="html">บทความนี้แนะนำวิธีการเลือกวัตถุ parent element ด้วยการใช้ภาษา JavaScript</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/parent_element_js_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python</title><link href="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/" rel="alternate" type="text/html" title="วัดระยะห่างระหว่างตาดำจากภาพโดยภาษา Python" /><published>2021-12-08T00:30:00+07:00</published><updated>2021-12-08T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/10/interpupillary-distance=measurement-python</id><content type="html" xml:base="https://nickuntitled.com/2021/12/10/interpupillary_distance_measurement_python/">&lt;p&gt;อันนี้เป็นส่วนหนึ่งของงานวิจัย ทำไปแล้วบางส่วน&lt;/p&gt;

&lt;p&gt;ปกติการวัดตาดำ เราจะพบได้ในคนที่เลือกขนาดเครื่อง Virtual Reality Headset หรือวัดขนาดแว่นตา หรืออื่น ๆ ปกติเราจะใช้ไม้บรรทัดวัดเพื่อให้รู้ว่าระยะห่างระหว่างตาดำ (Interpupillary Distance) มีระยะห่างเท่าไร อย่างไรก็ดีเราจะใช้ไม้บรรทัดวัดไปตลอดเหรอก็ไม่สะดวกเท่าไร แถมสมัยนี้เราก็ใช้คอมพิวเตอร์กันอยู่แล้วด้วย เลยเอามาเขียนโค้ดส่วนนี้เพื่อจับระยะการอ้าปากครับ&lt;/p&gt;

&lt;p&gt;หลักการวัดจากภาพดิจิทัล โดยปกติเวลาที่เราวัดจะได้หน่วยการวัดเป็น pixel แต่สิ่งที่เราต้องการก็คือ ต้องการการวัดที่มีหน่วยเป็นเซนติเมตร หรือมิลลิเมตรที่ตัวโปรแกรมวัดด้วยตัวเองไม่ได้ เราจำเป็นต้องหาวัตถุอ้างอิงเพื่อเป็น Reference สำหรับการแปลงหน่วยจาก pixel เป็นหน่วยที่เราวัดครับ&lt;/p&gt;

&lt;p&gt;ในตัวอย่างนี้ เราจะใช้บัตรประชาชนซึ่งเป็นสิ่งที่คนทุกคนมีกันอยู่แล้ว (ยกเว้นเด็กเล็ก) เป็นวัตถุ Reference ใช้สำหรับการวัดในครั้งนี้ ขนาดของบัตรประชาชน (ไทย) มีขนาดที่เป็นมาตรฐาน โดนมีขนาดด้านยาว 86 mm ด้านกว้าง 54 mm เราจะใช้ด้านยาวเป็น Reference&lt;/p&gt;

&lt;p&gt;แต่ก่อนที่จะไปวัด เราจะต้องแยกส่วน (Segment) บัตรประชาชนออกจากวัตถุอื่นในภาพก่อน แล้วจะทำอย่างไรดี หลักการนี้เรียกว่า Image Segmentation&lt;/p&gt;

&lt;h2 id=&quot;image-segmentation&quot;&gt;Image Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/mask_rcnn_segmentation.png&quot; alt=&quot;Image Segmentation&quot; /&gt;
ภาพตัวอย่างการ Segmentation จากเปเปอร์​ Mask R-CNN&lt;/p&gt;

&lt;p&gt;Image Segmentation เป็นหลักการจำแนก pixel ของวัตถุที่เราต้องการออกมาจากวัตถุอื่นในภาพดิจิทัล โดยยกตัวอย่างเช่นระบบการขับรถอัตโนมัติ (self-driving car) ที่จับคนในภาพเพื่อป้องกันไม่ให้เกิดอุบัติเหตุครับ หลักการนี้แบ่งออกมาได้เป็นสองวิธีได้แก่ Semantic Segmentation และ Instance Segmentation&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Semantic Segmentation เป็นการแยกวัตถุออกจากภาพวัตถุอื่นโดยการแบ่งประเภทของวัตถุ (class) จากภาพ ได้แก่ สีแดงเป็นคน สีน้ำเงินเป็นรถ เป็นต้น&lt;/li&gt;
  &lt;li&gt;Instance Segmentation เป็นการแบ่งวัตถุแต่ละชิ้นในภาพ ที่แตกต่างกับ Semantic Segmentation ที่แบ่งเป็นวัตถุที่ 1,2,3,4 เป็นต้น&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ตัวอย่างของเทคนิคที่ใช้ Image Segmentation คือ Mask R-CNN, U-NET ครับ&lt;/p&gt;

&lt;h2 id=&quot;u-net&quot;&gt;U-NET&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_artchitecture.png&quot; alt=&quot;U-NET Architecture&quot; /&gt;
ภาพโครงสร้าง U-NET&lt;/p&gt;

&lt;p&gt;U-NET ที่เป็นคนละอันกันกับ O-NET ที่สอบมัธยมศึกษาตอนปลายเข้ามหาวิทยาลัยที่จัดโดยสทศ ครับ&lt;/p&gt;

&lt;p&gt;U-NET เป็นโครงข่ายประสาทเทียม (Neural Network Architecture) แบบ Convolutional Neural Network ที่ให้ผลลัพธ์เป็น Matrix ที่มีขนาดกว้าง x ยาวเท่ากันกับภาพเดิม โดยในแต่ละตำแหน่งจะระบุได้ว่าเป็น 0 (ไม่มีภาพ Object) หรือ 1 (มี Object) ในภาพ&lt;/p&gt;

&lt;p&gt;โครงสร้างของเครือข่ายประสาท U-NET เราจะเห็นว่าเป็นรูปตัว U (U-shape) ที่แบ่งเป็นสองช่วง ได้แก่ Contracting Path (ด้านซ้าย) และ Upsampling Path (ด้านขวา) เราจะอธิบายในแต่ละส่วนตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h3 id=&quot;contract-path&quot;&gt;Contract Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_downsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Contract Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;3x3 Convolutions (ที่ไม่มี Padding) 2 รอบ&lt;/li&gt;
  &lt;li&gt;ตามมาด้วย Activation Function ReLU&lt;/li&gt;
  &lt;li&gt;ใช้ 2x2 Max Pooling ที่มี Stride 2 เพื่อ Down Sampling ระหว่างที่ทำ Down Sampling เราจะเพิ่มจำนวน Feature Channel เป็น 2 เท่าในแต่ละครั้ง&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;upsampling-path&quot;&gt;Upsampling Path&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/unet_upsampling.png&quot; alt=&quot;U-NET Contract Path&quot; /&gt;
ภาพโครงสร้าง U-NET ในขั้นตอน Upsampling Path&lt;/p&gt;

&lt;p&gt;ประกอบไปด้วย&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Up Sampling แล้วตามด้วย 2x2 Convolutions (หรือเรียกอีกอย่างว่า “up-convolution”) ที่แบ่งครึ่งจำนวน Channels&lt;/li&gt;
  &lt;li&gt;นำภาพที่ได้จากขั้นตอนการทำ 3x3 Convolutions + ReLU ใน Contract Path ที่ผ่านการ Cropped แล้วมา Concatenate&lt;/li&gt;
  &lt;li&gt;ทำ 3x3 Convolutions สองรอบ แล้วตามด้วย ReLU&lt;/li&gt;
  &lt;li&gt;ทำไปจนกระทั่งถึง Layer สุดท้าย เราทำ 1x1 Convolution เพื่อนำ 64 Component Feature Vector ให้เป็นจำนวน Classes ที่เราต้องการ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;จำนวน Convolutional Layer ทั้งหมดที่ใช้ใน U-NET มีทั้งหมด 23 Layers ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลเพิ่มเติมของ U-NET ผู้อ่านศึกษาได้ใน&lt;a href=&quot;https://arxiv.org/abs/1505.04597&quot;&gt;เปเปอร์ U-Net: Convolutional Networks for Biomedical Image Segmentation จากเว็บ arXiv&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h2 id=&quot;midv-500&quot;&gt;MIDV-500&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/midv_500.png&quot; alt=&quot;MIDV-500 Dataset&quot; /&gt;
ตัวอย่างรูปภาพในฐานข้อมูล MIDV-500&lt;/p&gt;

&lt;p&gt;MIDV-500 หรือเรียกอีกอย่างว่า Mobile Identity Document Video dataset ที่ประกอบไปด้วยวิดีโอ 500 ชิ้นที่มีเอกสารยืนยันตัวตนทั้งหมด 50 ชนิดที่สร้างขึ้นโดยใช้กล้องโทรศัพท์มือถืออย่าง iPhone 5, Samsung Galaxy S3 ที่บันทึกในสภาพแวดล้อม 5 รูปแบบ ได้แก่ ภาพวางบนโต๊ะ บนคีย์บอร์ด และบนมือ ภาพที่ถูกบังบางส่วน รวมถึงภาพที่มีพื้นหลังทีมีวัตถุต่าง ๆ เต็มหน้าจอที่ไม่เกี่ยวข้อง&lt;/p&gt;

&lt;p&gt;ในภาพที่บันทึกได้ จะไม่มีข้อมูลสำคัญ หรือข้อมูลที่ไว้ก็อปปี้สำหรับการทำบัตรปลอมได้ จุดนี้เป็นปัญหาสำคัญที่ไม่มีฐานข้อมูลในลักษณะนี้มาก่อนครับ&lt;/p&gt;

&lt;p&gt;สำหรับผู้อ่านที่ต้องการอ่านเพิ่มเติม สามารถอ่านได้ใน&lt;a href=&quot;https://arxiv.org/abs/1807.05786&quot;&gt;เปเปอร์ MIDV-500: a dataset for identity document analysis and recognition on mobile devices in video stream จากเว็บ arXiv&lt;/a&gt; ครับ และกรณีที่ต้องการดาวน์โหลดฐานข้อมูลไว้ใช้งาน สามารถดาวน์โหลดได้ที่ &lt;a href=&quot;https://github.com/fcakyon/midv500&quot;&gt;Github&lt;/a&gt; หรือดาวน์โหลดผ่านการติดตั้งไลบรารีใน pip ของไพทอน โดยพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install midv500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวไพทอนจะติดตั้งไลบรารี MIDV-500 ไว้ใช้งาน ตัวไลบรารีสามารถแปลงข้อมูล Annotation ของฐานข้อมูล MIDV-500 ให้อยู่ในรูปแบบของ COCO instance segmentation format&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ ฐานข้อมูลได้รับการพัฒนาขึ้นมาให้เป็นเวอร์ชันใหม่ โดยฐานข้อมูลที่สร้างขึ้นมาใหม่มีชื่อว่า &lt;a href=&quot;https://www.spiedigitallibrary.org/conference-proceedings-of-spie/11433/2558438/MIDV-2019--challenges-of-the-modern-mobile-based-document/10.1117/12.2558438.short?SSO=1&quot;&gt;MIDV-2019&lt;/a&gt; ครับ ฐานข้อมูลนี้แก้ปัญหาเรื่อง Projective Distortion และสภาพแสงสว่างที่แตกต่างกันไป&lt;/p&gt;

&lt;h2 id=&quot;เขียนโค้ดกัน&quot;&gt;เขียนโค้ดกัน&lt;/h2&gt;

&lt;p&gt;เราเขียนโค้ดเพื่อที่จะวัดระยะห่างระหว่างตาดำ การเขียนโค้ดจะมีขั้นตอนดังนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;จับภาพใบหน้า (Face detection)&lt;/li&gt;
  &lt;li&gt;Calibrate ระยะการวัด Pixel ต่อ mm โดยแยกส่วนบัตรประชาชนจากภาพ โดยให้ถือบัตรประชาชนให้ชิดริมฝีปากของผู้ที่ต้องการวัดภาพ&lt;/li&gt;
  &lt;li&gt;จับภาพจุดแลนมาร์คบริเวณดวงตา หรือตาดำ (Facial Landmark Detection)&lt;/li&gt;
  &lt;li&gt;วัดระยะห่างระหว่างตาดำ (Interpupillary Distance)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;เราเขียนโค้ดใน Google Colab ได้เลยครับ ผู้อ่านสามารถ&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/ipd_measurement.ipynb&quot;&gt;ดาวน์โหลดไฟล์ ipynb&lt;/a&gt; มาทดลองรันบน Google Colab หรืออื่น ๆ ได้ครับ&lt;/p&gt;

&lt;h3 id=&quot;จับภาพใบหน้า-face-detection&quot;&gt;จับภาพใบหน้า (Face Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/face_detection_python.jpg&quot; alt=&quot;Face Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับภาพใบหน้า หรือเรียกอีกอย่างว่า Face Detection คือการหาตำแหน่ง Face Regions of Interest จากภาพ โดยมีหลายเทคนิคที่เราสามารถใช้ได้เลย ตั้งแต่ Viola-Jones ที่พบได้ในคำสั่งบน OpenCV ที่คนโพสกันไปเยอะมาก หรือใช้เทคนิค dlib หรืออื่น ๆ ครับ อย่างไรก็ดี เราต้องพิจารณาความแม่นยำ ข้อดี ข้อเสียของแต่ละเทคนิค&lt;/p&gt;

&lt;p&gt;ในที่นี้ จะใช้เทคนิค FaceBoxes ครับ&lt;/p&gt;

&lt;h3 id=&quot;การจับจุดแลนมาร์คบนใบหน้า-facial-landmark-detection&quot;&gt;การจับจุดแลนมาร์คบนใบหน้า (Facial Landmark Detection)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/dlib_facial_landmark.jpeg&quot; alt=&quot;Facial Landmark Detection&quot; /&gt;
ภาพจากเว็บ Wikipedia&lt;/p&gt;

&lt;p&gt;การจับจุดแลนมาร์คบนใบหน้า หรือเรียกอีกอย่างว่า Facial Landmark Detection เป็นการจับตำแหน่งอวัยวะบนใบหน้าเพื่อใช้สำหรับการประมวลผลในขั้นตอนต่อไป มีหลายเทคนิคที่ใช้ ตั้งแต่รุ่นเก่าเลยก็เป็น Active Appearance Models, Constrained Local Models หรืออื่น ๆ แต่ถ้าเอาง่ายหน่อยก็เป็น dlib (จากเปเปอร์ Ensemble of Regression Trees) หรือ FaceMesh หรืออื่น ๆ&lt;/p&gt;

&lt;p&gt;ในตัวอย่าง เราใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;h3 id=&quot;calibrate-ระยะการวัด-pixel-และหาระยะห่างระหว่างตาดำ&quot;&gt;Calibrate ระยะการวัด Pixel และหาระยะห่างระหว่างตาดำ&lt;/h3&gt;

&lt;p&gt;เอาล่ะ มาเขียนโค้ดกันดีกว่า เราติดตั้งไลบรารีที่จำเป็นโดยการใช้ pip แต่สำหรับการทำ Calibrate เราใช้ไลบรารี&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OpenCV&lt;/li&gt;
  &lt;li&gt;Numpy&lt;/li&gt;
  &lt;li&gt;PyTorch&lt;/li&gt;
  &lt;li&gt;iglovikov_helper_functions&lt;/li&gt;
  &lt;li&gt;midv500models&lt;/li&gt;
  &lt;li&gt;imutils&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ติดตั้งเสร็จแล้ว อัพโหลดภาพเข้า Google Colab จากนั้นนำเข้าภาพโดยใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = cv2.imread(&quot;&amp;lt; Image Path &amp;gt;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab โดยใช้ภาพเราถือบัตรเองที่อัพโหลดเข้าไประบบ จะได้ภาพตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_input.png&quot; alt=&quot;Input Colab Image&quot; /&gt;
ภาพที่จะใช้ทำ Calibrate และหาระยะห่างระหว่างตาดำทั้งสองข้าง&lt;/p&gt;

&lt;p&gt;ต่อมา เรานำภาพผ่านการจับใบหน้าโดยใช้เทคนิค Face Detection และอะไรก็ได้เพื่อหา Face Regions of Interest ครับ โดยการใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img = img[..., ::-1]
boxes = face_boxes(img)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมาเรานำ Face Regions of Interest (ที่อยู่ในตัวแปร boxes) ไปประยุกต์ใช้ต่อสำหรับการทำ Calibrate เรานำเข้าไลบรารีได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import albumentations as albu
import torch

from iglovikov_helper_functions.utils.image_utils import load_rgb, pad, unpad
from iglovikov_helper_functions.dl.pytorch.utils import tensor_from_rgb_image

from midv500models.pre_trained_models import create_model
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ดาวน์โหลดโมเดล U-NET มาใช้งาน โดยใช้คำสั่งตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = create_model(&quot;Unet_resnet34_2020-05-19&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;กำหนดตัวโมเดลสำหรับการจับภาพที่ไม่ได้เทรนใหม่ (Evaluation model) และนำภาพที่เราจับภาพใบหน้ามาแล้วที่เป็นตำแหน่งแรกมาแยกส่วนบัตรประชาชน เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model.eval()
boxes = [boxes[0]]
size_box = len(boxes)
box = boxes[0]

[x1, y1, x2, y2] = box[:4]
x1 = int(x1)
y1 = int(y1)
x2 = int(x2)
y2 = int(y2)

# Segment Image
image = img[y1:y2,x1:x2].copy()
transform = albu.Compose([albu.Normalize(p=1)], p=1)
padded_image, pads = pad(image, factor=32, border=cv2.BORDER_CONSTANT)

# Inference
x = transform(image=padded_image)[&quot;image&quot;]
x = torch.unsqueeze(tensor_from_rgb_image(x), 0)
with torch.no_grad():
    prediction = model(x)[0][0]

# Postprocessing
mask = (prediction &amp;gt; 0).cpu().numpy().astype(np.uint8)
mask = unpad(mask, pads)
mask = mask * 255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราแยกส่วนบัตรประชาชนออกมาแล้วในรูปแบบตัวแปร mask ในตัวโค้ดจะออกมาเป็นอาเรย์ที่มีขนาดเท่าภาพต้นฉบับที่มีตัวแปรระหว่าง 0 กับ 1 แต่ภาพขาวดำปกติมันมีตั้งแต่ 0-255 (8-bit) เรานำ 255 มาคูณตามด้านบน&lt;/p&gt;

&lt;p&gt;หลังจากแยกส่วนแล้ว เราต้องการหาความยาวด้านยาวเป็นจำนวน Pixel เราจำเป็นต้องหา Contour ของภาพ โดยใช้คำสั่ง cv2.findContours แล้วเรียง Contour จากบนลงล่าง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Contour
contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
(cnts, boundingBoxes) = contour.sort_contours(contours, method=&quot;top-to-bottom&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อเรียงมาเรียบร้อยแล้ว เราหาความยาวด้านยาวของบัตรประชาชนที่แยกมาได้ โดยใช้คำสั่ง cv2.boundingRect&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# find boundingRect
target_cnt = cnts[0]
x,y,w,h = cv2.boundingRect(target_cnt)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้ความยาวมาเรียบร้อย เราแปลงให้อยู่ในรูปอัตราส่วนจำนวน pixel ต่อ mm ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Card size in pixels (compare to 86mm on long size)
distance = w
distancepermm = distance / 86
print(f&quot;card size (pixel) = { distance } compare to (mm) = 85 mm =&amp;gt; distance { distancepermm } pixels/mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;รันใน Google Colab เราจะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_calibrate.png&quot; alt=&quot;Calibrated Colab Image&quot; /&gt;
ภาพหลังการทำ Calibrate&lt;/p&gt;

&lt;p&gt;ต่อมา ในขั้นตอนต่อไป เป็นการหาตำแหน่งอวัยวะบนใบหน้า (Facial Landmark Detection) เราเอาภาพเดิมที่ผ่านการจับภาพใบหน้า (Face Detection) มาใช้งาน ได้ตามโค้ดด้านล่างนี้ที่ใช้เทคนิค 3DDFA_V2 ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param_lst, roi_box_lst = tddfa(img, boxes)
ver_lst = tddfa.recon_vers(param_lst, roi_box_lst, dense_flag=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เราจะได้จุดบนใบหน้า 68 จุดออกมา แต่อาเรย์ของ ver_lst อยู่ในรูปแบบอาเรย์ที่มี Shape = [3, 68] เราจำเป็นต้องแปลงให้อยู่ในรูปแบบ Shape = [68, 3] เสียก่อน ได้โดย&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = first_landmark[0,:].reshape(-1, 1)
y = first_landmark[1,:].reshape(-1, 1)
landmark = np.concatenate([x,y], axis = 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้ว เราจำเป็นต้องหาตำแหน่งตาดำตรงกลางเพื่อหาระยะห่างระหว่างตาดำ แต่ก่อนอื่น เรามาหาตำแหน่งรอบตาดำ และตาขาวก่อน จากภาพนี้&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/09/68-facial-landmarks.jpg&quot; alt=&quot;Facial Landmarks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;จุดบนอวัยวะบนใบหน้าทั้งหมด 68 จุด&lt;/p&gt;

&lt;p&gt;เรานำจุดบนอวัยวะบนใบหน้าตำแหน่งที่ 37-42 สำหรับตาขวา และตำแหน่งที่ 43-48 สำหรับตาซ้าย เพื่อนำมาหาตำแหน่งตาดำตรงกลางสำหรับการหาระยะห่างระหว่างตาดำ ได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;righteye = landmark[36:42]
rightiris = np.array([np.mean(righteye[:, 0]), np.mean(righteye[:, 1])])
lefteye = landmark[42:48]
leftiris = np.array([np.mean(lefteye[:, 0]), np.mean(lefteye[:, 1])])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เราหาระยะห่างระหว่างตาดำทั้งสองข้างได้โดยนำค่า pixel ของภาพต่อระยะห่างที่เป็นหน่วย mm ที่ได้จากการทำ Calibrate มาใช้งานตามโค้ดด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Find IPD
interpupillary_distance = 0.0
for i in range(2):
    interpupillary_distance += (rightiris[i] - leftiris[i])**2
interpupillary_distance = np.sqrt(interpupillary_distance)
interpupillary_distance_mm = interpupillary_distance / distancepermm
print(f&quot;Interpupillary Distance = { interpupillary_distance } which equals = { interpupillary_distance_mm } mm&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทดลองเริ่มต้นการทำงาน จะได้ผลลัพธ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/ipd_result.png&quot; alt=&quot;Interpupillary Distance Result&quot; /&gt;
ผลลัพธ์ที่ได้&lt;/p&gt;

&lt;p&gt;ฟังดูแล้วไม่ยากเกินไปใช่ไหมล่ะครับ สำหรับผู้อ่านวิธีการวัดระยะห่างระหว่างตาดำ (Interpupillary Distance) วิธีนี้เป็นวิธีหนึ่งแค่นั้นครับ&lt;/p&gt;

&lt;p&gt;และอีกอย่าง เทคนิคนี้ยังไม่ได้ทดสอบความแม่นยำกับคนอื่น ๆ (ยกเว้นผู้เขียนเอง) เลยอาจจะต้องเอาไปทดสอบก่อนที่จะนำไปใช้งานบน Production จริงครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Python" /><category term="Coding" /><category term="Developer" /><category term="Mouth Opening" /><category term="Iris" /><category term="Interpupillary Distance" /><category term="Measurement" /><category term="Programming" /><category term="Machine Learning" /><category term="Computer Vision" /><category term="Segmentation" /><category term="Face Detection" /><category term="Calibration" /><category term="U-NET" /><category term="Deep Learning" /><category term="3DDFA_V2" /><category term="FaceBoxes" /><category term="Face Detection" /><category term="Landmark Detection" /><category term="Artificial Intelligence" /><category term="เขียนโปรแกรม" /><category term="ไพทอน" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ตาดำ" /><category term="การวัด" /><category term="คอมพิวเตอร์วิทัศน์" /><summary type="html">บทความนี้แนะนำวิธีการวัดระยะห่างระหว่างตาดำโดยใช้ภาษา Python จากภาพดิจิทัลครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/find_ipd_cover.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token</title><link href="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/" rel="alternate" type="text/html" title="ใช้ HTTPOnly Cookies บน Node.js ด้วย Express สำหรับ Access Token" /><published>2021-12-01T00:30:00+07:00</published><updated>2021-12-01T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/12/01/implement-httponly-cookie-token-nodejs-express</id><content type="html" xml:base="https://nickuntitled.com/2021/12/01/implement_httponly_cookies_token_nodejs_express/">&lt;p&gt;เดิมทีเวลาที่เราใช้งานเพื่อเข้าสู่ระบบ เราจะเขียนโค้ดเพื่อขอ Access Token จากเซิร์ฟเวอร์แล้วนำมาเก็บไว้บน Client เพื่อนำมาใช้งานระบบที่จำเป็น โดยใน&lt;a href=&quot;https://www.howtographql.com/react-apollo/5-authentication/&quot;&gt;บทความบนเว็บที่เกี่ยวกับการทำระบบ Authentication โดยใช้ไลบรารี Apollo GraphQL&lt;/a&gt; นั้น เราจะเก็บข้อมูล Access Token ที่สร้างขึ้นไว้บน LocalStorage เพื่อนำมาใช้งานต่อครับ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การเก็บข้อมูลไว้ในนี้ก็มีปัญหาเรื่องความปลอดภัย ในบทความนี้จะแนะนำวิธีการเก็บข้อมูล Access Token ที่ปลอดภัยกว่าการเก็บบน LocalStorage ครับ&lt;/p&gt;

&lt;h2 id=&quot;localstorage&quot;&gt;LocalStorage&lt;/h2&gt;

&lt;p&gt;ก่อนอื่น เรามาพูดถึง LocalStorage ก่อน ตัว LocalStorage (หรือเรียกว่า window.localStorage) เป็นส่วนหนึ่งของ HTML5 Web Storage ที่ทำหน้าที่เก็บข้อมูลใส่ไว้บนเว็บเบราวเซอร์ทางฝั่ง Client ที่ข้อมูลยังคงอยู่ ถึงแม้ว่าเราจะปิดหน้าเว็บเบราวเซอร์นั้น ๆ ออกไป หรือข้อมูลหมดอายุตามที่เรากำหนดไว้เอง&lt;/p&gt;

&lt;p&gt;การใช้งาน LocalStorage ทำได้โดยการเก็บข้อมูลตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.setItem(&apos;token&apos;, &amp;lt; Access Token ที่ได้ &amp;gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วเราสามารถเรียกได้โดยการพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let token = localStorage.getItem(&apos;token&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้นข้อมูล Access Token ที่เก็บไว้ในเว็บเบราวเซอร์ก็จะคืนค่าอยู่ในตัวแปร token ครับ ฟังดูแล้วง่ายกว่าที่ดีคิดไว้ เพราะใช้คำสั่งตามที่เขียนไว้ข้างบนนี้ ข้อมูลก็ออกมาได้แล้วครับ อย่างไรก็ดี การเก็บข้อมูลไว้ใน LocalStorage มีข้อเสีย เนื่องมาจาก&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ข้อมูลที่เก็บ สามารถเก็บในรูปแบบ String เท่านั้น&lt;/li&gt;
  &lt;li&gt;มีขนาดที่จำกัดเพียงแค่ 5MB (แต่ข้อมูลข้างบนไม่ถึง 5MB :P)&lt;/li&gt;
  &lt;li&gt;มีปัญหาเรื่องความปลอดภัย เนื่องมาจากอ่านข้อมูลได้ง่ายเพียงใช้คำสั่งเดียวตามที่กล่าวไว้ข้างบน และสามารถดึกข้อมูลได้โดย &lt;a href=&quot;https://michael-coates.blogspot.com/2010/07/html5-local-storage-and-xss.html&quot;&gt;Cross site scripting (XSS)&lt;/a&gt; ครับ&lt;/li&gt;
  &lt;li&gt;อ่านรายละเอียดเพิ่มเติมได้ใน&lt;a href=&quot;https://dev.to/rdegges/please-stop-using-local-storage-1i04&quot;&gt;หน้าเว็บ dev.to ที่มีคนหนึ่งได้เขียนไว้&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ดังนั้นแล้ว ข้อมูลที่เก็บไว้ใน LocalStorage ไม่ควรจะเก็บข้อมูลที่เป็นความลับครับ แล้วเราจะเก็บข้อมูลไว้ที่ไหนดีล่ะ?&lt;/p&gt;

&lt;h2 id=&quot;httponly-cookies&quot;&gt;HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;HTTPOnly Cookies เป็นการตั้งค่าอันหนึ่งที่พบได้ระหว่าการตั้งค่า Set-Cookie HTTP Response Header ที่พบได้ตั้งแต่ Internet Explorer 6 SP1 (เก่ามากและ) โดยข้อมูลนี้เอามาจากบทความใน&lt;a href=&quot;https://owasp.org/www-community/HttpOnly&quot;&gt;หน้าเว็บมูลนิธิ OWASP&lt;/a&gt; ครับ&lt;/p&gt;

&lt;p&gt;สำหรับข้อมูลที่เป็นความลับ หรือข้อมูลที่ Sensitive มากกว่าปกติ ยกตัวอย่างเช่นข้อมูล Access Token, User ID, Session ID, ข้อมูลบัตรเครดิต และอื่น ๆ ที่เราต้องการให้แชร์บน Facebook แบบ Public นั้น เราเก็บช้อมูลใน HTTPOnly Cookies ที่ทำได้ตามขั้นตอนด้านล่างนี้&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;เมื่อผู้ใช้เข้าสู่ระบบ เซิร์ฟเวอร์จะสร้างข้อมูล Session ที่จำเป็นขึ้นมาสำหรับการใช้งาน&lt;/li&gt;
  &lt;li&gt;นำข้อมูลที่สร้างขึ้นเก็บอยู่ในรูปแบบ Cookie โดยกำหนดค่าคุกกี้ให้เป็น HTTPOnly เท่านั้น&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ไลบรารีที่รองรับ HTTPOnly Cookies มีหลากหลายไลบรารีมาก ผู้อ่านสามารถหาเพิ่มเติมได้ในอินเตอร์เน็ต แต่ในตัวอย่างนี้ เราจะใช้ไลบรารีที่นิยมอันหนึ่งที่มีชื่อว่า &lt;a href=&quot;https://expressjs.com/&quot;&gt;Express&lt;/a&gt; ที่อยู่ในรูปแบบภาษา JavaScript ที่ทำงานบน Node.js ครับ&lt;/p&gt;

&lt;p&gt;ตัวอย่างของการสร้าง HTTPOnly Cookies ทำได้ตามด้านล่างนี้ครับ แต่ก่อนอื่น เราต้องติดตั้งไลบรารีเหล่านี้ก่อนครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add express dayjs cookie-parser jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อติดตั้งเสร็จแล้ว เราพิมพ์ส่วนนี้เพิ่มเติมลงไปใน package.json&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  [...]
  &quot;type&quot;: &quot;module&quot;,
  [...]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เพื่อให้ใช้งานตามตัวอย่างด้านล่างนี้ได้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import http from &apos;http&apos;;
import express from &apos;express&apos;;
import dayjs from &apos;dayjs&apos;;
import cookieParser from &quot;cookie-parser&quot;;
import jwt from &apos;jsonwebtoken&apos;;

const app = express();
const httpServer = http.createServer(app);

[...]

app.use(cookieParser());

[...]

app.post(&apos;/login&apos;, (req, res, next) =&amp;gt; {

  [...]

  let token = jwt.sign(payload, jwt_secret, { expiresIn: jwt_expire });

  res.cookie(&quot;authorization&quot;, token, {
      secure: true,
      httpOnly: true,
      expires: dayjs().add(1, &quot;days&quot;).toDate(),
      sameSite: &apos;Strict&apos;
  });

  [...]

});

[...]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อดูตัวอย่างจากข้างบนนี้แล้ว ดูตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(cookieParser());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นการเกิดใช้งานตัว cookie-parser Middleware ที่เป็นส่วนหนึ่งของไลบรารี Express ที่อนุญาตให้เราเรียกใช้งาน Cookie header เพื่อดึงข้อมูล HTTPOnly Cookies โดยพิมพ์ว่า req.cookies ครับ&lt;/p&gt;

&lt;p&gt;ในหลายบรรทัดต่อมา ตรงส่วนคำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie(&quot;token&quot;, token, 
    secure: true,
    httpOnly: true,
    expires: dayjs().add(1, &quot;days&quot;).toDate(),
    sameSite: &apos;Strict&apos;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;คำสั่งนี้เป็นคำสั่งที่เรากำหนดค่าอะไรก็ตามลงไปใน Cookie ที่เราได้กำหนดไว้ คือ เรากำหนดค่า Access Token ลงไปใน Cookie token ครับ ส่วนการตั้งค่าที่อยู่ในปีกกานั้นเป็นการตั้งค่า Cookie นี้ให้&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;secure เป็นการตั้งค่าให้ใช้งานผ่าน HTTPS เท่านั้น&lt;/li&gt;
  &lt;li&gt;httpOnly เป็นการตั้งค่าให้ cookie ตัวนี้เรียกใช้งานโดยเว็บเซิร์ฟเวอร์ได้เท่านั้น&lt;/li&gt;
  &lt;li&gt;expires เป็นการตั้งค่าระยะเวลาหมดอายุ ตามคำสั่งที่เขียนข้างบนกำหนดให้มีอายุ 1 วัน&lt;/li&gt;
  &lt;li&gt;sameSite ตั้งค่าให้เพิ่ม SameSite ใน Set-Cookie HTTP Header มีด้วยกันสองแบบได้แก่ Strict ที่ผ่านทางเว็บไซต์เราเท่านั้น หรือ Lax ที่ส่ง Cookie ผ่านเว็บไซต์อื่นได้ ผ่าน HTTP Get บน Address Bar (เช่นการกด Link)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ส่วนการตั้งค่าเพิ่มเติมที่เราไม่ได้กำหนดค่าไว้ มีได้แก่&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;domain กำหนดโดเมนเนม ในที่นี้ให้โดเมนเนมเดียวกันกับ app&lt;/li&gt;
  &lt;li&gt;encode เป็นฟังก์ชันที่กำหนด encoding
เป็นต้น โดยการตั้งต่าเพิ่มเติมนี้ ผู้อ่านสามารถเข้าไปดูได้ใน &lt;a href=&quot;https://expressjs.com/en/api.html&quot;&gt;Reference ของ Express&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;เมื่อเราเรียกใช้งานผ่านคำสั่งอย่าง fetch, XMLHttpRequest หรืออื่น ๆ เราดู HTTPOnly Cookies ได้ที่หน้า Developer Tools -&amp;gt; Application -&amp;gt; Storage -&amp;gt; Cookies -&amp;gt; ที่อยู่เว็บไซต์ -&amp;gt; เราจะพบ HTTPOnly Cookies ที่เราได้สร้างขึ้นครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot; alt=&quot;HTTPOnly Cookies บน Developer Tools&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPOnly Cookies บน Developer Tools (&lt;a href=&quot;https://asset.nickuntitled.com/2021/12/httponly_cookie_devtool.png&quot;&gt;ดูรูปเต็ม&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ดูตรง Authorization เราจะพบว่า Cookie ที่สร้างนี้อันนี้เป็น HTTPOnly Cookies ครับ แล้วเวลาที่ใช้งานจริง เราจะเรียกใช้งานอย่างไรดีล่ะ?&lt;/p&gt;

&lt;p&gt;เราเรียกใช้งานได้โดยผ่านการพิมพ์&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(&apos;/isloggedin&apos;, (req, res, next) =&amp;gt; {
  
  [...]

  let token = req.cookies.authorization;

  [...]

});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง req.cookies.authorization อันนี้แหละ เป็นการเรียกใช้งาน HTTPOnly Cookies ที่เราสร้างชึ้นครับ อย่างไรก็ดี กรณีที่เราใช้งานผ่าน Apollo Server GraphQL เรายังเรียก HTTPOnly Cookies ได้อยู่ไหม คำตอบคือ ทำได้สบายมาก เพียงแต่เราต้องมาพิมพ์คำสั่งใน context ที่สร้างขึ้น&lt;/p&gt;

&lt;p&gt;เราพิมพ์โค้ดได้ตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { ApolloServer } from &apos;apollo-server-express&apos;;
import { ApolloServerPluginDrainHttpServer } from &apos;apollo-server-core&apos;;

[...]

const apollo_server = new ApolloServer({ 
  typeDefs,
  resolvers,
  plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
  context: ({ req }) =&amp;gt; {
    let token = req.cookies.authorization || &apos;&apos;;
    return {
      token
    };
  }
});

[...]

apollo_server.applyMiddleware({ &quot;app&quot;: express_app });

[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;สังเกตตรง context ที่อยู่ใน new ApolloServer({ … }) อันนี้แหละมีส่วนที่เราเรียกใช้งาน HTTPOnly Cookies ครับ ส่วนไลบรารีอื่น ผู้อ่านสามารถหาอ่านได้ในอินเตอร์เน็ตเพิ่มเติมครับ&lt;/p&gt;

&lt;h2 id=&quot;ประโยชน์การใช้-httponly-cookies&quot;&gt;ประโยชน์การใช้ HTTPOnly Cookies&lt;/h2&gt;

&lt;p&gt;ประโยชน์ของการใช้งาน HTTPOnly Cookies ตามที่เขียนในเว็บ &lt;a href=&quot;https://blog.codinghorror.com/protecting-your-cookies-httponly/&quot;&gt;CodingHorror&lt;/a&gt; หรืออื่น ๆ ได้แก่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTPOnly Cookies จำกัดให้เรียกใช้งานผ่านเว็บเซิร์ฟเวอร์เท่านั้น เราจะใช้งานผ่าน document.cookie ไม่ได้&lt;/li&gt;
  &lt;li&gt;ป้องกันการเกิด Cross-site Scripting (XSS) ดังนั้นแล้ว เวลาที่เรียกใช้งาน fetch, XMLHttpRequest หรืออื่น ๆ จะกระทำได้โดยผ่านโดเมนเดียวกันกับเว็บเซิร์ฟเวอร์เท่านั้น&lt;/li&gt;
  &lt;li&gt;ตามที่เขียนข้างบนนี้มีเขียนให้ใช้ Same-site Cookie ที่ใช้งานได้เฉพาะเว็บเราเท่านั้น ทำให้เรียกใช้ผ่านเว็บอื่นไม่ได้ ส่วนนี้จะป้องกัน Cross site request forgery (CSRF) ครับ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;และอื่น ๆ&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;จากตัวอย่างจะพบว่าเราใช้งาน HTTPOnly Cookies โดยใช้งานบน Node.js ที่ใช้ไลบรารี Express ได้เพียงไม่กี่คำสั่งเท่านั้น เมื่อใช้งานแล้วทำให้เว็บไซต์ของเราปลอดภัยขึ้นมากกว่าเดิมครับ อย่างไรก็ดี อันนี้เป็นส่วนหนึ่งที่ทำให้เว็บของเราปลอดภัยตรับ จะต้องพิจารณาการเขียนโค้ดส่วนอื่นร่วมด้วยว่ามีช่องโหว่หรือไม่ครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="HTTPOnly" /><category term="Developer" /><category term="HTTP" /><category term="Cookies" /><category term="Secure" /><category term="Security" /><category term="Token" /><category term="JWT" /><category term="JavaScript" /><category term="Coding" /><category term="GraphQL" /><category term="API" /><category term="เขียนโปรแกรม" /><category term="จาวาสคริป" /><category term="เขียนโค้ด" /><category term="โค้ดดิ้ง" /><category term="ความปลอดภัย" /><category term="โทเค็น" /><summary type="html">บทความนี้แนะนำวิธีการเก็บ Access Token ที่ปลอดภัยกว่าการเก็บใน LocalStorage ด้วย HTTPOnly Cookies บน Node.js</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/12/httponly_cookie_header.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">สรุปบางส่วนจากสเปช How to Become a Web 3 Developer</title><link href="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/" rel="alternate" type="text/html" title="สรุปบางส่วนจากสเปช How to Become a Web 3 Developer" /><published>2021-11-26T00:30:00+07:00</published><updated>2021-11-26T00:30:00+07:00</updated><id>https://nickuntitled.com/2021/11/26/how-to-be-web3-developer</id><content type="html" xml:base="https://nickuntitled.com/2021/11/26/how_to_be_web3_developer/">&lt;p&gt;เมื่อวันก่อนเปิดทวิตเตอร์เจอสเปชของทางเว็บ &lt;a href=&quot;https://hashnode.com&quot;&gt;Hashnode&lt;/a&gt; ที่มีหัวข้อว่า How to Become a Web 3 Developer หรือแปลเป็นภาษาไทยว่าวิธีการเป็นนักพัฒนาเว็บ 3.0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hashnode เป็นเว็บที่อนุญาตให้คนเขัยนบทความที่เกี่ยวข้องกับการเขัยนโปรแกรมได้ แถมเราสามารถลิ้งค์โดเมนเนมที่เราจดไว้แล้วกับหน้าบล็อกนี้ได้เลย 
จุดนี้นึกถึงเว็บ Medium ครับ แต่อันนี้สำหรับนักพัฒนาโปรแกรม ใครสนใจเข้าไปสมัครสมาชิกและเขียนบทความได้ฟรี&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ก่อนที่เราจะไปถึงสรุป เรามาพูดถึงเว็บ 3.0&lt;/p&gt;

&lt;h2 id=&quot;web-3&quot;&gt;Web 3&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/cryptocurrency.jpg&quot; alt=&quot;Cryptocurrency&quot; /&gt;
เงินคริปโตเป็นส่วนหนึ่งของ Blockchain ที่เกี่ยวข้องกับ Web 3.0&lt;/p&gt;

&lt;p&gt;Web 3 หรือเรียกว่า Web 3.0 มีคำนิยามตามที่ Tim Berners-Lee ให้ไว้ว่ามันจะเป็น The next generation of internet ที่ตัวเว็บจะกลายเป็น Semantic Web ที่มีความฉลาดมากขึ้น ทำงานได้อัตโนมัติ ทำได้งานด้าน AI, Machine Learning, Blockchain และเทคโนโลยีอัจฉริยะอื่น ทำงานได้ดีมากขึ้นกว่าเดิม&lt;/p&gt;

&lt;p&gt;นอกจากนี้ ทาง Berners-Lee ให้นิยามไว้เพิ่มเติมว่า Web 3.0 จะเป็นเครือข่ายที่อนุญาตให้ผู้อ่านสามารถสร้างคอนเท้นต์ได้โดยไม่จำเป็นต้องพึ่งทางผู้ให้บริการ ทางรัฐ หรืออื่น ๆ ก็คือจะมีความเป็น Decentralize มากขึ้นกว่าเดิม สิ่งนี้เหมือนกับเทคโนโลยีของ Blockchain ทางด้าน Cryptocurrency ตรับ&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถอ่านเพิ่มเติมได้ที่บทความในเว็บ&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2020/01/06/what-is-web-3-0/?sh=3831244258df&quot;&gt;Forbes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://slate.com/technology/2021/11/web3-explained-crypto-nfts-bored-apes.html&quot;&gt;Slate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;รวมถึงใน&lt;a href=&quot;https://www.youtube.com/results?search_query=web+3.0&quot;&gt;ยูทูป&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;และอื่นๆ ครับ&lt;/p&gt;

&lt;p&gt;เรามาพูดถึงที่สรุปจากสเปชบางส่วนครับ&lt;/p&gt;

&lt;h2 id=&quot;สรุปจากสเปช&quot;&gt;สรุปจากสเปช&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/web3_space.jpg&quot; alt=&quot;Web 3.0 Space&quot; /&gt;&lt;/p&gt;

&lt;p&gt;สเปชนี้จะเป็นสเปชที่เปิดให้คนกดยกมือเข้าไปถามได้ อันนี้นึกถึง &lt;a href=&quot;https://nickuntitled.com/2021/02/18/talk-about-clubhouse/&quot;&gt;Clubhouse&lt;/a&gt; ตรับ เพียงแต่อันนี้มีบนทวิตเตอร์มาระยะหนึ่งแล้ว และไม่เป็น&lt;a href=&quot;https://twitter.com/search?q=%23สเปซtoxic&amp;amp;src=typed_query&amp;amp;f=top&quot;&gt;สเปช Toxic&lt;/a&gt; ครับ โดยเราจะสรุปบางส่วนได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;นักพัฒนา Web 3.0 ไม่จำเป็นต้องเชี่ยวชาญ Web 2.0 มาก่อน แต่ถ้าเคยทำเว็บมาก่อนอยู่แล้วจะทำให้เรียนรู้การทำ Web 3.0 ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;การทำเว็บก็ต้องมีความรู้ทางด้านการเขียนโปรแกรม ในสเปชจะกล่าวถึ้งความรู้ทางด้าน HTML, CSS, JavaScript, Object-oriented Programming (OOP) และอื่น ๆ&lt;/li&gt;
  &lt;li&gt;นอกจากความรู้ทางการเขียนโปรแกรมแล้ว ความรู้ทางด้าน Blockchain, Solana, Ethereum, Polygon รวมถึงหลักการ NFT, Smart Contract, Decentralization, Layer 2 เป็นต้น &lt;a href=&quot;https://www.youtube.com/watch?v=qOVAbKKSH10&quot;&gt;ลิ้งยูทูปอันนี้&lt;/a&gt;น่าจะอธิบายเรื่องที่กล่าวมาได้ในระดับหนึ่งครับ&lt;/li&gt;
  &lt;li&gt;อีกอย่าง เรียนรู้การใช้ไลบรารีที่เกี่ยวข้องกับ Web 3.0 ครับ โดยหยิบไลบรารี Open Source มาฝึกได้เลย&lt;/li&gt;
  &lt;li&gt;พอเรีัยนรู้ตามข้างบนไประยะหนึ่งแล้ว การสร้างโปรเจคขึ้นมาเป็นวิธีทำให้เราเรียนรู้ได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;เมื่อสร้างโปรเจคแล้ว นำมาเผยแพร่บนอินเตอร์เน็ต โซเชียล รวมถึงเขียนบล็อก บทความบนแพลตฟอร์มอะไรก็ได้เพื่อเผยแพร่โปรเจค ให้ความรู้ (ทางนั้นแนะนำ Hashnode แหม ก็ใครเป็นเจ้าของสเปช) และโพสลงโซเชียลเพื่อทำให้คนรู้จักเรา สร้างคอนเนคชั่นได้ (ที่ไม่ใช่ระบบอุปถัมภ์)&lt;/li&gt;
  &lt;li&gt;สร้าง Resume, CV และมองหาบริษัทที่เปิดรับสมัครงาน&lt;/li&gt;
  &lt;li&gt;ระยะเวลาเริ่มต้นจนทำเว็บ 3.0 เป็น อันนี้ไม่แน่นอน ขึ้นกับคน ถ้ายังไม่มีพื้นฐานอะไรเลย ก็จะช้าหน่อย&lt;/li&gt;
  &lt;li&gt;มี Passion อยากจะเรียนรู้ ใช้เวลาฝึกสม่ำเสมอ สนุกกับมัน&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;สรุปได้คร่าว ๆ ประมาณนี้ครับ ดูจากแต่ละข้อแล้วก็คล้าย ๆ กันกับวิธีการเริ่มการเขียนโปรแกรม หรือวิธีการเริ่มสกิลใหม่สำหรับคนที่ทำงานหนึ่งแล้วต้องการเปลี่ยนสาย เช่นหมอไปเป็นนักบิน เป็นต้น ผู้อ่านสามารถนำสิ่งที่สรุปไปทำตามได้ครับ&lt;/p&gt;

&lt;p&gt;แต่ถ้าผู้อ่านต้องการข้อมูลเพิ่มเติม ผู้อ่านสามารถหาได้ในอินเตอร์เน็ต ยูทูป หนังสือ และอื่น ๆ ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Web" /><category term="Web 3.0" /><category term="Developer" /><category term="Programmer" /><category term="Job" /><category term="Career" /><category term="Reskill" /><category term="Hashnode" /><category term="เว็บ" /><category term="เว็บ 3.0" /><category term="เขียนโปรแกรม" /><category term="โปรแกรมเมอร์" /><category term="อาชีพ" /><category term="รีสกิล" /><category term="นักพัฒนาเว็บ" /><summary type="html">เมื่อวันก่อนมีการจัดสเปชของ Hashnode ที่กล่าวถึง How to be Web 3.0 Developer ในบทความนี้สรุปบางส่วนครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/how_to_be_web3_developer_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Black Friday - ช่วงแอพดี ราคาถูก แล้วบอกต่อ</title><link href="https://nickuntitled.com/2021/11/23/black_friday_app/" rel="alternate" type="text/html" title="Black Friday - ช่วงแอพดี ราคาถูก แล้วบอกต่อ" /><published>2021-11-23T08:23:00+07:00</published><updated>2021-11-23T08:23:00+07:00</updated><id>https://nickuntitled.com/2021/11/23/black-friday-app</id><content type="html" xml:base="https://nickuntitled.com/2021/11/23/black_friday_app/">&lt;p&gt;Black Friday เป็นมหกรรมงาน Sale ลดราคาสินค้าหลายชนิดที่จัดทางฝั่งอเมริกา งานในลักษณะนี้ถ้าให้ใกล้เคียงกันก็เป็นงาน 11.11 12.12 ที่จัดตามเว็บแบบ Lazada Shopee ครับ โดยในช่วงนี้เราจะเห็นว่ามีการจัดโปรโมชันลดราคาแอพลงมาพอสมควร ทำให้เราจับจ่ายใช้สอยซื้อแอพของแท้ได้ง่ายขึ้นมากกว่าเดิมครับ งาน Black Friday งานนี้ปกติทุกปีจะจัดในช่วงวันศุกร์สัปดาห์ที่ 4 ของเดือนพฤศจิกายนครับ โดยปี 2564 ปีนี้จัดขึ้นในวันที่ 26 พฤศจิกายนครับ&lt;/p&gt;

&lt;h2 id=&quot;ที่มาของงานนี้คืออะไร&quot;&gt;ที่มาของงานนี้คืออะไร?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/ddusa_blackfriday.jpg&quot; alt=&quot;Black Friday History&quot; /&gt;&lt;/p&gt;

&lt;center&gt;Black Friday ที่มาภาพจาก &lt;a href=&quot;https://en.wikipedia.org/wiki/Black_Friday_(shopping)&quot;&gt;Wikipedia&lt;/a&gt;&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ที่มาของงานนี้ตามในเว็บของ &lt;a href=&quot;https://www.history.com/news/black-friday-thanksgiving-origins-history&quot;&gt;Histroy&lt;/a&gt; กล่าวว่ามาจากเมืองฟิลาเดลเฟรีย ที่ประชาชนออกมาใช้เงินเป็นจำนวนมากอย่างกับจลาจล จนต้องมีตำรวจเข้ามาควบคุม และคอยระงับเหตุต่าง ๆ ในเมือง เลยเรียกวันนี้ว่า วันศุกร์อันแสนมืดหม่น ครับ แต่ตอนหลังก็ไม่ได้มืดหม่นอะไรแล้วล่ะฮะ เป็นช่วงงานช้อปปิ้งที่สินค้าลดราคาในช่วงนี้แทนครับ&lt;/p&gt;

&lt;h2 id=&quot;แอพที่ลดราคา&quot;&gt;แอพที่ลดราคา&lt;/h2&gt;

&lt;p&gt;ช่วงนี้เงินหายาก จะให้ไปดาวน์โหลดแอพเถื่อนเพื่อป้องกันนายทุนตามในทวิตเตอร์ที่ปรากฏในช่วงนี้ก็คงจะดูไม่ดี แถมการใช้งานแอพเถื่อนก็ยุ่งยากไปหน่อย เพราะเราต้อง Crack หรือลง Patch หรือทำวิธีอื่น ๆ เพื่อให้เราสามารถใช้งานแอพได้โดยไม่ซื้อของแท้ แล้วความเสี่ยงที่เกิดจากการใช้งานแอพเถื่อนก็มีได้แก่ ติดไวรัส ติดมัลแวร์ แอพมีช่องโหว่เนื่องจากแอพไม่ได้รับการอัพเดท ข้อมูลถูกขโมยได้ง่าย ขาดการซัพพอร์ตจากทางผู้ให้บริการ รวมถึงมีความเสี่ยงที่จะถูกจับได้ครับ&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้ว เรามาซื้อของแท้ดีกว่า แต่ก็มีคนบอกว่าไม่อยากจะจ่ายแอพราคาแพง เปลืองเงิน เงินไม่พอ หรือเงินเดือนน้อยจะให้ทำอย่างไร? เราจะบอกว่าช่วงนี้แหละ (รวมถึงช่วงอื่น ถ้าลดราคาครับ) เป็นช่วงที่เหมาะแก่การซื้อแอพเลยครับ เราจะยกตัวอย่างแอพที่ลดราคาในช่วงนี้ตามบทความที่เขียนใน &lt;a href=&quot;https://appleinsider.com/articles/21/11/22/black-friday-software-deals-save-up-to-70-on-adobe-creative-cloud-affinity-photo-parallels&quot;&gt;Apple Insider&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h3 id=&quot;affinity-photo-desginer-publisher&quot;&gt;Affinity Photo, Desginer, Publisher&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/affinity_app.png&quot; alt=&quot;Affinity App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Affinity Photo, Desginer, Publisher&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพนี้เป็นแอพแต่งภาพ ทำงานด้านการออกแบบ หรือถึงทำงานด้านสิ่งพิมพ์ที่พัฒนาโดยบริษัท Serif ที่เป็นหนึ่งในแอพที่นิยมครับ แอพนี้ซื้อครั้งเดียว ใช้งานได้ยาว ๆ ไม่จำเป็นต้องจ่ายรายเดือนแบบที่เราสมัครใช้บริการผ่าน Adobe Creative Cloud ครับ&lt;/p&gt;

&lt;p&gt;ช่วงนี้แอพเหล่านี้ลดราคาลงมา 30% เอาจริง ไม่ได้ลดแค่แอพอย่างเดียว ส่วนเสริมของแอพก็ลดราคา 30% ด้วย ใครที่ลังเลว่าจะซื้อไหม เราแนะนำให้ซื้อครับ ของเราใช้ Affinity Photo แล้วใช้แต่งภาพถ่ายได้ดีครับ&lt;/p&gt;

&lt;p&gt;ซื้อได้ที่ไหน เราแนะนำให้ซื้อผ่าน&lt;a href=&quot;https://affinity.serif.com/en-us/&quot;&gt;หน้าเว็บของผู้ผลิต&lt;/a&gt;ครับ ซื้อแล้วสามารถติดตั้งลงบน macOS, Windows ได้ครับ ส่วน iPad ก็สามารถติดตั้งผ่าน App Store ได้เช่นกัน แต่ไม่มีแอพ Affinity Publisher ครับ&lt;/p&gt;

&lt;h3 id=&quot;parallels&quot;&gt;Parallels&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/parallel_app.png&quot; alt=&quot;Parallels App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Parallels&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพ Parallels ที่เรารู้จักกันเป็นแอพ Parallels Desktop ที่สามารถติดตั้งวินโดว์เพื่อใช้งานบนคอมพิวเตอร์เครื่องแมค ที่มีคนลง Windows 10 on ARM ลงบนคอมพิวเตอร์ Mac ที่ใช้ซีพียู Apple M1, M1 Pro และ M1 Max ครับ ทีนี้ช่วงนี้แอพเหล่านี้ลดราคาลงมา 20% ทำให้เราสามารถซื้อมาใช้งานได้ง่ายขึ้นมากกว่าเดิม&lt;/p&gt;

&lt;p&gt;ไปซื้อได้ในเว็บของ &lt;a href=&quot;https://www.parallels.com&quot;&gt;Parallels&lt;/a&gt; เองตรับ&lt;/p&gt;

&lt;h3 id=&quot;adobe-creative-cloud&quot;&gt;Adobe Creative Cloud&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/adobe_app.png&quot; alt=&quot;Adobe Creative Cloud App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Creative Cloud&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;แอพ Adobe Creative Cloud เป็นแอพกลุ่มที่ใช้งานออกแบบ ตัดต่อวิดีโอ ทำเว็บ หรืออื่น ๆ ที่หลายคนรู้จักกัน ได้แก่ Photoshop, Lightroom, Premiere Pro, Illustrator, AfterEffects หรืออื่น ๆ ที่เดิมจากซื้อขาดมาเปลี่ยนเป็นจ่ายผ่านรายเดือนแทน มีหลายแพคเกจตั้งแต่ Photography Plan จนถึง All Apps&lt;/p&gt;

&lt;p&gt;ที่เห็นในเว็บที่ลดราคาก็มีแพคเกจ All apps ที่ลดราคาสำหรับผู้ที่ใช้งานในปีแรก มีตั้งแต่สำหรับ&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Individual ที่ลดราคาเหลือ 1,143.83 บาทต่อเดือน จากเดิมราคา 2,020.16 บาทต่อเดือน&lt;/li&gt;
  &lt;li&gt;Student and Teachers ที่ลดราคาเหลือ 609.90 บาทต่อเดือน จากเดิมราคา 2,020.16 บาทจ่อเดือน&lt;/li&gt;
  &lt;li&gt;Teams ที่ลดราคาเหลือ 1,386.72 บาท&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ราคาทั้งหมด รวม VAT แล้วครับ&lt;/p&gt;

&lt;p&gt;ใครสนใจ ไปสมัครสมาชิกรายเดือนได้ในเว็บของ &lt;a href=&quot;https://www.adobe.com/th_th/creativecloud.html?mv=affiliate&amp;amp;mv2=red&quot;&gt;Adobe&lt;/a&gt; เองครับ&lt;/p&gt;

&lt;h3 id=&quot;อื่น-ๆ&quot;&gt;อื่น ๆ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/corel_app.png&quot; alt=&quot;Corel App&quot; /&gt;&lt;/p&gt;

&lt;center&gt;แอพกลุ่ม Corels ครับ&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;นอกเหนือจากสองแอพที่กล่าวมาข้างบน ตามในเว็บนั้นก็มีบอกแอพที่ลดราคาเพิ่มเติมได้แก่&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;แอพกลุ่ม VMWare ที่ลดราคาถึง 40%&lt;/li&gt;
  &lt;li&gt;แอพกลุ่ม Corel ที่ลดราคาพอสมควรเลย ได้แก่ แอพ CorelDraw, Painter 2022, Paintshop Pro 2022 Ultimate, Pinnacle Studio 25 Ultimate และ VideoStudio Ultimate 2021&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ส่วนแอพอื่นที่นอกเหนือจากนั้น ลองเปิดหาในอินเตอร์เน็ตเพิ่มเติมได้ครับ จะมีประกาศลดราคาให้เห็นเอง หรือถ้าลดใน App Store หรือ Play Store ก็จะได้เห็นในนั้นครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Black Friday" /><category term="Sale" /><category term="Discount" /><category term="Cheap" /><category term="App" /><category term="App Store" /><category term="Buying" /><category term="ลดราคา" /><category term="ราคาถูก" /><category term="แอพ" /><category term="โปรแกรม" /><category term="แอพลิเคชัน" /><summary type="html">Black Friday เป็นช่วงที่จัดขึ้นหลัง Thanksgiving Day เป็นช่วงที่สินค้าลดราคาหลายชนิด แอพก็เช่นกัน</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/blackfriday_cover_min.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/blackfriday_cover_min.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Enter Programming - จากเรียนแพทย์เข้ามาเขียนโปรแกรมได้ยังไง?</title><link href="https://nickuntitled.com/2021/11/9/enter_programming_how_to_move_from_medical_doctor/" rel="alternate" type="text/html" title="Enter Programming - จากเรียนแพทย์เข้ามาเขียนโปรแกรมได้ยังไง?" /><published>2021-11-09T20:00:00+07:00</published><updated>2021-11-09T20:00:00+07:00</updated><id>https://nickuntitled.com/2021/11/9/being-programming-from-doctor</id><content type="html" xml:base="https://nickuntitled.com/2021/11/9/enter_programming_how_to_move_from_medical_doctor/">&lt;p&gt;บทความนี้เราเขียนเสริมจากที่พูดในคาบของอ. advisor ที่สอนให้ในวิชาเลือกของรพ.ริมน้ำที่เกี่ยวกับการเรียน AI สำหรับทางการแพทย์&lt;/p&gt;

&lt;h2 id=&quot;ช่วงแรก-ก่อนเข้าเรียนหมอ&quot;&gt;ช่วงแรก ก่อนเข้าเรียนหมอ&lt;/h2&gt;

&lt;p&gt;ตอนแรกก่อนเข้าเรียนหมอเรียนภาษา C มาก่อน เรียนเองและเรียนจากค่ายสอวน. คอม (ที่เคยไปถึงโอลิมปิกระดับชาติแล้วได้เหรียญทองแดง) ฝึกตั้งแต่พื้นฐาน, Data Structure &amp;amp; Algorithms และแก้โจทย์ปัญหาบ้างผ่านทางเว็บในสมัยนั้นก็มีเว็บ programming.in.th (ที่ตอนนี้มีหลายเว็บแล้ว เช่น &lt;a href=&quot;https://leetcode.com/&quot;&gt;Leetcode&lt;/a&gt;)&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/c_programming.jpg&quot; alt=&quot;C Programming&quot; /&gt;
&lt;figcaption&gt;ก่อนเรียนหมอ ก็เรียนภาษา C มาก่อนแล้ว&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;ต่อมา เราก็ฝึกเขียน PHP + MySQL เพราะมีพื้นภาษา C อยู่แล้วนี่ แถมได้เขียนเว็บทางฝั่ง Front-end ด้วย HTML, CSS, JavaScript (สมัยนั้นใช้ jQuery เพราะมันฮิตด้วย แถมมันติดมากับ Bootstrap เวอร์ชัน 3-4)&lt;/p&gt;

&lt;p&gt;ช่วงนี้เราเขียนหน้าเว็บให้กับทางคณะฯ มาบ้าง แต่พอขึ้นคลินิกก็ไม่ได้เขียนเลย ก็งานยุ่งนี่ครับ แค่ทบทวนเรื่องที่เรียนบนชั้นคลินิกเวลาก็หมดเสียแล้ว&lt;/p&gt;

&lt;h2 id=&quot;หลังเรียนจบหมอ&quot;&gt;หลังเรียนจบหมอ&lt;/h2&gt;

&lt;p&gt;เมื่อเรียนจบพอมาใช้ทุนสธ. ก็ไม่ได้เขียนเลย เพราะแค่ลงเวรมาก็อยากจะนอน ไม่อยากอ่านอะไรเพิ่ม ก็มันไม่มีเวลาอ่ะคุณ แต่พอคิดไปคิดมา ไม่ได้อยากเป็นหมอแต่แรกแล้ว พอใช้ไปสักพักก็ลาออกมา จ่ายเงินสองแสนกว่าบาท&lt;/p&gt;

&lt;p&gt;แล้วเลือกเรียนต่อวิศวะชีวการแพทย์ ที่เลือกม.มหิดลเพราะเป็นแห่งแรก ๆ และมีอาจารย์ที่ทำเรื่องนี้ เราเลยเลือกสอบและสัมภาษณ์เข้าไป ก็เข้าไปเรียน&lt;/p&gt;

&lt;h2 id=&quot;เข้าเรียนวิศวะชีวการแพทย์&quot;&gt;เข้าเรียนวิศวะชีวการแพทย์&lt;/h2&gt;

&lt;p&gt;ตอนเรียนมีปรับพื้นฐานของวิศวะ ก็มีพวกคณิตศาสตร์ที่ใช้ มีตั้งแต่แคลคูลัส, Differential Equation, Probability เป็นต้น อย่างไรก็ดี ตอนเรียนที่แพทย์จุฬาฯ ไม่มีสอน Calculus 1 เราเลยซื้อหนังสือแคลคูลัส 1 มาอ่านแล้วทำโจทย์เอง แถมค้นหาข้อมูลเพิ่มเติมในอินเตอร์เน็ตที่มีสอนฟรี เราก็ฝึกไปก่อน นอกจากเรียนเลขแล้วยังมีเรียน Signals, Image Processing, Bioimage Informatics และอื่น ๆ&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/face_detection_python.jpg&quot; alt=&quot;Face Detection&quot; /&gt;
&lt;figcaption&gt;หลังเข้าเรียน ก็ได้ฝึกเขียน Python และศึกษาเรื่อง Computer Vision เช่น Face Detection แบบในภาพ&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;แล้วเข้าไปแล็บที่เป็น AI ครับ ตอนนี้แหละ (Artificial Intelligence in Medicine) ได้ฝึกเขียนโปรแกรม เลยเอาภาษาไพทอนนี่แหละมาฝึก เพราะภาษาไพทอนเป็นภาษาที่ฝึกได้ง่าย ตัวโค้ดเขียนเข้าใจง่าย ฝึกไม่นานก็เขียนได้แล้ว&lt;/p&gt;

&lt;p&gt;ต่อมาเราเลยศึกษาพวกไลบรารีไพทอนที่จำเป็นที่เกี่ยวข้องกับงานด้าน Computer Vision เช่น OpenCV, Numpy, Matplotlib, PyTorch, Tensorflow, ONNX runtime เป็นต้น&lt;/p&gt;

&lt;p&gt;พอศึกษาแล้วเขียนพอได้ระดับหนึ่ง ก็ต้องทำตัวเว็บเซิร์ฟเวอร์ แล้วจะเอาตัวไหนดี ตอนแรกจะเอา Django มันจะดูยากไปไหม เลยเลือก Flask ฝึกและใช้งานไประดับหนึ่ง ก็ฝึก FastAPI มาลองใช้ดู ใช้ง่ายแฮะ แต่อันนี้ไม่ได้เอาไปทำตัวเว็บเซิร์ฟเวอร์ ใช้แต่ Flask&lt;/p&gt;

&lt;p&gt;นอกจากทำตัว back-end แล้วก็ต้องทำ front-end เลยฝึก HTML, JS, CSS ใหม่อีกที ฝึกไม่นานก็ทำหน้าเว็บได้ และช่วงนี้ก็ฝึก Framework ในปัจจุบัน อย่าง ReactJS, GraphQL (Apollo Server &amp;amp; Client) เป็นต้น แถมสมัยนี้ใช้ Container กัน ก็ฝึกใช้ Docker, docker-compose เลย (แต่ตอนนั้นยังไม่ได้ฝึก Kubernetes)&lt;/p&gt;

&lt;h2 id=&quot;หลังจากนี้&quot;&gt;หลังจากนี้&lt;/h2&gt;

&lt;p&gt;ต่อไปหลังจากนี้ เราก็เดี๋ยวฝึกอันที่คนใช้กันเยอะ เช่น Django, FastAPI, Svelte, Tailwind CSS, NoSQL (MongoDB) และอื่น ๆ รวมถึงฝึกพื้นฐานอย่าง Math, Data Structure, Algorithm, Data Science และอื่น ๆ ที่จำเป็นต้องกรทำงานครับ&lt;/p&gt;

&lt;p&gt;เดี๋ยวฝึกแล้วได้อะไร จะเอามาเขียนในนี้ในโพสต่อ ๆ ไปครับ ขอบคุณผู้อ่านที่ติดตามครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Doctor" /><category term="Programming" /><category term="Medicine" /><category term="Programmer" /><category term="Job" /><category term="Python" /><category term="JavaScript" /><category term="JS" /><category term="C" /><category term="HTML" /><category term="CSS" /><category term="Engineering" /><category term="Career" /><category term="Biomedical" /><category term="สายงาน" /><category term="เปลี่ยนสาย" /><category term="เปลี่ยนอาชีพ" /><category term="หมอ" /><category term="แพทย์" /><category term="โปรแกรมเมอร์" /><category term="เขียนโปรแกรม" /><category term="โปรแกรมมิง" /><category term="วิศวกรรมศาสตร์" /><category term="วิศวกร" /><category term="วิศวชีวการแพทย์" /><summary type="html">ก่อนหน้านี้เรียนหมอไม่ค่อยได้ฝึกเขียนโปรแกรมอะไร จนมาที่เรียนวิศวะชีวการแพทย์ ที่เขียนโปรแกรมได้ในระดับหนึ่งแล้ว ในบทความนี้จะพูดว่ามาเขียนโปรแกรมได้อย่างไรครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/enter_programming_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/enter_programming_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Redis Queue - ตัวช่วยให้งานบน Web Server เป็น Asynchronous</title><link href="https://nickuntitled.com/2021/11/7/redis_queue_for_asynchronous_task_web_server/" rel="alternate" type="text/html" title="Redis Queue - ตัวช่วยให้งานบน Web Server เป็น Asynchronous" /><published>2021-11-07T17:30:00+07:00</published><updated>2021-11-07T17:30:00+07:00</updated><id>https://nickuntitled.com/2021/11/7/redis-queue-python</id><content type="html" xml:base="https://nickuntitled.com/2021/11/7/redis_queue_for_asynchronous_task_web_server/">&lt;p&gt;ปกติเวลาที่ฝั่ง Client ส่งข้อมูลไปที่ Server แล้ว เราจะรอระยะเวลาไม่นาน จากนั้น Server จะส่งข้อมูลกลับทาง Client ไว้สำหรับการประมวลผลต่อ ทีนี้เวลาที่เราส่งข้อมูลที่ใช้ระยะเวลาประมวลผลนานไปยัง Server แล้วประมวลผลผ่านไปซักพัก จะเกิดปัญหาหนึ่งคือ Request Timeout&lt;/p&gt;

&lt;p&gt;เมื่อเกิดปัญหา Timeout แล้ว เราต้องการแก้ปัญหานี้ จะทำอย่างไร? ปัญหานี้ที่เคยอ่านในอินเตอร์เน็ตก็มีหลายวิธี ตัวอย่างเช่น แก้ที่ตัวเว็บเซิร์ฟเวอร์ว่าตั้งค่าให้มีระยะเวลานานเท่าไรก่อนที่จะขึ้นว่า Timeout หรือว่าไปแก้ที่ตัวโค้ดให้ใช้เวลาประมวลผลที่สั้นลง&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี กรณีที่ตัวโค้ดมันแก้ไปให้ทำงานสั้นลงได้ลำบาก ตัวอย่างก็เป็นงานด้าน AI/ML ที่ต้องนำภาพมาประมวลผลเพื่อหาใบหน้าในภาพ (Face Detection) อันนี้มีวิธีหนึ่งที่ช่วยแก้ปัญหาได้คือใช้ตัว Redis Queue&lt;/p&gt;

&lt;p&gt;แต่ก่อนอื่น เรามาแนะนำ Redis&lt;/p&gt;

&lt;h2 id=&quot;redis&quot;&gt;Redis&lt;/h2&gt;

&lt;p&gt;Redis เป็นโปรแกรมฐานข้อมูลที่เป็น Open source ที่เก็บโครงสร้าง และข้อมูลไว้บน Memory โดยเราสามารถใช้งานเป็นฐานข้อมูลชั่วคราว หรือใช้ในการเก็บ Cache รวมถึงใช้ในการจัดการ Queue เพื่อไว้ใช้ประมวลผลสำหรับฟังก์ชันที่ต้องใช้ระยะเวลาประมวลผลที่มีระยะเวลานาน&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี เราจะนำโปรแกรมนี้มาใช้งานแทนโปรแกรมฐานข้อมูลที่มีอยู่เดิมไม่ได้ทุกกรณี แต่ในบทความนี้เราจะเอามาใช้งานเรื่อง Queue ครับ&lt;/p&gt;

&lt;p&gt;อ่านเพิ่มเติมได้ตามอินเตอร์เน็ตเลย อันนี้เป็น&lt;a href=&quot;https://www.borntodev.com/2020/07/14/redis-101/&quot;&gt;ตัวอย่างหนึ่งครับ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ต่อจาก Redis แล้ว ต้องมีตัวช่วยคือ Redis Queue&lt;/p&gt;

&lt;h2 id=&quot;redis-queue&quot;&gt;Redis Queue&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://python-rq.org/&quot;&gt;Redis Queue&lt;/a&gt; เป็นไลบรารีหนึ่งในภาษาไพทอนที่มีหน้าที่จัดการคิว และประมวลผลฟังก์ชันที่ต้องใช้ระยะเวลานานให้อยู่เบื้องหลังโดยการใช้ตัว Workers ไลบรารีนี้ใช้ฐานข้อมูล Redis สำหรับการจัดการเรื่อง Queue ครับ ไลบรารีนี้มีข้อดีคือจัดการกับ Queue ได้ง่ายกว่าการใช้ไลบรารีอย่าง &lt;a href=&quot;https://www.fullstackpython.com/celery.html&quot;&gt;Celery&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;การติดตั้ง-และเขียนโค้ด&quot;&gt;การติดตั้ง และเขียนโค้ด&lt;/h2&gt;

&lt;p&gt;การติดตั้งไลบรารี และเขียนโค้ดขึ้นมาทำได้ไม่ยากจนเกินไปครับ เราสามารถติดตั้งได้โดย&lt;/p&gt;

&lt;h3 id=&quot;1-ติดตั้งฐานข้อมูล-redis&quot;&gt;1. ติดตั้งฐานข้อมูล Redis&lt;/h3&gt;

&lt;p&gt;เราสามารถติดตั้งฐานข้อมูล Redis ได้หลายวิธี แต่วิธีที่ง่ายกว่าวิธีอื่น เพราะไม่ต้องติดตั้ง หรือตั้งค่าอะไรซับซ้อน ก็คือการใช้ Container ผ่านการใช้เครื่องมืออย่าง Docker&lt;/p&gt;

&lt;p&gt;เราพิมพ์คำสั่งตามด้านล่างนี้ก็ติดตั้งได้เลยครับ ขั้นแรกเป็นการดึงตัว Container จากฐานข้อมูล Docker Hub&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ต่อมา เริ่มการทำงานตัว Container ของ Redis&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 6379:6379 redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์คำสั่งตามนี้แล้ว ตัว Container Docker ของ Redis ก็ทำงานเรียบร้อยครับ&lt;/p&gt;

&lt;h3 id=&quot;2-ติดตั้งไลบรารีที่จำเป็นของไพทอน&quot;&gt;2. ติดตั้งไลบรารีที่จำเป็นของไพทอน&lt;/h3&gt;

&lt;p&gt;เราติดตั้งไลบรารีที่จำเป็นของไพทอนได้โดยการใช้คำสั่ง pip หรือ conda หรืออย่างอื่นก็ได้ แต่ในบทความนี้จะใช้คำสั่ง pip โดยติดตั้งผ่านการสร้างโดยใช้คำสั่ง &lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;virtualenv&lt;/a&gt; ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install redis rq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;เมื่อพิมพ์คำสั่งแล้วกด Enter เราจะรอให้ตัวโปรแกรมติดตั้งไลบรารีครับ เมื่อติดตั้งเสร็จแล้ว เราสามารถเรียกใช้ไลบรารีทั้งสองได้แล้วครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ส่วนใครที่ใช้ Container เราเขียนเพิ่มได้ในที่ไฟล์ requirements.txt หรืออื่น ๆ ตามที่เราใช้งานอยู่ได้ครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3-การเรียกใช้งาน&quot;&gt;3. การเรียกใช้งาน&lt;/h3&gt;

&lt;p&gt;เราสามารถเขียนเพื่อใช้งานตัว Redis Queue ได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from redis import Redis
from rq import Queue, Connection
from rq.job import Job
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-การเชื่อมต่อเข้ากับฐานข้อมูล-redis&quot;&gt;4. การเชื่อมต่อเข้ากับฐานข้อมูล Redis&lt;/h3&gt;

&lt;p&gt;เราเชื่อมต่อกับฐานข้อมูลของ Redis ได้โดยใช้คำสั่งในไลบรารี redis ที่เราติดตั้งในขั้นตอนก่อนหน้านี้ได้โดยการพิมพ์คำสั่งตามด้านล่างครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis_conn = Redis(host URL, port)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;host URL คือที่อยู่ของเซิร์ฟเวอร์ที่ติดตั้งฐานข้อมูล Redis ไว้ ในกรณีนี้อยู่ในคอมเครื่องเดียวกัน เราพิมพ์ localhost แทนได้ แต่ถ้าอยู่ใน Container อาจจะต้องพิมพ์เป็นอย่างอื่นแทน ส่วน port ก็คือ port ของเซิร์ฟเวอร์ที่ลงตัว Redis ครับ&lt;/p&gt;

&lt;p&gt;สำหรับการตั้งค่าอื่นเพิ่มเติม สามารถ&lt;a href=&quot;https://python-rq.org/docs/connections/&quot;&gt;อ่านได้ในหน้านี้&lt;/a&gt;ครับ&lt;/p&gt;

&lt;h3 id=&quot;4-การส่งฟังก์ชันที่ใช้เวลาประมวลผลนานไว้บน-redis-สำหรับ-queue&quot;&gt;4. การส่งฟังก์ชันที่ใช้เวลาประมวลผลนานไว้บน Redis สำหรับ Queue&lt;/h3&gt;

&lt;p&gt;การส่งฟังก์ชันที่ใช้ระยะเวลาประมวลผลนานไว้บน Redis สำหรับ Queue เพื่อให้ตัว Redis Worker ใช้งานฟังก์ชันนั้นในเบื้องหลัง แทนที่จะประมวลผลบน HTTP server สามารถทำได้ไม่ยาก เพียงใช้ฟังก์ชันที่มีอยู่ใน Redis Queue ที่มีชื่อว่า Enqueue&lt;/p&gt;

&lt;p&gt;เราเรียกใช้ฟังก์ชัน Enqueue ได้โดยการพิมพ์ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q = Queue(connection=redis_conn)
job = q.enqueue(long_running_function,  argument)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตรงที่พิมพ์ long_running_function เป็นฟังก์ชันอะไรก็ได้ที่ใช้เวลาประมวลผลนานมากกว่าปกติ โดยฟังก์ชันนี้ต้องอยู่ในไฟล์ไพทอนที่__ไม่ใช่__ไฟล์หลักที่เริ่มต้นใช้งานครับ  ตัวอย่างการใช้งานดูได้ตามด้านล่างนี้ เราจะแบ่งไฟล์เป็นสองไฟล์คือไฟล์ task.py ที่ใส่ฟังก์ชันหนึ่งที่ใช้ระยะเวลาทำงานนานมากกว่าปกติ ส่วนไฟล์ main.py เป็นไฟล์หลักที่เริ่มต้นทำงานครับ&lt;/p&gt;

&lt;h4 id=&quot;ไฟล์-taskpy&quot;&gt;ไฟล์ task.py&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time

def long_running_function(seconds):
    print(&quot;Starting num task&quot;)
    for num in range(seconds):
        print(num)
        time.sleep(1)
    print(&quot;Task to print_numbers completed&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ไฟล์หลัก-mainpy&quot;&gt;ไฟล์หลัก main.py&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from redis import Redis
from rq import Queue, Connection
from task import long_running_function

redis_conn = Redis(&apos;127.0.0.1&apos;, 6379)
q = Queue(connection=redis_conn)
job = q.enqueue(long_running_function,  5)
job_id = job.id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ทดลองเริ่มต้นการทำงานโดยพิมพ์คำสั่งตามข้อที่ 6 และ 7 ครับ  ผลลัพธ์ที่ได้จะแสดงตามด้านล่างนี้&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10:00:29 default: task.long_running_function(5) (XXXX)
Starting num task
0
1
2
3
4
Task to print_numbers completed
10:00:34 default: Job OK (XXX)
10:00:34 Result is kept for 500 seconds
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แสดงว่าฟังก์ชันนี้ทำงานไดสำเร็จโดยไม่มีปัญหาอะไรครับ&lt;/p&gt;

&lt;h4 id=&quot;กรณีที่มีมากกว่าหนึ่ง-argument&quot;&gt;กรณีที่มีมากกว่าหนึ่ง Argument&lt;/h4&gt;

&lt;p&gt;ส่วนกรณีที่มีมากกว่าหนึ่ง Argument เราสามารถดูตัวอย่างได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q = Queue(connection=redis_conn)
job = q.enqueue(long_running_function,  
        args=(&apos;http://nvie.com&apos;,),
        kwargs={
            &apos;description&apos;: &apos;Function description&apos;, # This is passed on to count_words_at_url
            &apos;ttl&apos;: 15  # This is passed on to count_words_at_url function
        }))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;นอกจากนี้ เราสามารถเพิ่มการตั้งค่าของคำสั่ง enqueue เพิ่มเติมได้ตามหน้านี้ของ&lt;a href=&quot;https://python-rq.org/docs/&quot;&gt;เว็บไลบรารี Redis Queue&lt;/a&gt; ครับ&lt;/p&gt;

&lt;h4 id=&quot;การทำงานของฟังก์ชัน-enqueue&quot;&gt;การทำงานของฟังก์ชัน enqueue&lt;/h4&gt;

&lt;p&gt;เมื่อใส่คำสั่งนี้แล้ว ตัวโปรแกรมจะส่งฟังก์ชันนี้ไว้ใน Queue ของ Redis แล้ว ตัว Workers จะนำฟังก์ชันใน Queue นั้น ๆ มาประมวลผลครับ&lt;/p&gt;

&lt;p&gt;ตัวคำสั่ง enqueue จะคืนค่าชนิดตัวแปรที่มีชื่อเรียกว่า &lt;a href=&quot;https://python-rq.org/docs/jobs/&quot;&gt;Job&lt;/a&gt; ในตัวแปร job ตามที่เขียนไว้ข้างบนนี้ เราสามารถเรียกตัว id สำหรับการติดตามความก้าวหน้าได้โดยพิมพ์ job.id ครับ&lt;/p&gt;

&lt;h3 id=&quot;5-การติดตามความก้าวหน้าของการทำงานฟังก์ชัน&quot;&gt;5. การติดตามความก้าวหน้าของการทำงานฟังก์ชัน&lt;/h3&gt;

&lt;p&gt;หลังจากที่ได้ตัว id มาเรียบร้อยแล้ว เราสามารถติดตามการทำงานของฟังก์ชันที่ประมวลผลอยู่ใน Workers ได้โดยการพิมพ์คำสั่งตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;job = Job.fetch(&apos;job_id&apos;, connection=redis_conn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;พิมพ์คำสั่งนี้แล้ว ตัวฟังก์ชันจะคืนค่าตัวแปร Job เพื่อใช้สำหรับการประมวลผลในขั้นตอนต่อไป เราติดตามความก้าวหน้าของฟังก์ชันได้โดยพิมพ์คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;status = job.get_status()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ตัวฟังก์ชันนี้จะคืนค่าสถานะของฟังก์ชันที่ทำงานอยู่ โดยสถานะนี้แบ่งได้เป็น queued, started, deferred, finished, stopped, scheduled, canceled และ failed ครับ ผู้อ่านนำไปประยุกต์ใช้เพื่อติดตามความก้าวหน้าของฟังก์ชันได้ครับ&lt;/p&gt;

&lt;p&gt;ส่วนของผมจะเช็คว่าฟังก์ชันนี้ทำงานได้สำเร็จ หรือไม่สำเร็จ หรืออื่น ๆ หรือไม่ เราพิมพ์ได้ตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;h4 id=&quot;ตัวอย่างที่ใช้การวนลูปในไพทอน&quot;&gt;ตัวอย่างที่ใช้การวนลูปในไพทอน&lt;/h4&gt;

&lt;p&gt;เราเพิ่มการนำเข้าไลบรารีเป็น&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from time import sleep
import json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;แล้วพิมพ์โค้ดเพิ่มตามด้านล่างนี้ (โค้ดส่วน setInterval เอามาจากเว็บ Stackoverflow)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def call_at_interval(period, callback, args):
    while True:
        sleep(period)
        if callback(*args) == False:
            break

def setInterval(period, callback, *args):
    Thread(target=call_at_interval, args=(period, callback, args)).start()

def polling(job_id):
    job = Job.fetch(job_id, connection=redis_conn)
    status = job.get_status()
    result = job.result

    if status == &apos;finished&apos;:
        print(json.dumps({
            &apos;status&apos;: &apos;success&apos;,
            &apos;result&apos;: result
        }))
        return False
    elif status == &apos;failed&apos;:
        print(json.dumps({
            &apos;status&apos;: &apos;failed&apos;,
            &apos;result&apos;: result
        }))
        return False

    print(json.dumps({
      &apos;status&apos;: &apos;processing&apos;
    }))
    return True

setInterval(1, polling, job_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ตัวอย่างที่ใช้ไลบรารีของ-flask&quot;&gt;ตัวอย่างที่ใช้ไลบรารีของ Flask&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.route(&apos;/get_status/&amp;lt;string:task_id&amp;gt;&apos;, methods=[&apos;GET&apos;])
def get_status(task_id):
    q = Queue(connection=redis_conn)
    job = Job.fetch(task_id, connection=redis_conn)
    status = job.get_status()
    result = job.result

    if status == &apos;finished&apos;:
        return json.dumps({
          &apos;status&apos;: &apos;success&apos;,
          &apos;result&apos;: result
        })
    elif status == &apos;failed&apos;:
        return json.dumps({
          &apos;status&apos;: &apos;failed&apos;,
          &apos;result&apos;: result
        })

    return json.dumps({
      &apos;status&apos;: &apos;processing&apos;
    })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ส่วน flask ตามข้างบนนี้คืออะไร Flask เป็นไลบรารีที่มีหน้าที่ทำตัว Web server ครับ รายละเอียดของไลบรารีนี้สามารถ&lt;a href=&quot;https://flask.palletsprojects.com/en/2.0.x/&quot;&gt;อ่านเพิ่มเติมได้ที่นี่ครับ&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-การเริ่มต้น-workers&quot;&gt;6. การเริ่มต้น Workers&lt;/h3&gt;

&lt;p&gt;เราเรียกใช้งานตัว Workers ได้โดยพิมพ์คำสั่งตามด้านล่างนี้ครับ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rq worker --with-scheduler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;จากนั้นเรียกใช้งานไฟล์ไพทอนตามปกติ&lt;/p&gt;

&lt;h3 id=&quot;7-การเริ่มต้นตัวโปรแกรม&quot;&gt;7. การเริ่มต้นตัวโปรแกรม&lt;/h3&gt;

&lt;p&gt;เราเริ่มต้นตัวโปรแกรมที่ใช้ Redis Queue ตามข้างบนที่ผ่านมานี้ได้โดยใช้คำสั่ง&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python &amp;lt;ชื่อไฟล์ .py&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;หรือกรณีที่ใช้ Flask, FastAPI หรืออื่น ๆ เราสามารถเรียกใช้งานผ่าน gunicorn, uvicorn, uWSGI ได้ครับ&lt;/p&gt;

&lt;h3 id=&quot;8-เพิ่มเติม&quot;&gt;8. เพิ่มเติม&lt;/h3&gt;

&lt;p&gt;ฟังก์ชันอื่น ๆ ที่มีอยู่ในไลบรารี Redis Queue ผู้อ่านเข้าไปอ่านที่&lt;a href=&quot;https://python-rq.org/&quot;&gt;หน้าเว็บไซต์ตามลิ้งค์นี้ได้ครับ&lt;/a&gt; ตัว Reference ที่มีอยู่ในเว็บไซต์เข้าใจได้ไม่ยากจนเกินไปครับ&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;ปกติการเรียกใช้งาน HTTP Request ทั่ว ๆ ไป เราจะเรียกจากตัว Client แล้วให้ทาง Server ประมวลผลตามปกติ ทีนี้กรณีที่ใช้ฟังก์ชัันที่ใช้ระยะเวลาการประมวลผลนานมากกว่าปกติ จะทำให้เกิด Timeout ขึ้นมา การใช้งานไลบรารี Redis Queue สามารถแก้ปัญหาที่จุดนี้ได้โดย&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Server รับ Request จากทาง Client แล้วใช้คำสั่งตามข้อที่ 3-5 เพื่อส่งฟังก์ชันนั้นไว้ใน Queue ของ Redis แล้วให้ทาง Workers ประมวลผลต่อ&lt;/li&gt;
  &lt;li&gt;เมื่อส่ง Queue ไปแล้ว เราต้องการค่า job_id ออกมา แล้วติดตามความก้าวหน้าของฟังก์ชันนั้น โดยทำตามข้อที่ 4-5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ซึ่ง เราได้ทดลองใช้กับ web server ที่เขียนโดย Flask ไปแล้ว ตัว Redis Queue แก้ปัญหาเรื่อง Request Timeout ระหว่างการประมวลผลฟังก์ชันที่ต้องใช้ระยะเวลาประมวลผลนานครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Redis" /><category term="Programming" /><category term="Python" /><category term="Redis Queue" /><category term="HTTP" /><category term="Web server" /><category term="Flask" /><category term="Worker" /><category term="ไพทอน" /><category term="เขียนโปรแกรม" /><summary type="html">ปัญหาหนึ่งเวลาที่เขียนหน้าเว็บเพื่อส่งข้อมูลสำหรับการประมวลผลที่ใช้เวลานานไปคือเกิด Request Timeout ในบทความนี้จะแนะนำตัวช่วยหนึ่งที่มีชื่อว่า Redis Queue</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/redis_queue_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/redis_queue_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hello World ใน Python, JS และ C++</title><link href="https://nickuntitled.com/2021/11/5/hello_world/" rel="alternate" type="text/html" title="Hello World ใน Python, JS และ C++" /><published>2021-11-05T08:00:00+07:00</published><updated>2021-11-05T08:00:00+07:00</updated><id>https://nickuntitled.com/2021/11/5/hello-world</id><content type="html" xml:base="https://nickuntitled.com/2021/11/5/hello_world/">&lt;p&gt;Hello World เป็นโปรแกรมที่เขียนขึ้นมาเพื่อแสดงผลหน้าจอว่า “Hello World” ซึ่งเป็นสิ่งที่พบได้ในทุกภาษา และมีไว้แสดงลักษณะการเขียนในภาษาเขียนโปรแกรมนั้น ๆ (Syntax) นอกเหนือจากนี้แล้วการเขียนโปรแกรมนี้ขึ้นมามีหน้าที่ทดสอบว่า เราติดตั้งแล้วสามารถใช้งานตัว Compiler หรือตัว Interpreter ว่าทำงานได้ปกติหรือไม่&lt;/p&gt;

&lt;p&gt;ต่อมา เราเขียนทวิตหนึ่งไป แล้วแมสมาพอดี มีโควทหนึ่งในทวิตว่าสนใจที่จะเขียน Hello World เราเลยแสดงให้เห็นว่า การเขียนในภาษาไพทอน จาวาสคริป และ C++ เป็นอย่างไรครับ&lt;/p&gt;

&lt;h2 id=&quot;ภาษาไพทอน&quot;&gt;ภาษาไพทอน&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/hello_world_py.png&quot; alt=&quot;Hello World in Python&quot; /&gt;&lt;/p&gt;

&lt;p&gt;อันนี้เป็น Hello World ในภาษาไพทอน จะพบว่าเขียนได้จบในบรรทัดเดียว สะดวกไหมล่ะ? สำหรับคนที่เพิ่งเขียนโปรแกรม ภาษานี้เราแนะนำครับ เรียนแล้วเอาไปต่อยอดทางด้าน Data Science, AI/ML และอื่น ๆ ได้เลย&lt;/p&gt;

&lt;h2 id=&quot;ภาษาจาวาสคริป&quot;&gt;ภาษาจาวาสคริป&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/hello_world_js.png&quot; alt=&quot;Hello World in JS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;อันนี้เป็น Hello World ในภาษาจาวาสคริป จะพบว่าเขียนได้จบในบรรทัดเดียวเช่นกัน สะดวกไหมล่ะ? สำหรับคนที่เพิ่งเขียนโปรแกรม ภาษานี้เราก็แนะนำครับ เรียนแล้วเอาไปต่อยอดทำเว็บได้ทั้ง Front-end, Back-end รวมถึงทำโปรแกรมบนเดสก์ท็อป มือถือได้ครับ&lt;/p&gt;

&lt;h2 id=&quot;ภาษา-c&quot;&gt;ภาษา C++&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/11/hello_world_cpp.png&quot; alt=&quot;Hello World in CPP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;อันนี้เป็น Hello World ในภาษา C++ จะพบว่าเขียนได้ไม่จบในบรรทัดเดียวเช่นกัน อย่างไรก็ดีภาษานี้ใครเรียนคอมในโรงเรียน หรือในมหาวิทยาลัยก็จะได้เจอกัน ส่วนตัวภาษานี้อาจจะยากไปนิดสำหรับคนที่เพิ่งเขียนโปรแกรม แต่ถ้าเขียนเป็นแล้วนี่เอาไปต่อยอดได้อีกเยอะครับ เช่นพัฒนาเกม, พัฒนาลงอุปกรณ์ IoT (Internet of Things), ฐานข้อมูล เป็นต้น&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถอ่านได้ใน&lt;a href=&quot;https://www.codecademy.com/resources/blog/what-is-c-plus-plus-used-for/&quot;&gt;หน้าเว็บของ Codecademy ที่สอนเขียนโปรแกรมได้ครับ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;สำหรับคนที่เพิ่งเขียนโปรแกรม โปรแกรมนี้จะเป็นโปรแกรมแรกที่ได้เขียน เราแสดงให้เป็นตัวอย่างใน 3 ภาษาได้แก่ ไพทอน จาวาสคริป และ C++ ที่จะเห็นว่าโค้ดในสองภาษาแรกสามารถเขียนได้ในบรรทัดเดียว ส่วนตัวเราแนะนำให้เริ่มเขียนทั้งสองภาษานี้ก่อนครับ พอเขียนเป็นแล้วจะไปเรียนต่อภาษาอื่นก็ทำได้เช่นกันครับผม&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Computer" /><category term="Hello World" /><category term="Programming" /><category term="Newbie" /><category term="เขียนโปรแกรม" /><category term="Python" /><category term="JavaScript" /><category term="JS" /><category term="C++" /><category term="CPP" /><category term="มือใหม่" /><category term="ไพทอน" /><category term="จาวาสคริป" /><summary type="html">Hello World เป็นสิ่งที่ผู้ที่เริ่มต้นเขียนโปรแกรมจะได้สัมผัส และเขียนขึ้นมา ในบทความนี้จะแสดงการเขียนในแต่ละภาษาครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/11/hello_world_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/11/hello_world_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">นักเรียนเลว - สนับสนุนเพื่อทวงสิทธิเสรีภาพ และอนาคตของนร.</title><link href="https://nickuntitled.com/2021/10/31/support-bad-student/" rel="alternate" type="text/html" title="นักเรียนเลว - สนับสนุนเพื่อทวงสิทธิเสรีภาพ และอนาคตของนร." /><published>2021-10-31T14:10:30+07:00</published><updated>2021-10-31T14:10:30+07:00</updated><id>https://nickuntitled.com/2021/10/31/support-badstudent</id><content type="html" xml:base="https://nickuntitled.com/2021/10/31/support-bad-student/">&lt;p&gt;กลุ่มนักเรียนเลว เป็นกลุ่มที่ได้รับการก่อตั้งเพื่อเคลื่อนไหวประเด็นทางด้านสิทธิ เสรีภาพ และทวงอนาคตสำหรับนักเรียนไทย ที่มาของชื่อกลุ่มนี้มาจากคำกล่าวที่ผู้ใหญ่จะกล่าวว่า “เป็นเด็กจะต้องเชื่อฟังผู้ใหญ่” แล้วทีนี้ผู้ก่อตั้ง และกลุ่มไม่ได้เชื่อฟังไปเสียทั้งหมดซึ่งก็ขัดตามคำที่ผู้ใหญ่บอก ตามที่&lt;a href=&quot;https://www.matichonweekly.com/column/article_345406&quot;&gt;ผู้ก่อตั้งกลุ่ม (มิน) สัมภาษณ์ไว้ในบทความนี้&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;สำหรับคนที่ไม่ทราบว่ากลุ่มนี้เคลื่อนไหวอะไรบ้าง กลุ่มนักเรียนเลวเคลื่อนไหวเกี่ยวกับ&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;การประท้วงกฎเกณฑ์เรื่องทรงผมในโรงเรียน&lt;/li&gt;
  &lt;li&gt;การจัดขบวนเดินเท้าเรียกร้องความเท่าเทียมทางเพศ&lt;/li&gt;
  &lt;li&gt;ปัญหาอำนาจนิยมในสถานศึกษา&lt;/li&gt;
  &lt;li&gt;การหยุดคุกคาม และล่วงละเมิดทางเพศในนักเรียน&lt;/li&gt;
  &lt;li&gt;การร่วมกิจกรรมวิ่งแฮมทาโร่&lt;/li&gt;
  &lt;li&gt;เป็นต้น&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;รวมถึงการจัดกิจกรรมเพื่อแก้ปัญหาเรียนออนไลน์ในที่ผ่านมา ที่มีแฮชแทคว่า &lt;a href=&quot;https://twitter.com/search?q=%23%E0%B9%84%E0%B8%A1%E0%B9%88%E0%B9%80%E0%B8%A3%E0%B8%B5%E0%B8%A2%E0%B8%99%E0%B8%AD%E0%B8%AD%E0%B8%99%E0%B9%84%E0%B8%A5%E0%B8%99%E0%B9%8C%E0%B9%81%E0%B8%A5%E0%B9%89%E0%B8%A7%E0%B8%AD%E0%B8%B4%E0%B8%AA%E0%B8%B1%E0%B8%AA&amp;amp;src=trend_click&amp;amp;vertical=trends&quot;&gt;#ไม่เรียนออนไลน์แล้วอิสัส&lt;/a&gt; ที่จัดกิจกรรมเพื่อแสดงออกเรื่องปัญหาการเรียนออนไลน์ที่ขาดประสิทธิภาพครับ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี การจัดกิจกรรมในแต่ละครั้ง หรือจะทำอะไรก็ตามก็ต้องมีต้นทุนซึ่งเป็นปัญหาหลักเลยว่าจะหาเงินให้มันเพียงพอได้อย่างไร กลุ่มนี้เช่นกันตามที่ทีมงานในกลุ่มนี้กล่าวไว้ ก็ต้องมี&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ต้นทุนสำหรับค่าเดินทาง&lt;/li&gt;
  &lt;li&gt;ค่าเช่าออฟฟิสสำหรับการประชุม&lt;/li&gt;
  &lt;li&gt;ค่าน้ำ ค่าไฟ&lt;/li&gt;
  &lt;li&gt;และอินเตอร์เน็ตเพื่อดำเนินงานครับ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ที่ทางกลุ่มต้องการการสนับสนุนเพิ่มเติม แล้วเราจะสนับสนุนได้อย่างไร?&lt;/p&gt;

&lt;p&gt;ผู้อ่านสามารถสนับสนุนการเคลื่อนไหวเพื่อทวงสิทธิ เสรีภาพ และอนาคตสำหรับนักเรียนไทยได้โดยการโอนเข้าบัญชีตามโพสทวิตเตอร์ของกลุ่มด้านล่างนี้ครับ&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;th&quot; dir=&quot;ltr&quot;&gt;เป็นส่วนหนึ่งในการทวงคืนสิทธิของนักเรียนกลับคืนมา ด้วยการสนับสนุนพวกเรา เพื่อให้นักเรียนเลวสามารถเคลื่อนไหว ทำกิจกรรม และผลิตเนื้อหาต่าง ๆ สู่สังคมต่อไปได้&lt;br /&gt;&lt;br /&gt;ผ่านทางธนาคารกสิกรไทย เลขที่บัญชี&lt;br /&gt;093-8-26583-6 ชื่อบัญชี ธญานี และ ลภนพัฒน์ และ ภาณุพงศ์&lt;br /&gt;——&lt;a href=&quot;https://twitter.com/hashtag/%E0%B8%99%E0%B8%B1%E0%B8%81%E0%B9%80%E0%B8%A3%E0%B8%B5%E0%B8%A2%E0%B8%99%E0%B9%80%E0%B8%A5%E0%B8%A7?src=hash&amp;amp;ref_src=twsrc%5Etfw&quot;&gt;#นักเรียนเลว&lt;/a&gt; &lt;a href=&quot;https://t.co/TLK7GzWiTD&quot;&gt;pic.twitter.com/TLK7GzWiTD&lt;/a&gt;&lt;/p&gt;&amp;mdash; นักเรียนเลว (@BadStudent_) &lt;a href=&quot;https://twitter.com/BadStudent_/status/1453998308855148549?ref_src=twsrc%5Etfw&quot;&gt;October 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;ส่วนผู้อ่านจะติดตามเพจนี้ต่อได้อย่างไร? เราสามารถติดตามกลุ่มนี้ได้ใน&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/Badstudent.th/&quot;&gt;Facebook&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/BadStudent_&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ได้เลยครับ ส่วนหน้าเว็บของกลุ่มนี้ ไม่มีครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;เพิ่มเติม&lt;/strong&gt;&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;ผู้เขียนไม่ได้เป็นทีมงานของกลุ่มนี้ครับ อายุเกินไปหลายปีแล้วคุณ&lt;/li&gt;
    &lt;li&gt;และเราได้สนับสนุนไปเรียบร้อยครับ&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;</content><author><name>nickuntitled</name></author><category term="Diary" /><category term="Badstudent" /><category term="Thai" /><category term="Democracy" /><category term="Student" /><category term="Funding" /><category term="Donation" /><category term="Support" /><category term="นักเรียนเลว" /><category term="นักเรียน" /><category term="ไทย" /><category term="สิทธิเสรีภาพ" /><category term="บริจาค" /><category term="สนับสนุน" /><summary type="html">กลุ่มนักเรียนเลวเป็นกลุ่มที่เคลื่อนไหวประเด็นสิทธิเสรีภาพ และทวงอนาคตสำหรับนักเรียนไทย ในบทความนี้จะกล่าวถึงวิธีการสนับสนุนกลุ่มให้สามารดำเนินงานต่อไปได้ครับ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/10/badstudent_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/10/badstudent_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Windows 11 - การใช้งาน &amp;amp; แอพบน Surface Pro X</title><link href="https://nickuntitled.com/2021/10/30/windows-11-usage-app-surfacepro-x/" rel="alternate" type="text/html" title="Windows 11 - การใช้งาน &amp;amp; แอพบน Surface Pro X" /><published>2021-10-30T02:18:30+07:00</published><updated>2021-10-30T02:18:30+07:00</updated><id>https://nickuntitled.com/2021/10/30/upgrading-to-windows-11</id><content type="html" xml:base="https://nickuntitled.com/2021/10/30/windows-11-usage-app-surfacepro-x/">&lt;p&gt;หลังจากที่ระบบปฏิบัติการของไมโครซอฟท์อย่าง Windows 11 ได้รับการปล่อยให้อัพเดทไปตั้งแต่ต้นเดือนตุลาคมที่ผ่านมา ซึ่งการปล่อยให้อัพเดทจะปล่อยผ่านทาง Windows Update เป็นระยะ แต่เราอัพเดทก่อนได้ผ่านทาง Windows 11 Installation Assistant แต่ในบทความนี้เราจะกล่าวถึงอุปกรณ์ที่ใช้อยู่ที่ใช้ซีพียู ARM เองนั่นก็คือ Surface Pro X&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ในบทความนี้สามารถเอาไปใช้กับคอมพิวเตอร์ที่ใช้ซีพียู ARM ได้นอกเหนือจาก Surface ครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ก่อนที่จะมาพูดถึงการใช้งาน เรามาพูดถึงตัววินโดว์ก่อน&lt;/p&gt;

&lt;h2 id=&quot;windows-11&quot;&gt;Windows 11&lt;/h2&gt;

&lt;p&gt;Windows 11 เป็นระบบปฏิบัติการที่ได้รับการพัฒนาจากบริษัทไมโครซอฟท์ ระบบปฏิบัติการนี้ได้รับการประกาศเปิดตัวไปแล้ววันที่ 24 มิถุนายน 2564 จากนั้นได้รับการปล่อยใน Windows Insider&lt;/p&gt;

&lt;p&gt;ต่อมา Windows 11 ได้รับการปล่อยออกมาเป็นตัวจริงเมื่อวันที่ 5 ตุลาคม 2564 ที่อนุญาตให้เราอัพเกรตจากวินโดว์ 10 ฟรีผ่านทาง Windows Update หรือ Windows 11 Installation Assistant ที่เป็นแอพช่วยให้เราอัพเกรตเป็นวินโดว์ 11 ได้อย่างง่ายดาย เพียงแค่ดาวน์โหลดตัวติดตั้ง แล้วกดปุ่มเข้าไป ตัวแอพจะจัดการให้เราทั้งหมด&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี เราได้ดาวน์โหลด Windows 11 Installation Assistant แล้ว แต่เมื่อเขียนลงไดรฟ์ USB แล้วเสียบกับคอมพิวเตอร์ที่ใช้อยู่ ระบบไม่บูทเข้าสู่หน้าจอการติดตั้งวินโดว์ 11 พอไปเช็คอีกที ตัวแอพดาวน์โหลดเวอร์ชันที่รองรับเฉพาะซีพียูสถาปัตยกรรม x86 64 Bit ครับ เลยเปิดเข้ามาหน้าจอการติดตั้งไม่ได้ครับ&lt;/p&gt;

&lt;p&gt;เหลือทางเลือกหนึ่งคือรอทางไมโครซอฟท์ปล่อยให้อัพเกรตผ่านทาง Windows Update เรารอประมาณเกือบ 1 เดือน ก็ดาวน์โหลดมาอัพเกรตได้ครับ&lt;/p&gt;

&lt;p&gt;ส่วนข่าวที่ปรากฏตั้งแต่การเปิดตัวก็จะมีปัญหาเรื่องของ TPM 2.0 และ Secure Boot ของ UEFI โดย&lt;/p&gt;

&lt;h3 id=&quot;tpm&quot;&gt;TPM&lt;/h3&gt;

&lt;p&gt;TPM (ย่อมาจาก Trusted Platform Module) เป็นชิพที่เกี่ยวข้องกับความปลอดภัยของระบบ ดูแลตั้งแต่เปิดเครื่องจนกระทั่งปิดคอมพิวเตอร์ ชิพตัวนี้เราพบได้ในชิพที่ซื้อมาติดบนเมนบอร์ดเพิ่ม หรือติดมากับ Chipset หรือซีพียูรุ่นใหม่ของ Intel, AMD และ Qualcomm ที่มีคนนำชิพนี้ไปใช้งานด้านการเข้ารหัสข้อมูลบน Disk อย่าง BitLocker, DRM, Anti-cheat ในบางเกม เช่น Valorant ก็ใช้ชิพนี้เช่นกัน&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี Windows 11 ต้องการ TPM 2.0 ส่วนใครใช้รุ่นเก่ากว่า หรือไม่มีตัวนี้ก็อัพเกรตแล้วอาจจะใช้งานได้ไม่เต็มที่ หรือาจจะไม่ได้รับการอัพเดทเพิ่มเติมครับ&lt;/p&gt;

&lt;p&gt;ส่วนสาเหตุที่ต้องการ TPM 2.0 ทาง&lt;a href=&quot;https://www.blognone.com/node/123419&quot;&gt;บริษัท Microsoft ได้ชี้แจงแล้วตามนี้ครับ&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;เราสามารถอ่านข้อมูลเพิ่มเติมได้ใน&lt;a href=&quot;https://en.wikipedia.org/wiki/Trusted_Platform_Module&quot;&gt;หน้านี้ครับ&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;uefi&quot;&gt;UEFI&lt;/h3&gt;

&lt;p&gt;UEFI (ย่อมาจาก Unified Extensible Firmware Interface) เป็นโปรแกรมที่เริ่มทำงานตั้งแต่เปิดคอมพิวเตอร์ที่ทำหน้าที่เชื่อมต่อ ตรวจสอบ และตั้งค่าฮาร์ดแวร์ต่าง ๆ เช่น CPU, RAM, การ์ดจอ และอื่น ๆ เพื่อเริ่มต้นใช้งานในระบบปฏิบัติการต่อไป ตัวนี้มันดีกว่า BIOS เดิมอย่างไร ดีกว่าตรงที่&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;รองรับความจุฮาร์ดดิสก์ที่มีขนาดใหญ่ขึ้นมากกว่าเดิม (9 Zettabytes)&lt;/li&gt;
  &lt;li&gt;บูตเครื่องได้เร็วขึ้น&lt;/li&gt;
  &lt;li&gt;มีฟังก์ชันเกี่ยวกับความปลอดภัยอย่าง Secure Boot ที่ป้องกันการบูตเข้าไปในโปรแกรมที่ไม่ได้รับการรับรอง&lt;/li&gt;
  &lt;li&gt;สามารถทำงานได้ใน 32-bit หรือ 64-bit ในขณะที่ BIOS ยังเป็น 16-bit อยู่เลย&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;สิ่งที่ Windows 11 ต้องการสำหรับการอัพเกรตคือฟังก์ชัน UEFI ที่เปิด Secure Boot เพื่อป้องกันแอพ Malware หรือ Randomware ที่ล็อคไฟล์แล้วต้องจ่ายเงินเพื่อปลดล็อคครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;สำหรับข้อมูลเพิ่มเติม&lt;a href=&quot;https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface&quot;&gt;อ่านที่นี่&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;การใช้งาน&quot;&gt;การใช้งาน&lt;/h2&gt;

&lt;p&gt;หลังจากที่ติดตั้งระบบปฏิบัติการ Windows 11 เรียบร้อยแล้ว เปิดเข้ามาหน้าจอหลักของ Windows แล้วใช้งาน เราจะพบว่าหน้าตา และการใช้งานเปลี่ยนไปพอสมควร ได้แก่&lt;/p&gt;

&lt;h3 id=&quot;1-taskbar&quot;&gt;1. Taskbar&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/taskbar.png&quot; alt=&quot;Windows 11 new taskbar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Taskbar เป็นแถบที่ปรากฏด้านล่างหน้าจอที่ปรากฏไอคอนแอพที่เปิดไว้อยู่ ทีนี้เปลี่ยนจากมุมล่างซ้ายมาอยู่ตรงกางแทน มันดูไม่ค่อยจะสมมาตรกันเท่าไร แถมมีไอคอนที่อยู่มุมล่างขวามาเบียดอีก เราเลยเปลี่ยนให้ไอคอนแอพที่เปิดไว้อยู่ที่มันอยู่ตรงกลาง มาเป็นด้านล่างซ้ายแทน ดูแล้วคล้ายกันกับที่ใช้บน Windows 10&lt;/p&gt;

&lt;p&gt;ต่อมาเมื่อกดปุ่ม Start Menu ออกมาแล้ว เราจะปรากฏเมนูที่ให้เลือกแอพ จุดนี้หน้าตาเปลี่ยนไป ตัวเมนูตัดส่วนที่เราจัดกรุ๊ปแอพตามการใช้งานออกหมด เหลือเพียงแอพที่ติดตั้งอยู่ในคอมพิวเตอร์ อันนี้สำหรับเราไม่ค่อยสะดวกเท่าไร แก้ปัญหาเวลาที่เราอยากใช้แอพตัวไหน ก็พิมพ์ชื่อแอพบนคีย์บอร์ดเลย แอพนั้นจะปรากฏขึ้นมาให้กดเองครับ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/control_center.png&quot; alt=&quot;Windows 11 control center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;สุดท้าย แถบ Control Center ที่เปลี่ยนไป เวลาที่กดมุมล่างขวาของ Windows 10 มันจะขึ้นหน้าต่างการตั้งค่าที่ปรากฏเยอะมาก ตั้งแต่การปรับแสงหน้าจอ ปรับแต่งเสียง การหมุนหน้าจอ ไวไฟ บลูทูธ แต่พอใช้งานใน Windows 11 มีฟังก์ชันหนึ่งที่น่าจะตัดไปคือฟังก์ชันล็อคการหมุนของหน้าจอ ที่เราต้องไปปรับให้หน้าจอ Setting เพื่อปรับทิศทางการหมุนหน้าจอเองว่าจะให้อยู่ในแนวตั้ง แนวนอนครับ&lt;/p&gt;

&lt;h3 id=&quot;2-virtual-desktop&quot;&gt;2. Virtual Desktop&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/virtual_desktop.png&quot; alt=&quot;Windows 11 Virtual Desktop&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ปกติเวลาใช้งานบนวินโดว์จะแสดง Desktop ได้หลายหน้าตั้งแต่ Windows 10 แล้ว พออัพเกรตมาใช้งานบน Windows 11 พบว่าใช้งานได้สะดวกขึ้นมากกว่าเดิม เพียงแค่เอาเมาส์เลื่อนมาไว้บนปุ่มที่สามจากด้านซ้ายสุด แล้วกดปุ่ม จะปรากฏรายการหน้าต่างวินโดว์ที่เปิดไว้อยู่ และหน้า Desktop ที่เราใช้อยู่ครับ เราสามารถเพิ่ม-ลด Desktop ได้ตามที่ต้องการ รวมถึงสามารถเลื่อนหน้าต่างแอพที่เราเปิดไว้ ไปวางบน Desktop อื่นได้ เพื่อไม่ให้หน้าจอรกเกินไป&lt;/p&gt;

&lt;p&gt;ฟังก์ชันนี้ทำให้นึกถึงเวลาที่ใช้งานฟังก์ชัน Mission Control บนระบบปฏิบัติการ MacOS หรือ Virtual Desktop บนระบบปฏิบัติการ Linux ครับ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;การเปิดหน้าจอตามที่กล่าวไว้ เราสามารถทำได้โดยการกดปุ่ม Win + Tab ครับ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3-แอพ&quot;&gt;3. แอพ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/app.png&quot; alt=&quot;Apps on Windows 11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;หลังจากที่อัพเดทเป็นระบบปฏิบัติการ Windows 11 บนคอมพิวเตอร์ที่ใช้ซีพียูสถาปัตยกรรม ARM/ARM64 แล้ว ฟังก์ชันที่เพิ่งเพิ่มมาคือ&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;เราสามารถเปิดใช้งานแอพที่เป็น x86 64-bit&lt;/li&gt;
  &lt;li&gt;กรณีที่ผู้พัฒนาต้องการพอร์ตแอพจาก x86 64-bit มาใช้บน ARM64 แต่ไลบรารีบางส่วนไม่รองรับก็สามารถคอมไพล์บางส่วนเป็น ARM บางส่วนเป็น 64-bit ก็ใช้งานได้เช่นกัน หรือที่เรียกว่า &lt;a href=&quot;https://blogs.windows.com/windowsdeveloper/2021/06/28/announcing-arm64ec-building-native-and-interoperable-apps-for-windows-11-on-arm/&quot;&gt;ARM64EC (ย่อมาจาก ARM64 Emulation Compatible)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;สาเหตุที่รองรับเนื่องมาจากว่าแอพในปัจจุบันเปลี่ยนมาใช้งานบน 64-bit มากขึ้น และทางบริษัทได้รับ Feedback จากลูกค้าว่าต้องการให้รองรับการใช้งานแอพลักษณะนี้ครับ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี ที่รองรับการใช้งานในลักษณะนี้มีเฉพาะแอพเท่านั้น ไม่รองรับ Driver ที่เป็น x86 32-bit หรือ 64-bit แต่อย่างใด เราลองติดตั้งแอพหนึ่งที่เป็น 64-bit เช่น Cloudflare WARP แล้ว ก็เปิดแอพ เห็นหน้าต่างได้ตามปกติ แต่เปิดใช้งาน VPN ไม่ได้เพราะเครื่องนั้นไม่รองรับ Driver ที่เป็น x86 64-bit ครับ&lt;/p&gt;

&lt;p&gt;ส่วนใครที่จะเอาไปเล่นเกมที่เป็น 64-bit ทั้งเกมออนไลน์ หรือออฟไลน์ อาจจะต้องเช็คตัว Anti-cheat ว่ารองรับหรือเปล่า ถ้าเปิดได้ อาจจะต้องดูรันไหวไหม เพราะเกม AAA ต้องการสเปคที่สูง ส่วนเกมที่แข่ง e-sport อันนี้เราไม่เคยเล่น เลยบอกไม่ได้ครับ&lt;/p&gt;

&lt;p&gt;ส่วนแอพอื่น เรายังไม่ได้ทดลองใช้งาน เพราะว่าแอพที่ใช้งานในปัจจุบันรองรับการทำงานบนซีพียู ARM/ARM64 เกือบหมดแล้ว บางตัวเป็น x86 32-bit ครับ โดยแอพที่ใช้อยู่ได้แก่&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;แอพสำหรับประชุม หรือ Video Conference เช่น Microsoft Teams, Zoom&lt;/li&gt;
  &lt;li&gt;แอพที่ไว้พัฒนาแอพ เช่น Visual Studio Code&lt;/li&gt;
  &lt;li&gt;เว็บเบราวเซอร์ เช่น Microsoft Edge, Mozilla Firefox&lt;/li&gt;
  &lt;li&gt;แอพแต่งภาพ เช่น Adobe Lightroom, Adobe Photoshop&lt;/li&gt;
  &lt;li&gt;แอพออฟฟิส เช่น Office 365&lt;/li&gt;
  &lt;li&gt;Linux เช่น Windows Subsystem for Linux 2 อย่าง Ubuntu&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;แอพเกือบทั้งหมดนี้ ได้กล่าวถึงไปแล้วในหน้า &lt;a href=&quot;https://nickuntitled.com/2021/05/20/surface-pro-x-application-problem-solution/&quot;&gt;“Surface Pro X กับแอพที่ใช้งานอยู่ในขณะนี้”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ บางแอพเปิดแล้วมันไม่ติด เช่นแอพ LINE (ที่มีฟีเจอร์หลายอย่างมาก ยกเว้นเป็นแอพแชทที่ดี) อันนี้ยังไม่ได้ลองติดตั้งใหม่อีกทีว่าใช้ได้ไหม ถ้าไม่ได้ ก็อาจจะเปลี่ยนมาใช้บนมือถืออย่างเดียว แล้วเวลาที่รับไฟล์ เราค่อยอัพผ่าน OneDrive อีกที&lt;/p&gt;

&lt;h3 id=&quot;4-คีย์บอร์ด&quot;&gt;4. คีย์บอร์ด&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/onscreenkeyboard.png&quot; alt=&quot;On Screen Keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;เวลาที่เราใช้งานบนแท็บเล็ต แล้วเอานิ้วแตะกล่องข้อความที่ปรากฏบนหน้าจอ สิ่งที่เราพบได้บ่อยที่สุดคือ On-screen keyboard&lt;/p&gt;

&lt;p&gt;On-screen keyboard เป็นแป้นพิมพ์เสมือนที่ปรากฏบนหน้าจอ มีหน้าจอที่ให้เรากดปุ่มตัวอักษรที่อยู่บนหน้าจอ แล้วตัวอักษรนั้นจะปรากฏบนกล่องข้อความนั้น ๆ หรืออาจจะกดปุ่มบนหน้าจอเพื่อใช้งาน Shortcut ได้ตามที่ต้องการ&lt;/p&gt;

&lt;p&gt;ฟังก์ชันนี้ในระบบปฏิบัติการ Windows 11 มีมาให้เช่นกัน หน้าตาที่สวยขึ้นมากกว่าเดิม สามารถปรับให้เป็นคีย์บอร์ดขนาดเล็กแบบที่พิมพ์บนมือถือได้ และยังรองรับการเขียนข้อความได้อีก อย่างไรก็ดีฟังก์ชันทั้งสองนี้ไม่รองรับภาษาไทย ผิดกับของซัมซุง (ที่เราใช้อยู่) ที่รองรับความสามารถทั้งสองอย่างเลย และสามารถใช้ปากกา S-Pen เขียนข้อความเป็นภาษาไทยได้อีก&lt;/p&gt;

&lt;p&gt;ส่วนเราสามารถเพิ่ม Layout ที่ไม่ได้ติดมาในวินโดว์ได้ไหม อันนี้ไม่ได้ลอง เดี๋ยวค่อยเอา&lt;a href=&quot;https://manoonchai.com/&quot;&gt;แป้นพิมพ์มนูญชัย&lt;/a&gt;มาเพิ่มแล้วว่ามันใช้ได้ไหม ถ้าได้ก็โอเค&lt;/p&gt;

&lt;h3 id=&quot;5-dark-mode&quot;&gt;5. Dark Mode&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/darkmode.png&quot; alt=&quot;Dark Mode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ธีมบนระบบปฏิบัติการ Windows 11 รองรับการใช้งานธีมที่เป็น Dark Mode (ธีมสีออกเทา ๆ ดำ ๆ ครับ) ธีมนี้ทำให้เราสามารถใช้งานได้สบายตาขึ้นมากกว่าเดิม และลดปริมาณแสงที่ออกมาจากหน้าจอครับ รวมถึงประหยัดแบตด้วยครับ&lt;/p&gt;

&lt;p&gt;ความสามารถนี้มีมาตั้งแต่ใน Windows 10 แล้ว เพียงแต่บน Windows 11 ทำงานได้ดีขึ้นมากกว่าเดิม&lt;/p&gt;

&lt;p&gt;การเปิดใช้งาน คลิกขวาที่หน้า Desktop -&amp;gt; Personalize -&amp;gt; Colors -&amp;gt; แล้วเลือกตรงช่อง Choose your mode จาก Light ให้เป็น Dark ครับ&lt;/p&gt;

&lt;h3 id=&quot;6-หน้าต่าง-explorer&quot;&gt;6. หน้าต่าง Explorer&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://asset.nickuntitled.com/2021/10/explorer.png&quot; alt=&quot;Windows 11 explorer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;หน้าต่าง Explorer บนระบบปฏิบัติการ Windows 11 ที่มันดูไม่ค่อยรกแบบตอนที่ใช้บน Windows 8, 8.1 และ 10 แถมจุดหนึ่งที่เราว่ามันดีกว่าเดิม คือมันสามารถเปิดดูโฟลเดอร์บน Windows Subsystem for Linux ได้เลย สะดวกเวลาขึ้นเวลาที่ถ่ายโอนไฟล์ครับ&lt;/p&gt;

&lt;p&gt;นอกเหนือจากนี้ หน้าตาของหน้าต่างนี้ รวมถึงไอคอนที่ดูทันสมัยกว่ารุ่นก่อน ๆ ครับ&lt;/p&gt;

&lt;p&gt;ส่วนรายละเอียดเพิ่มเติม สามารถ &lt;a href=&quot;https://www.windowscentral.com/whats-new-file-explorer-windows-11&quot;&gt;อ่านได้ที่ลิ้งค์นี้ครับ&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;7-แอพ-android&quot;&gt;7. แอพ Android&lt;/h3&gt;

&lt;p&gt;ความสามารถหนึ่งที่ช่วงเปิดตัว Windows 11 ก็คือรองรับการติดตั้งแอพ Android ที่มีให้โหลดใน Amazon App Store อันนี้มาไม่ทันตอนที่ปล่อย Windows 11&lt;/p&gt;

&lt;p&gt;อย่างไรก็ดี ความสามารถนี้ได้ปล่อยออกมาใน Windows Insider แล้ว อีกไม่นานคงได้ปล่อยมาให้อัพเดทต่อ ๆ ไป และตอนที่ปล่อยออกมาแล้ว เรามีแอพที่อยากจะลงอยู่ และมีให้โหลดใน Amazon App Store ทีนี้เราจะได้ใช้งานได้สะดวกขึ้นมากกว่าเดิมครับ&lt;/p&gt;

&lt;p&gt;ส่วน Google Play ตอนนี้มีคนพยายามลงแล้วก็พบว่าลงได้แล้ว &lt;a href=&quot;https://droidsans.com/how-to-install-google-play-store-on-windows-11-pc/&quot;&gt;ส่วนวิธีดูได้ที่ลิ้งค์นี้ครับ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;บัค&quot;&gt;บัค&lt;/h2&gt;

&lt;p&gt;เวลาที่ใช้งาน Windows 11 บนเครื่องที่ใช้ซีพียู ARM แบบ Surface Pro X มันก็มีบัค เวลาที่ใช้งาน ตัววินโดว์จะค้างไปเองแบบไม่มีปี่ไม่มีขลุ่ย รวมถึงทำงานได้ช้ากว่าตอน Windows 10&lt;/p&gt;

&lt;p&gt;ผิดกับตอนที่เราใช้ macOS เลย อันนี้เวลาที่อัพเดทแล้วไม่ค่อยค้างเท่าไร ยกเว้นแต่ CPU เก่าเกินไป ทำงานได้ช้าครับ :P&lt;/p&gt;

&lt;h2 id=&quot;สรุป&quot;&gt;สรุป&lt;/h2&gt;

&lt;p&gt;Windows 11 เป็นระบบปฏิบัติการของไมโครซอฟท์ที่ปล่อยออกมาแล้วช่วงต้นเดือนตุลาคมที่ผ่านมา เราอัพเกรตลงบน Surface Pro X แล้วพบว่าการใช้งานหลายส่วนใช้งานได้ดีขึ้น แต่มีบางส่วนที่ยังขาด ๆ เกิน ๆ อยู่ อันนี้อาจจะต้องรอทางไมโครซอฟท์แก้ไข แล้วอัพเดทอีกทีนึงครับ&lt;/p&gt;

&lt;p&gt;สำหรับคนที่ใช้ Windows 10 อยู่ แล้วใช้คอมที่เป็นซีพียู ARM อันนี้เราแนะนำให้อัพเดทครับ จะได้ใช้แอพที่มีอยู่ในปัจจุบันที่รองรับ x86 64-bit ครับ&lt;/p&gt;</content><author><name>nickuntitled</name></author><category term="Computer" /><category term="Diary" /><category term="Windows" /><category term="Windows 11" /><category term="Microsoft" /><category term="Surface" /><category term="Surface Pro X" /><category term="Laptop" /><category term="Tablet" /><category term="ARM" /><category term="ARM64" /><category term="Upgrade" /><category term="Installation" /><category term="Apps" /><category term="UEFI" /><category term="TPM" /><category term="Trusted Platform Module" /><category term="BIOS" /><summary type="html">หลังจากที่วินโดว์ 11 ปล่อยออกมาให้อัพเกรตแล้ว ทีนี้รอจนกระทั่งไมโครซอฟท์ปล่อยให้อัพบน Windows Update ในบทความนี้กล่าวถึงการใช้งาน และแอพบนอุปกรณ์ที่ใช้อยู่</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://asset.nickuntitled.com/2021/10/windows11_cover.jpg" /><media:content medium="image" url="https://asset.nickuntitled.com/2021/10/windows11_cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>